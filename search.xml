<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>reversing.kr:Easy_crack</title>
      <link href="/2019/07/23/%C2%96%C2%96reversing-kr-Easy-crack/"/>
      <url>/2019/07/23/%C2%96%C2%96reversing-kr-Easy-crack/</url>
      
        <content type="html"><![CDATA[<p>#####打开程序</p><p><img src="https://raw.githubusercontent.com/leave-Devour/leave-Devour.github.io/master/images/20190723214824.png" alt></p><pre><code>猜想：会不会是单纯的一个一个的字符的验证呢？</code></pre><p>######放进Ollydbg</p><pre><code>查找关键字</code></pre><p><img src="https://raw.githubusercontent.com/leave-Devour/leave-Devour.github.io/master/images/20190723215545.png" alt></p><pre><code>看到congratulation，果断跟进去，断在入口处，这题就ok啦；</code></pre><hr><pre><code>00401080  /$  83EC 64       sub esp,0x6400401083  |.  57            push edi00401084  |.  B9 18000000   mov ecx,0x1800401089  |.  33C0          xor eax,eax0040108B  |.  8D7C24 05     lea edi,dword ptr ss:[esp+0x5]0040108F  |.  C64424 04 00  mov byte ptr ss:[esp+0x4],0x000401094  |.  6A 64         push 0x64                                ; /Count = 64 (100.)00401096  |.  F3:AB         rep stos dword ptr es:[edi]              ; |00401098  |.  66:AB         stos word ptr es:[edi]                   ; |0040109A  |.  AA            stos byte ptr es:[edi]                   ; |0040109B  |.  8B7C24 70     mov edi,dword ptr ss:[esp+0x70]          ; |user32.76DC635B0040109F  |.  8D4424 08     lea eax,dword ptr ss:[esp+0x8]           ; |004010A3  |.  50            push eax                                 ; |Buffer = 00000001004010A4  |.  68 E8030000   push 0x3E8                               ; |ControlID = 3E8 (1000.)004010A9  |.  57            push edi                                 ; |hWnd = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)004010AA  |.  FF15 9C504000 call dword ptr ds:[&lt;&amp;USER32.GetDlgItemTe&gt;; \GetDlgItemTextA004010B0  |.  807C24 05 61  cmp byte ptr ss:[esp+0x5],0x61           ;  第二個字符004010B5  |.  75 7E         jnz short Easy_Cra.00401135004010B7  |.  6A 02         push 0x2004010B9  |.  8D4C24 0A     lea ecx,dword ptr ss:[esp+0xA]004010BD  |.  68 78604000   push Easy_Cra.00406078                   ;  5y004010C2  |.  51            push ecx004010C3  |.  E8 88000000   call Easy_Cra.00401150                   ;  第三 第四字符004010C8  |.  83C4 0C       add esp,0xC004010CB  |.  85C0          test eax,eax004010CD  |.  75 66         jnz short Easy_Cra.00401135004010CF  |.  53            push ebx004010D0  |.  56            push esi004010D1  |.  BE 6C604000   mov esi,Easy_Cra.0040606C                ;  R3versing004010D6  |.  8D4424 10     lea eax,dword ptr ss:[esp+0x10]004010DA  |&gt;  8A10          /mov dl,byte ptr ds:[eax]                ;  這裡判斷第五個字符到最後004010DC  |.  8A1E          |mov bl,byte ptr ds:[esi]004010DE  |.  8ACA          |mov cl,dl004010E0  |.  3AD3          |cmp dl,bl004010E2  |.  75 1E         |jnz short Easy_Cra.00401102004010E4  |.  84C9          |test cl,cl004010E6  |.  74 16         |je short Easy_Cra.004010FE004010E8  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]004010EB  |.  8A5E 01       |mov bl,byte ptr ds:[esi+0x1]004010EE  |.  8ACA          |mov cl,dl004010F0  |.  3AD3          |cmp dl,bl004010F2  |.  75 0E         |jnz short Easy_Cra.00401102004010F4  |.  83C0 02       |add eax,0x2004010F7  |.  83C6 02       |add esi,0x2004010FA  |.  84C9          |test cl,cl004010FC  |.^ 75 DC         \jnz short Easy_Cra.004010DA004010FE  |&gt;  33C0          xor eax,eax00401100  |.  EB 05         jmp short Easy_Cra.0040110700401102  |&gt;  1BC0          sbb eax,eax00401104  |.  83D8 FF       sbb eax,-0x100401107  |&gt;  5E            pop esi00401108  |.  5B            pop ebx00401109  |.  85C0          test eax,eax0040110B  |.  75 28         jnz short Easy_Cra.004011350040110D  |.  807C24 04 45  cmp byte ptr ss:[esp+0x4],0x45           ;  第一個字符00401112  |.  75 21         jnz short Easy_Cra.0040113500401114  |.  6A 40         push 0x40                                ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL00401116  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe0040111B  |.  68 44604000   push Easy_Cra.00406044                   ; |Congratulation !!00401120  |.  57            push edi                                 ; |hOwner = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)00401121  |.  FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA00401127  |.  6A 00         push 0x0                                 ; /Result = 0x000401129  |.  57            push edi                                 ; |hWnd = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)0040112A  |.  FF15 A4504000 call dword ptr ds:[&lt;&amp;USER32.EndDialog&gt;]  ; \EndDialog00401130  |.  5F            pop edi00401131  |.  83C4 64       add esp,0x6400401134  |.  C3            retn00401135  |&gt;  6A 10         push 0x10                                ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL00401137  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe0040113C  |.  68 30604000   push Easy_Cra.00406030                   ; |Incorrect Password00401141  |.  57            push edi                                 ; |hOwner = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)00401142  |.  FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA00401148  |.  5F            pop edi00401149  |.  83C4 64       add esp,0x640040114C  \.  C3            retn</code></pre><hr><pre><code>最后得出的password就是：Ea5yR3versing</code></pre>]]></content>
      
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr——input</title>
      <link href="/2019/07/23/Pwnable-kr-input/"/>
      <url>/2019/07/23/Pwnable-kr-input/</url>
      
        <content type="html"><![CDATA[<h2 id="放出源码"><a href="#放出源码" class="headerlink" title="放出源码"></a>放出源码</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[]){    printf(&quot;Welcome to pwnable.kr\n&quot;);    printf(&quot;Let&apos;s see if you know how to give input to program\n&quot;);    printf(&quot;Just give me correct inputs then you will get the flag :)\n&quot;);    //argc    if(argc != 100) return 0;    if(strcmp(argv[&apos;A&apos;],&quot;\x00&quot;)) return 0;    if(strcmp(argv[&apos;B&apos;],&quot;\x20\x0a\x0d&quot;)) return 0;    printf(&quot;Stage 1 clear!\n&quot;);        // stdio    char buf[4];    read(0, buf, 4);    if(memcmp(buf, &quot;\x00\x0a\x00\xff&quot;, 4)) return 0;    read(2, buf, 4);        if(memcmp(buf, &quot;\x00\x0a\x02\xff&quot;, 4)) return 0;    printf(&quot;Stage 2 clear!\n&quot;);    // env    if(strcmp(&quot;\xca\xfe\xba\xbe&quot;, getenv(&quot;\xde\xad\xbe\xef&quot;))) return 0;    printf(&quot;Stage 3 clear!\n&quot;);    // file    FILE* fp = fopen(&quot;\x0a&quot;, &quot;r&quot;);    if(!fp) return 0;    if( fread(buf, 4, 1, fp)!=1 ) return 0;    if( memcmp(buf, &quot;\x00\x00\x00\x00&quot;, 4) ) return 0;    fclose(fp);    printf(&quot;Stage 4 clear!\n&quot;);        // network    int sd, cd;    struct sockaddr_in saddr, caddr;    sd = socket(AF_INET, SOCK_STREAM, 0);    if(sd == -1){        printf(&quot;socket error, tell admin\n&quot;);        return 0;    }    saddr.sin_family = AF_INET;    saddr.sin_addr.s_addr = INADDR_ANY;    saddr.sin_port = htons( atoi(argv[&apos;C&apos;]) );    if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){        printf(&quot;bind error, use another port\n&quot;);            return 1;    }    listen(sd, 1);    int c = sizeof(struct sockaddr_in);    cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c);    if(cd &lt; 0){        printf(&quot;accept error, tell admin\n&quot;);        return 0;    }    if( recv(cd, buf, 4, 0) != 4 ) return 0;    if(memcmp(buf, &quot;\xde\xad\xbe\xef&quot;, 4)) return 0;    printf(&quot;Stage 5 clear!\n&quot;);    // here&apos;s your flag    system(&quot;/bin/cat flag&quot;);        return 0;</code></pre><p>}</p><p>—可以看出前面有5个地方需要绕过的。</p><pre><code>1：就是argc和argv2：stdin和stderr3：env4：存在文件\x0a 5：socket通信</code></pre><h3 id="记录下一些get到的知识点"><a href="#记录下一些get到的知识点" class="headerlink" title="记录下一些get到的知识点"></a>记录下一些get到的知识点</h3><pre><code>1、用pipe创建管道，试两个进程间进行通信2、用fork创建进程</code></pre><hr><pre><code>int writepipe[2] = {-1,-1}, /* parent -&gt; child */    readpipe [2] = {-1,-1}; /* child -&gt; parent */pid_t   childpid;/*------------------------------------------------------------------------ * CREATE THE PAIR OF PIPES * * Pipes have two ends but just one direction: to get a two-way * conversation you need two pipes. It&apos;s an error if we cannot make * them both, and we define these macros for easy reference. */writepipe[0] = -1;if ( pipe(readpipe) &lt; 0  ||  pipe(writepipe) &lt; 0 ){    /* FATAL: cannot create pipe */    /* close readpipe[0] &amp; [1] if necessary */}#define PARENT_READ readpipe[0]#define CHILD_WRITE readpipe[1]#define CHILD_READ  writepipe[0]#define PARENT_WRITE    writepipe[1]if ( (childpid = fork()) &lt; 0){    /* FATAL: cannot fork child */}else if ( childpid == 0 )   /* in the child */{    close(PARENT_WRITE);    close(PARENT_READ);    dup2(CHILD_READ,  0);  close(CHILD_READ);    dup2(CHILD_WRITE, 1);  close(CHILD_WRITE);    /* do child stuff */}else                /* in the parent */{    close(CHILD_READ);    close(CHILD_WRITE);    /* do parent stuff */}</code></pre><hr><pre><code>首先fork()创建的进程(&quot;即当前的进程的镜像&quot;),两者的初始状态一样，执行互不干扰。另外fork() 复制程序时不是从** #include **处开始复制的，因为fork是把进程当前的情况拷贝一份，所以执行fork()，前面的已经执行完了，fork()只拷贝下一行代码到新进程。</code></pre><hr><pre><code>pipe(int fd[2])函数可以得到两个file descriptors 形成一个单向的pipe,fd[0]固定为读端，fd[1]固定为写端。具体可以参考：http://unixwiz.net/techtips/remap-pipe-fds.html</code></pre><hr><pre><code>另外 execv家族有很多，其中的execve()可以控制传进去的envp,envint execve(const char *filename, char *const argv[ ], char *const envp[ ]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
